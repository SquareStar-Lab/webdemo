import{A as fs,O as ys,L as Yt,x as Jt,E as Ht}from"./rapier-7f742b17.js";import{V as m,C as gA,P as Kn,M as $A,R as bt,S as NA,a as le,T as lt,B as kt,W as Ee,N as ln,b as En,U as Sn,O as Rn,c as HA,d as fA,e as Ce,Q as IA,D as XA,f as ms,g as ZA,h as In,I as ws,i as mn,j as he,k as Ds,l as xs,G as ue,m as Ss,n as de,o as pe,p as cn,q as Ms,L as bs,r as ks,s as Fs,t as Cn,u as Rs,v as Ns,w as qt,x as qA,y as Pn,z as vs,A as Gs,E as Ls,F as Us,H as Et,J as fe,K as _s,X as wn,Y as ye,Z as GA,_ as Ts,$ as me,a0 as we,a1 as dn,a2 as MA,a3 as Ys,a4 as De,a5 as Js,a6 as Hs,a7 as Ct,a8 as xe,a9 as ht,aa as qs,ab as $n,ac as zs,ad as Ks,ae as Ps,af as Os,ag as js,ah as Vs,ai as Xs,aj as Zs,ak as At,al as Se,am as Ws,an as $s,ao as Ai,ap as ni,aq as Me,ar as zt,as as ti,at as ei,au as si,av as ii,aw as ai,ax as ri,ay as be,az as oi,aA as Kt,aB as Pt,aC as Ot,aD as gi,aE as Ii,aF as ci,aG as Bi,aH as Qi,aI as li,aJ as Ei,aK as Ci}from"./three-fae381eb.js";(function(){const A=document.createElement("link").relList;if(A&&A.supports&&A.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))t(e);new MutationObserver(e=>{for(const i of e)if(i.type==="childList")for(const a of i.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&t(a)}).observe(document,{childList:!0,subtree:!0});function n(e){const i={};return e.integrity&&(i.integrity=e.integrity),e.referrerPolicy&&(i.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?i.credentials="include":e.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function t(e){if(e.ep)return;e.ep=!0;const i=n(e);fetch(e.href,i)}})();let vA;const ke=typeof TextDecoder<"u"?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};typeof TextDecoder<"u"&&ke.decode();let pn=null;function hi(){return(pn===null||pn.byteLength===0)&&(pn=new Uint8Array(vA.memory.buffer)),pn}function ui(s,A){return s=s>>>0,ke.decode(hi().subarray(s,s+A))}function di(s,A,n,t,e,i,a,r,o,g,c){return vA.raycast_splats(s,A,n,t,e,i,a,r,o,g,c)}async function pi(s,A){if(typeof Response=="function"&&s instanceof Response){if(typeof WebAssembly.instantiateStreaming=="function")try{return await WebAssembly.instantiateStreaming(s,A)}catch(t){if(s.headers.get("Content-Type")!="application/wasm")console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",t);else throw t}const n=await s.arrayBuffer();return await WebAssembly.instantiate(n,A)}else{const n=await WebAssembly.instantiate(s,A);return n instanceof WebAssembly.Instance?{instance:n,module:s}:n}}function fi(){const s={};return s.wbg={},s.wbg.__wbg_buffer_609cc3eee51ed158=function(A){return A.buffer},s.wbg.__wbg_length_3b4f022188ae8db6=function(A){return A.length},s.wbg.__wbg_length_6ca527665d89694d=function(A){return A.length},s.wbg.__wbg_length_8cfd2c6409af88ad=function(A){return A.length},s.wbg.__wbg_new_9fee97a409b32b68=function(A){return new Uint16Array(A)},s.wbg.__wbg_new_e3b321dcfef89fc7=function(A){return new Uint32Array(A)},s.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354=function(A,n,t){return new Float32Array(A,n>>>0,t>>>0)},s.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212=function(A,n,t){return new Uint32Array(A,n>>>0,t>>>0)},s.wbg.__wbg_newwithlength_5a5efe313cfd59f1=function(A){return new Float32Array(A>>>0)},s.wbg.__wbg_set_10bad9bee0e9c58b=function(A,n,t){A.set(n,t>>>0)},s.wbg.__wbg_set_d23661d19148b229=function(A,n,t){A.set(n,t>>>0)},s.wbg.__wbg_set_f4f1f0daa30696fc=function(A,n,t){A.set(n,t>>>0)},s.wbg.__wbg_subarray_3aaeec89bb2544f0=function(A,n,t){return A.subarray(n>>>0,t>>>0)},s.wbg.__wbg_subarray_769e1e0f81bb259b=function(A,n,t){return A.subarray(n>>>0,t>>>0)},s.wbg.__wbindgen_init_externref_table=function(){const A=vA.__wbindgen_export_0,n=A.grow(4);A.set(0,void 0),A.set(n+0,void 0),A.set(n+1,null),A.set(n+2,!0),A.set(n+3,!1)},s.wbg.__wbindgen_memory=function(){return vA.memory},s.wbg.__wbindgen_throw=function(A,n){throw new Error(ui(A,n))},s}function yi(s,A){return vA=s.exports,Fe.__wbindgen_wasm_module=A,pn=null,vA.__wbindgen_start(),vA}async function Fe(s){if(vA!==void 0)return vA;typeof s<"u"&&(Object.getPrototypeOf(s)===Object.prototype?{module_or_path:s}=s:console.warn("using deprecated parameters for the initialization function; pass a single object instead")),typeof s>"u"&&(s=new URL("data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUF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BSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIM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AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSAN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IABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9v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Zm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2Yg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",self.location));const A=fi();(typeof s=="string"||typeof Request=="function"&&s instanceof Request||typeof URL=="function"&&s instanceof URL)&&(s=fetch(s));const{instance:n,module:t}=await pi(await s,A);return yi(n,t)}const WA=-9,mi=9,Bn=(mi-WA)/254,wi=11,Di=11,T=1<<wi,PA=1<<Di,xi=1;function Si(s){return s==="bool"||s==="bvec2"||s==="bvec3"||s==="bvec4"}function OA(s){return s==="int"||s==="ivec2"||s==="ivec3"||s==="ivec4"}function jA(s){return s==="uint"||s==="uvec2"||s==="uvec3"||s==="uvec4"}function Mi(s){return s==="float"||s==="vec2"||s==="vec3"||s==="vec4"}function bi(s){return s==="mat2"||s==="mat2x2"||s==="mat2x3"||s==="mat2x4"||s==="mat3"||s==="mat3x2"||s==="mat3x3"||s==="mat3x4"||s==="mat4"||s==="mat4x2"||s==="mat4x3"||s==="mat4x4"}function Mn(s){return Mi(s)||bi(s)}function nn(s){return s==="mat2"||s==="mat2x2"}function tn(s){return s==="mat3"||s==="mat3x3"}function en(s){return s==="mat4"||s==="mat4x4"}function ki(s){switch(s){case"vec2":return"float";case"vec3":return"float";case"vec4":return"float";case"ivec2":return"int";case"ivec3":return"int";case"ivec4":return"int";case"uvec2":return"uint";case"uvec3":return"uint";case"uvec4":return"uint";default:throw new Error(`Invalid vector type: ${s}`)}}function Fi(s){switch(s){case"vec2":case"ivec2":case"uvec2":return 2;case"vec3":case"ivec3":case"uvec3":return 3;case"vec4":case"ivec4":case"uvec4":return 4;default:throw new Error(`Invalid vector type: ${s}`)}}function X(s){return Math.trunc(s).toString()}function Z(s){return`${Math.max(0,Math.trunc(s)).toString()}u`}function G(s){return s===Number.POSITIVE_INFINITY?"INFINITY":s===Number.NEGATIVE_INFINITY?"-INFINITY":Number.isInteger(s)?s.toFixed(1):s.toString()}function JA(s){return s instanceof VA?s.type:s.dynoOut().type}class VA{constructor(A){this.__isDynoValue=!0,this.type=A}}class QA extends VA{constructor(A,n){super(A.outTypes[n]),this.dyno=A,this.key=n}}class Jn extends VA{constructor(A,n){super(A),this.literal=n}getLiteral(){return this.literal}}class Ri extends Jn{constructor(A,n){super(A,""),this.value=n}getLiteral(){const{type:A,value:n}=this;switch(A){case"bool":return n?"true":"false";case"uint":return Z(n);case"int":return X(n);case"float":return G(n);case"bvec2":{const t=n;return`bvec2(${t[0]}, ${t[1]})`}case"uvec2":{if(n instanceof cn)return`uvec2(${Z(n.x)}, ${Z(n.y)})`;const t=n;return`uvec2(${Z(t[0])}, ${Z(t[1])})`}case"ivec2":{if(n instanceof cn)return`ivec2(${X(n.x)}, ${X(n.y)})`;const t=n;return`ivec2(${X(t[0])}, ${X(t[1])})`}case"vec2":{if(n instanceof cn)return`vec2(${G(n.x)}, ${G(n.y)})`;const t=n;return`vec2(${G(t[0])}, ${G(t[1])})`}case"bvec3":{const t=n;return`bvec3(${t[0]}, ${t[1]}, ${t[2]})`}case"uvec3":{if(n instanceof m)return`uvec3(${Z(n.x)}, ${Z(n.y)}, ${Z(n.z)})`;const t=n;return`uvec3(${Z(t[0])}, ${Z(t[1])}, ${Z(t[2])})`}case"ivec3":{if(n instanceof m)return`ivec3(${X(n.x)}, ${X(n.y)}, ${X(n.z)})`;const t=n;return`ivec3(${X(t[0])}, ${X(t[1])}, ${X(t[2])})`}case"vec3":{if(n instanceof m)return`vec3(${G(n.x)}, ${G(n.y)}, ${G(n.z)})`;const t=n;return`vec3(${G(t[0])}, ${G(t[1])}, ${G(t[2])})`}case"bvec4":{const t=n;return`bvec4(${t[0]}, ${t[1]}, ${t[2]}, ${t[3]})`}case"uvec4":{if(n instanceof HA)return`uvec4(${Z(n.x)}, ${Z(n.y)}, ${Z(n.z)}, ${Z(n.w)})`;const t=n;return`uvec4(${Z(t[0])}, ${Z(t[1])}, ${Z(t[2])}, ${Z(t[3])})`}case"ivec4":{if(n instanceof HA)return`ivec4(${X(n.x)}, ${X(n.y)}, ${X(n.z)}, ${X(n.w)})`;const t=n;return`ivec4(${X(t[0])}, ${X(t[1])}, ${X(t[2])}, ${X(t[3])})`}case"vec4":{if(n instanceof HA)return`vec4(${G(n.x)}, ${G(n.y)}, ${G(n.z)}, ${G(n.w)})`;if(n instanceof IA)return`vec4(${G(n.x)}, ${G(n.y)}, ${G(n.z)}, ${G(n.w)})`;const t=n;return`vec4(${G(t[0])}, ${G(t[1])}, ${G(t[2])}, ${G(t[3])})`}case"mat2":case"mat2x2":{const t=n,e=t instanceof Ns?t.elements:n,i=new Array(4).fill(0).map((a,r)=>G(e[r]));return`${A}(${i.join(", ")})`}case"mat2x3":{const t=n,e=new Array(6).fill(0).map((i,a)=>G(t[a]));return`${A}(${e.join(", ")})`}case"mat2x4":{const t=n,e=new Array(8).fill(0).map((i,a)=>G(t[a]));return`${A}(${e.join(", ")})`}case"mat3":case"mat3x3":{const t=n,e=t instanceof Ce?t.elements:n,i=new Array(9).fill(0).map((a,r)=>G(e[r]));return`${A}(${i.join(", ")})`}case"mat3x2":{const t=n,e=new Array(6).fill(0).map((i,a)=>G(t[a]));return`${A}(${e.join(", ")})`}case"mat3x4":{const t=n,e=new Array(12).fill(0).map((i,a)=>G(t[a]));return`${A}(${e.join(", ")})`}case"mat4":case"mat4x4":{const t=n,e=t instanceof fA?t.elements:n,i=new Array(16).fill(0).map((a,r)=>G(e[r]));return`${A}(${i.join(", ")})`}case"mat4x2":{const t=n,e=new Array(8).fill(0).map((i,a)=>G(t[a]));return`${A}(${e.join(", ")})`}case"mat4x3":{const t=n,e=new Array(12).fill(0).map((i,a)=>G(t[a]));return`${A}(${e.join(", ")})`}default:throw new Error(`Type not implemented: ${String(A)}`)}}}function ut(s,A){return new Ri(s,A)}function vn(s){const A=String(s);if(Si(s))return`${A}(false)`;if(Mn(s))return`${A}(0.0)`;if(OA(s))return`${A}(0)`;if(jA(s))return`${A}(0u)`;throw new Error(`Type not implemented: ${A}`)}const jt="    ";class Ni{constructor({indent:A}={}){this.globals=new Set,this.statements=[],this.uniforms={},this.declares=new Set,this.updaters=[],this.sequence=0,this.indent=jt,this.indent=A??jt}nextSequence(){return this.sequence++}}class tA{constructor({inTypes:A,outTypes:n,inputs:t,update:e,globals:i,statements:a,generate:r}){this.inTypes=A??{},this.outTypes=n??{},this.inputs=t??{},this.update=e,this.globals=i,this.statements=a,this.generate=r??(({inputs:o,outputs:g,compile:c})=>{var I,B;return{globals:(I=this.globals)==null?void 0:I.call(this,{inputs:o,outputs:g,compile:c}),statements:(B=this.statements)==null?void 0:B.call(this,{inputs:o,outputs:g,compile:c})}})}get outputs(){const A={};for(const n in this.outTypes)A[n]=new QA(this,n);return A}apply(A){return Object.assign(this.inputs,A),this.outputs}compile({inputs:A,outputs:n,compile:t}){const e=[`// ${this.constructor.name}(${Object.values(A).join(", ")}) => (${Object.values(n).join(", ")})`],i=[];for(const g in n){const c=n[g];c&&!t.declares.has(c)&&(t.declares.add(c),i.push(g))}const{globals:a,statements:r,uniforms:o}=this.generate({inputs:A,outputs:n,compile:t});for(const g of a??[])t.globals.add(g);for(const g in o)t.uniforms[g]=o[g];this.update&&t.updaters.push(this.update);for(const g of i){const c=n[g];c&&(t.uniforms[c]||e.push(`${Re(c,this.outTypes[g])};`))}return r?.length&&(e.push("{"),e.push(...r.map(g=>t.indent+g)),e.push("}")),e}}class vi extends tA{constructor({inTypes:A,outTypes:n,inputs:t,update:e,globals:i,construct:a}){super({inTypes:A,outTypes:n,inputs:t,update:e,globals:i,generate:r=>this.generateBlock(r)}),this.construct=a}generateBlock({inputs:A,outputs:n,compile:t}){var e,i;const a={},r={};for(const E in A)A[E]!=null&&(a[E]=new Jn(this.inTypes[E],A[E]));for(const E in n)n[E]!=null&&(r[E]=new VA(this.outTypes[E]));const o={roots:[]},g=this.construct(a,r,o);for(const E of((e=this.globals)==null?void 0:e.call(this,{inputs:A,outputs:n,compile:t}))??[])t.globals.add(E);const c=[],I=new Map;function B(E,h,f){let u=I.get(E);if(!u){u={sequence:t.nextSequence(),outNames:new Map,newOuts:new Set},I.set(E,u);for(const y in E.inputs){let w=E.inputs[y];for(;w;){if(w instanceof VA){w instanceof QA&&B(w.dyno,w.key);break}w=w.dynoOut()}}c.push(E)}h&&(f||u.newOuts.add(h),u.outNames.set(h,f??`${h}_${u.sequence}`))}for(const E of o.roots)B(E);for(const E in r){let h=g?.[E]??r[E];for(;h;){if(h instanceof VA){h instanceof QA&&B(h.dyno,h.key,n[E]);break}h=h.dynoOut()}r[E]=h}const Q=[];for(const E of c){const h={},f={};for(const w in E.inputs){let S=E.inputs[w];for(;S;){if(S instanceof VA){if(S instanceof Jn)h[w]=S.getLiteral();else if(S instanceof QA){const M=(i=I.get(S.dyno))==null?void 0:i.outNames.get(S.key);if(!M)throw new Error(`Source not found for ${S.dyno.constructor.name}.${S.key}`);h[w]=M}break}S=S.dynoOut()}}const u=I.get(E)??{outNames:new Map};for(const[w,S]of u.outNames.entries())f[w]=S;const y=E.compile({inputs:h,outputs:f,compile:t});Q.push(y)}const l=[];for(const E in n)r[E]instanceof Jn&&l.push(`${n[E]} = ${r[E].getLiteral()};`);return l.length>0&&Q.push(l),{statements:Q.flatMap((E,h)=>h===0?E:["",...E])}}}function zA(s,A,n,{update:t,globals:e}={}){return new vi({inTypes:s,outTypes:A,construct:n,update:t,globals:e})}function Xn({inTypes:s,outTypes:A,inputs:n,update:t,globals:e,statements:i,generate:a}){return new tA({inTypes:s,outTypes:A,inputs:n,update:t,globals:e,statements:i,generate:a})}function Re(s,A,n){const t=typeof A=="string"?A:A.type;if(!t)throw new Error(`Invalid DynoType: ${String(A)}`);return`${t} ${s}${n!=null?`[${n}]`:""}`}function bA(s){var A;let n=!1;const t=s.split(`
`).map(a=>{const r=a.trimEnd();return n?r:r.length>0?(n=!0,r):null}).filter(a=>a!=null);for(;t.length>0&&t[t.length-1].length===0;)t.pop();if(t.length===0)return[];const e=(A=t[0].match(/^\s*/))==null?void 0:A[0];if(!e)return t;const i=new RegExp(`^${e}`);return t.map(a=>a.replace(i,""))}function lA(s){return bA(s).join(`
`)}class Ft extends tA{constructor({a:A,outKey:n,outTypeFunc:t}){const e={a:JA(A)},i=t(JA(A)),a={[n]:i};super({inTypes:e,outTypes:a,inputs:{a:A}}),this.outKey=n}dynoOut(){return new QA(this,this.outKey)}}class Zn extends tA{constructor({a:A,b:n,outKey:t,outTypeFunc:e}){const i={a:JA(A),b:JA(n)},a=e(JA(A),JA(n)),r={[t]:a};super({inTypes:i,outTypes:r,inputs:{a:A,b:n}}),this.outKey=t}dynoOut(){return new QA(this,this.outKey)}}const W={type:"Gsplat"},Wn={type:"PackedSplats"},On=(s,A)=>new Li({packedSplats:s,index:A}),Gi=(s,A,n,t)=>new Ui({packedSplats:s,index:A,base:n,count:t}),Hn=s=>new _i({gsplat:s}),nt=({gsplat:s,flags:A,index:n,center:t,scales:e,quaternion:i,rgba:a,rgb:r,opacity:o,x:g,y:c,z:I,r:B,g:Q,b:l})=>new Ti({gsplat:s,flags:A,index:n,center:t,scales:e,quaternion:i,rgba:a,rgb:r,opacity:o,x:g,y:c,z:I,r:B,g:Q,b:l}),Ne=(s,{scale:A,rotate:n,translate:t,recolor:e})=>new Yi({gsplat:s,scale:A,rotate:n,translate:t,recolor:e}),kA=lA(`
  struct Gsplat {
    vec3 center;
    uint flags;
    vec3 scales;
    int index;
    vec4 quaternion;
    vec4 rgba;
  };
  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;

  bool isGsplatActive(uint flags) {
    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;
  }
`),Rt=lA(`
  struct PackedSplats {
    usampler2DArray texture;
    int numSplats;
  };
`),ve=lA(`
  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {
    if ((index >= 0) && (index < numSplats)) {
      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);
      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);
      return true;
    } else {
      return false;
    }
  }
`);class Li extends tA{constructor({packedSplats:A,index:n}){super({inTypes:{packedSplats:Wn,index:"int"},outTypes:{gsplat:W},inputs:{packedSplats:A,index:n},globals:()=>[kA,Rt,ve],statements:({inputs:t,outputs:e})=>{const{gsplat:i}=e;if(!i)return[];const{packedSplats:a,index:r}=t;let o;return a&&r?o=bA(`
            if (readPackedSplat(${a}.texture, ${a}.numSplats, ${r}, ${i})) {
              bool zeroSize = all(equal(${i}.scales, vec3(0.0, 0.0, 0.0)));
              ${i}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
            } else {
              ${i}.flags = 0u;
            }
          `):o=[`${i}.flags = 0u;`],o.push(`${i}.index = ${r??"0"};`),o}})}dynoOut(){return new QA(this,"gsplat")}}class Ui extends tA{constructor({packedSplats:A,index:n,base:t,count:e}){super({inTypes:{packedSplats:Wn,index:"int",base:"int",count:"int"},outTypes:{gsplat:W},inputs:{packedSplats:A,index:n,base:t,count:e},globals:()=>[kA,Rt,ve],statements:({inputs:i,outputs:a})=>{const{gsplat:r}=a;if(!r)return[];const{packedSplats:o,index:g,base:c,count:I}=i;let B;return o&&g&&c&&I?B=bA(`
            ${r}.flags = 0u;
            if ((${g} >= ${c}) && (${g} < (${c} + ${I}))) {
              if (readPackedSplat(${o}.texture, ${o}.numSplats, ${g}, ${r})) {
                bool zeroSize = all(equal(${r}.scales, vec3(0.0, 0.0, 0.0)));
                ${r}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
              }
            }
          `):B=[`${r}.flags = 0u;`],B.push(`${r}.index = ${g??"0"};`),B}})}dynoOut(){return new QA(this,"gsplat")}}class _i extends tA{constructor({gsplat:A}){super({inTypes:{gsplat:W},outTypes:{flags:"uint",active:"bool",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},inputs:{gsplat:A},globals:()=>[kA],statements:({inputs:n,outputs:t})=>{const{gsplat:e}=n,{flags:i,active:a,index:r,center:o,scales:g,quaternion:c,rgba:I,rgb:B,opacity:Q,x:l,y:C,z:E,r:h,g:f,b:u}=t;return[i?`${i} = ${e?`${e}.flags`:"0u"};`:null,a?`${a} = isGsplatActive(${e?`${e}.flags`:"0u"});`:null,r?`${r} = ${e?`${e}.index`:"0"};`:null,o?`${o} = ${e?`${e}.center`:"vec3(0.0, 0.0, 0.0)"};`:null,g?`${g} = ${e?`${e}.scales`:"vec3(0.0, 0.0, 0.0)"};`:null,c?`${c} = ${e?`${e}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)"};`:null,I?`${I} = ${e?`${e}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)"};`:null,B?`${B} = ${e?`${e}.rgba.rgb`:"vec3(0.0, 0.0, 0.0)"};`:null,Q?`${Q} = ${e?`${e}.rgba.a`:"0.0"};`:null,l?`${l} = ${e?`${e}.center.x`:"0.0"};`:null,C?`${C} = ${e?`${e}.center.y`:"0.0"};`:null,E?`${E} = ${e?`${e}.center.z`:"0.0"};`:null,h?`${h} = ${e?`${e}.rgba.r`:"0.0"};`:null,f?`${f} = ${e?`${e}.rgba.g`:"0.0"};`:null,u?`${u} = ${e?`${e}.rgba.b`:"0.0"};`:null].filter(Boolean)}})}}class Ti extends tA{constructor({gsplat:A,flags:n,index:t,center:e,scales:i,quaternion:a,rgba:r,rgb:o,opacity:g,x:c,y:I,z:B,r:Q,g:l,b:C}){super({inTypes:{gsplat:W,flags:"uint",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},outTypes:{gsplat:W},inputs:{gsplat:A,flags:n,index:t,center:e,scales:i,quaternion:a,rgba:r,rgb:o,opacity:g,x:c,y:I,z:B,r:Q,g:l,b:C},globals:()=>[kA],statements:({inputs:E,outputs:h})=>{const{gsplat:f}=h;if(!f)return[];const{gsplat:u,flags:y,index:w,center:S,scales:M,quaternion:K,rgba:L,rgb:P,opacity:_,x:j,y:eA,z:V,r:sA,g:O,b:N}=E;return[`${f}.flags = ${y??(u?`${u}.flags`:"0u")};`,`${f}.index = ${w??(u?`${u}.index`:"0")};`,`${f}.center = ${S??(u?`${u}.center`:"vec3(0.0, 0.0, 0.0)")};`,`${f}.scales = ${M??(u?`${u}.scales`:"vec3(0.0, 0.0, 0.0)")};`,`${f}.quaternion = ${K??(u?`${u}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)")};`,`${f}.rgba = ${L??(u?`${u}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)")};`,P?`${f}.rgba.rgb = ${P};`:null,_?`${f}.rgba.a = ${_};`:null,j?`${f}.center.x = ${j};`:null,eA?`${f}.center.y = ${eA};`:null,V?`${f}.center.z = ${V};`:null,sA?`${f}.rgba.r = ${sA};`:null,O?`${f}.rgba.g = ${O};`:null,N?`${f}.rgba.b = ${N};`:null].filter(Boolean)}})}dynoOut(){return new QA(this,"gsplat")}}lA(`
  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {
    float minScale = min(scales.x, min(scales.y, scales.z));
    vec3 normal;
    if (scales.z == minScale) {
      normal = vec3(0.0, 0.0, 1.0);
    } else if (scales.y == minScale) {
      normal = vec3(0.0, 1.0, 0.0);
    } else {
      normal = vec3(1.0, 0.0, 0.0);
    }
    return quatVec(quaternion, normal);
  }
`);class Yi extends tA{constructor({gsplat:A,scale:n,rotate:t,translate:e,recolor:i}){super({inTypes:{gsplat:W,scale:"float",rotate:"vec4",translate:"vec3",recolor:"vec4"},outTypes:{gsplat:W},inputs:{gsplat:A,scale:n,rotate:t,translate:e,recolor:i},globals:()=>[kA],statements:({inputs:a,outputs:r,compile:o})=>{const{gsplat:g}=r;if(!g||!a.gsplat)return[];const{scale:c,rotate:I,translate:B,recolor:Q}=a,l=o.indent;return[`${g} = ${a.gsplat};`,`if (isGsplatActive(${g}.flags)) {`,c?`${l}${g}.center *= ${c};`:null,I?`${l}${g}.center = quatVec(${I}, ${g}.center);`:null,B?`${l}${g}.center += ${B};`:null,c?`${l}${g}.scales *= ${c};`:null,I?`${l}${g}.quaternion = quatQuat(${I}, ${g}.quaternion);`:null,Q?`${l}${g}.rgba *= ${Q};`:null,"}"].filter(Boolean)}})}dynoOut(){return new QA(this,"gsplat")}}const Ji=s=>new Hi({gsplat:s});class Hi extends tA{constructor({gsplat:A}){super({inTypes:{gsplat:W},inputs:{gsplat:A},globals:()=>[kA],statements:({inputs:n,outputs:t})=>{const{output:e}=t;if(!e)return[];const{gsplat:i}=n;return i?bA(`
            if (isGsplatActive(${i}.flags)) {
              ${e} = packSplat(${i}.center, ${i}.scales, ${i}.quaternion, ${i}.rgba);
            } else {
              ${e} = uvec4(0u, 0u, 0u, 0u);
            }
          `):[`${e} = uvec4(0u, 0u, 0u, 0u);`]}})}dynoOut(){return new QA(this,"output")}}class qi extends tA{constructor({rgba8:A}){super({inTypes:{rgba8:"vec4"},inputs:{rgba8:A},statements:({inputs:n,outputs:t})=>[`target = ${n.rgba8??"vec4(0.0, 0.0, 0.0, 0.0)"};`]})}dynoOut(){return new QA(this,"rgba8")}}class xA extends tA{constructor({key:A,type:n,count:t,value:e,update:i,globals:a}){A=A??"value",super({outTypes:{[A]:n},update:()=>{if(i){const r=i(this.value);r!==void 0&&(this.value=r)}this.uniform.value=this.value},generate:({inputs:r,outputs:o})=>{const g=a?.({inputs:r,outputs:o})??[],c={},I=o[A];return I&&(g.push(`uniform ${Re(I,n,t)};`),c[I]=this.uniform),{globals:g,uniforms:c}}}),this.type=n,this.count=t,this.value=e,this.uniform={value:e},this.outKey=A}dynoOut(){return new QA(this,this.outKey)}}class Vt extends xA{constructor({key:A,value:n,update:t}){super({key:A,type:"bool",value:n,update:t})}}class dt extends xA{constructor({key:A,value:n,update:t}){super({key:A,type:"int",value:n,update:t})}}class bn extends xA{constructor({key:A,value:n,update:t}){super({key:A,type:"float",value:n,update:t})}}class jn extends xA{constructor({key:A,value:n,update:t}){super({key:A,type:"vec3",value:n,update:t})}}class Nt extends xA{constructor({key:A,value:n,update:t}){super({key:A,type:"vec4",value:n,update:t})}}class tt extends xA{constructor({key:A,value:n,update:t}){super({key:A,type:"usampler2DArray",value:n,update:t})}}var nA=Uint8Array,gn=Uint16Array,zi=Int32Array,Ge=new nA([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Le=new nA([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Ki=new nA([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Ue=function(s,A){for(var n=new gn(31),t=0;t<31;++t)n[t]=A+=1<<s[t-1];for(var e=new zi(n[30]),t=1;t<30;++t)for(var i=n[t];i<n[t+1];++i)e[i]=i-n[t]<<5|t;return{b:n,r:e}},_e=Ue(Ge,2),Te=_e.b,Pi=_e.r;Te[28]=258,Pi[258]=28;var Oi=Ue(Le,0),ji=Oi.b,pt=new gn(32768);for(var z=0;z<32768;++z){var TA=(z&43690)>>1|(z&21845)<<1;TA=(TA&52428)>>2|(TA&13107)<<2,TA=(TA&61680)>>4|(TA&3855)<<4,pt[z]=((TA&65280)>>8|(TA&255)<<8)>>1}var Dn=function(s,A,n){for(var t=s.length,e=0,i=new gn(A);e<t;++e)s[e]&&++i[s[e]-1];var a=new gn(A);for(e=1;e<A;++e)a[e]=a[e-1]+i[e-1]<<1;var r;if(n){r=new gn(1<<A);var o=15-A;for(e=0;e<t;++e)if(s[e])for(var g=e<<4|s[e],c=A-s[e],I=a[s[e]-1]++<<c,B=I|(1<<c)-1;I<=B;++I)r[pt[I]>>o]=g}else for(r=new gn(t),e=0;e<t;++e)s[e]&&(r[e]=pt[a[s[e]-1]++]>>15-s[e]);return r},Nn=new nA(288);for(var z=0;z<144;++z)Nn[z]=8;for(var z=144;z<256;++z)Nn[z]=9;for(var z=256;z<280;++z)Nn[z]=7;for(var z=280;z<288;++z)Nn[z]=8;var Ye=new nA(32);for(var z=0;z<32;++z)Ye[z]=5;var Vi=Dn(Nn,9,1),Xi=Dn(Ye,5,1),et=function(s){for(var A=s[0],n=1;n<s.length;++n)s[n]>A&&(A=s[n]);return A},mA=function(s,A,n){var t=A/8|0;return(s[t]|s[t+1]<<8)>>(A&7)&n},st=function(s,A){var n=A/8|0;return(s[n]|s[n+1]<<8|s[n+2]<<16)>>(A&7)},Je=function(s){return(s+7)/8|0},qn=function(s,A,n){return(A==null||A<0)&&(A=0),(n==null||n>s.length)&&(n=s.length),new nA(s.subarray(A,n))},Zi=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],dA=function(s,A,n){var t=new Error(A||Zi[s]);if(t.code=s,Error.captureStackTrace&&Error.captureStackTrace(t,dA),!n)throw t;return t},Wi=function(s,A,n,t){var e=s.length,i=0;if(!e||A.f&&!A.l)return n||new nA(0);var a=!n,r=a||A.i!=2,o=A.i;a&&(n=new nA(e*3));var g=function(x){var D=n.length;if(x>D){var b=new nA(Math.max(D*2,x));b.set(n),n=b}},c=A.f||0,I=A.p||0,B=A.b||0,Q=A.l,l=A.d,C=A.m,E=A.n,h=e*8;do{if(!Q){c=mA(s,I,1);var f=mA(s,I+1,3);if(I+=3,f)if(f==1)Q=Vi,l=Xi,C=9,E=5;else if(f==2){var S=mA(s,I,31)+257,M=mA(s,I+10,15)+4,K=S+mA(s,I+5,31)+1;I+=14;for(var L=new nA(K),P=new nA(19),_=0;_<M;++_)P[Ki[_]]=mA(s,I+_*3,7);I+=M*3;for(var j=et(P),eA=(1<<j)-1,V=Dn(P,j,1),_=0;_<K;){var sA=V[mA(s,I,eA)];I+=sA&15;var u=sA>>4;if(u<16)L[_++]=u;else{var O=0,N=0;for(u==16?(N=3+mA(s,I,3),I+=2,O=L[_-1]):u==17?(N=3+mA(s,I,7),I+=3):u==18&&(N=11+mA(s,I,127),I+=7);N--;)L[_++]=O}}var iA=L.subarray(0,S),Y=L.subarray(S);C=et(iA),E=et(Y),Q=Dn(iA,C,1),l=Dn(Y,E,1)}else dA(1);else{var u=Je(I)+4,y=s[u-4]|s[u-3]<<8,w=u+y;if(w>e){o&&dA(0);break}r&&g(B+y),n.set(s.subarray(u,w),B),A.b=B+=y,A.p=I=w*8,A.f=c;continue}if(I>h){o&&dA(0);break}}r&&g(B+131072);for(var wA=(1<<C)-1,CA=(1<<E)-1,cA=I;;cA=I){var O=Q[st(s,I)&wA],aA=O>>4;if(I+=O&15,I>h){o&&dA(0);break}if(O||dA(2),aA<256)n[B++]=aA;else if(aA==256){cA=I,Q=null;break}else{var yA=aA-254;if(aA>264){var _=aA-257,rA=Ge[_];yA=mA(s,I,(1<<rA)-1)+Te[_],I+=rA}var BA=l[st(s,I)&CA],v=BA>>4;BA||dA(3),I+=BA&15;var Y=ji[v];if(v>3){var rA=Le[v];Y+=st(s,I)&(1<<rA)-1,I+=rA}if(I>h){o&&dA(0);break}r&&g(B+131072);var hA=B+yA;if(B<Y){var d=i-Y,p=Math.min(Y,hA);for(d+B<0&&dA(3);B<p;++B)n[B]=t[d+B]}for(;B<hA;++B)n[B]=n[B-Y]}}A.l=Q,A.p=cA,A.b=B,A.f=c,Q&&(c=1,A.m=C,A.d=l,A.n=E)}while(!c);return B!=n.length&&a?qn(n,0,B):n.subarray(0,B)},$i=new nA(0),Aa=function(s){(s[0]!=31||s[1]!=139||s[2]!=8)&&dA(6,"invalid gzip data");var A=s[3],n=10;A&4&&(n+=(s[10]|s[11]<<8)+2);for(var t=(A>>3&1)+(A>>4&1);t>0;t-=!s[n++]);return n+(A&2)},it=function(){function s(A,n){typeof A=="function"&&(n=A,A={}),this.ondata=n;var t=A&&A.dictionary&&A.dictionary.subarray(-32768);this.s={i:0,b:t?t.length:0},this.o=new nA(32768),this.p=new nA(0),t&&this.o.set(t)}return s.prototype.e=function(A){if(this.ondata||dA(5),this.d&&dA(4),!this.p.length)this.p=A;else if(A.length){var n=new nA(this.p.length+A.length);n.set(this.p),n.set(A,this.p.length),this.p=n}},s.prototype.c=function(A){this.s.i=+(this.d=A||!1);var n=this.s.b,t=Wi(this.p,this.s,this.o);this.ondata(qn(t,n,this.s.b),this.d),this.o=qn(t,this.s.b-32768),this.s.b=this.o.length,this.p=qn(this.p,this.s.p/8|0),this.s.p&=7},s.prototype.push=function(A,n){this.e(A),this.c(n)},s}(),na=function(){function s(A,n){this.v=1,this.r=0,it.call(this,A,n)}return s.prototype.push=function(A,n){if(it.prototype.e.call(this,A),this.r+=A.length,this.v){var t=this.p.subarray(this.v-1),e=t.length>3?Aa(t):4;if(e>t.length){if(!n)return}else this.v>1&&this.onmember&&this.onmember(this.r-t.length);this.p=t.subarray(e),this.v=0}it.prototype.c.call(this,n),this.s.f&&!this.s.l&&!n&&(this.v=Je(this.s.p)+9,this.s={i:0},this.o=new nA(0),this.push(new nA(0),n))},s}(),ta=typeof TextDecoder<"u"&&new TextDecoder,ea=0;try{ta.decode($i,{stream:!0}),ea=1}catch{}const vt=new Float32Array(1),He=new Uint32Array(vt.buffer);function at(s){vt[0]=s;const A=He[0],n=A>>31&1,t=A>>23&255,e=A&8388607,i=n<<15;if(t===255)return e!==0?i|32767:i|31744;const a=t-127+15;if(a>=31)return i|31744;if(a<=0){if(a<-10)return i;const o=(e|8388608)>>1-a+13;return i|o}const r=e>>13;return i|a<<10|r}function rt(s){const A=s>>15&1,n=s>>10&31,t=s&1023;let e;if(n===0)if(t===0)e=A<<31;else{let i=t,a=-14;for(;!(i&1024);)i<<=1,a--;i&=1023;const r=a+127,o=i<<13;e=A<<31|r<<23|o}else if(n===31)t===0?e=A<<31|2139095040:e=A<<31|2143289344;else{const i=n-15+127,a=t<<13;e=A<<31|i<<23|a}return He[0]=e,vt[0]}function Gn(s){return Math.max(0,Math.min(255,Math.round(s*255)))}function sa(s){const A=[],n=new Set;function t(e){e&&typeof e=="object"&&!n.has(e)&&(n.add(e),e instanceof ArrayBuffer?A.push(e):ArrayBuffer.isView(e)?A.push(e.buffer):Array.isArray(e)?e.forEach(t):Object.values(e).forEach(t))}return t(s),A}class ia{constructor({allocate:A,dispose:n,valid:t}){this.items=[],this.allocate=A,this.dispose=n,this.valid=t}alloc(A){for(;;){const n=this.items.pop();if(!n)break;if(this.valid(n,A))return n;this.dispose&&this.dispose(n)}return this.allocate(A)}free(A){this.items.push(A)}disposeAll(){let A;for(A=this.items.pop();A;)this.dispose&&this.dispose(A),A=this.items.pop()}}function Xt(s,A,n,t,e,i,a,r,o,g,c,I,B,Q,l,C){const E=Gn(Q),h=Gn(l),f=Gn(C),u=Gn(B),y=Ca(new IA(o,g,c,I)),w=y&255,S=y>>>8&255,M=y>>>16&255,K=i===0?0:Math.min(255,Math.max(0,Math.round((Math.log(i)-WA)/Bn)+1)),L=a===0?0:Math.min(255,Math.max(0,Math.round((Math.log(a)-WA)/Bn)+1)),P=r===0?0:Math.min(255,Math.max(0,Math.round((Math.log(r)-WA)/Bn)+1)),_=at(n),j=at(t),eA=at(e),V=A*4;s[V]=E|h<<8|f<<16|u<<24,s[V+1]=_|j<<16,s[V+2]=eA|w<<16|S<<24,s[V+3]=K|L<<8|P<<16|M<<24}const aa=new m,ra=new m,oa=new IA,ga=new gA,Ia={center:aa,scales:ra,quaternion:oa,color:ga,opacity:0};function Zt(s,A){const n=Ia,t=A*4,e=s[t],i=s[t+1],a=s[t+2],r=s[t+3];n.color.set((e&255)/255,(e>>>8&255)/255,(e>>>16&255)/255),n.opacity=(e>>>24&255)/255,n.center.set(rt(i&65535),rt(i>>>16&65535),rt(a&65535));const o=r&255;n.scales.x=o===0?0:Math.exp(WA+(o-1)*Bn);const g=r>>>8&255;n.scales.y=g===0?0:Math.exp(WA+(g-1)*Bn);const c=r>>>16&255;n.scales.z=c===0?0:Math.exp(WA+(c-1)*Bn);const I=a>>>16&65535|r>>>8&16711680;return ha(I,n.quaternion),n}function pA(s){const A=T,n=Math.max(xi,Math.min(PA,Math.ceil(s/A))),t=Math.ceil(s/(A*n)),e=A*n*t;return{width:A,height:n,depth:t,maxSplats:e}}function ca(s){const A=new pe(s.autoStart);return A.startTime=s.startTime,A.oldTime=s.oldTime,A.elapsedTime=s.elapsedTime,A.running=s.running,A}const Ba=lA(`
  precision highp float;

  in vec3 position;

  void main() {
    gl_Position = vec4(position.xy, 0.0, 1.0);
  }
`);function Qa(s){const A=new m;for(const n of s)A.add(n);return A.divideScalar(s.length)}function la(s){if(s.length===0)return new IA;const A=s[0].clone();for(let n=1;n<s.length;n++)s[n].dot(s[0])<0?(A.x-=s[n].x,A.y-=s[n].y,A.z-=s[n].z,A.w-=s[n].w):(A.x+=s[n].x,A.y+=s[n].y,A.z+=s[n].z,A.w+=s[n].w);return A.normalize()}function Ea(s,A){const[n,t]=[new m,new IA],[e,i]=[new m,new IA];s.decompose(n,t,new m),A.decompose(e,i,new m);const a=n.distanceTo(e),r=Math.abs(t.dot(i));return{distance:a,coorient:r}}function ft({matrix1:s,matrix2:A,maxDistance:n,minCoorient:t}){const{distance:e,coorient:i}=Ea(s,A);return e<=n&&(t==null||i>=t)}function Ca(s){const A=s.clone().normalize();A.w<0&&A.set(-A.x,-A.y,-A.z,-A.w);const n=2*Math.acos(A.w),t=Math.sqrt(A.x*A.x+A.y*A.y+A.z*A.z),e=t<1e-6?new m(1,0,0):new m(A.x,A.y,A.z).divideScalar(t),i=Math.abs(e.x)+Math.abs(e.y)+Math.abs(e.z);let a=e.x/i,r=e.y/i;if(e.z<0){const Q=a;a=(1-Math.abs(r))*(a>=0?1:-1),r=(1-Math.abs(Q))*(r>=0?1:-1)}const o=a*.5+.5,g=r*.5+.5,c=Math.round(o*255),I=Math.round(g*255);return Math.round(n*(255/Math.PI))<<16|I<<8|c}function ha(s,A){const n=s&255,t=s>>>8&255,e=s>>>16&255,i=n/255,a=t/255;let r=(i-.5)*2,o=(a-.5)*2;const g=1-(Math.abs(r)+Math.abs(o)),c=Math.max(-g,0);r+=r>=0?-c:c,o+=o>=0?-c:c;const I=new m(r,o,g).normalize(),Q=e/255*Math.PI*.5,l=Math.sin(Q),C=Math.cos(Q);return A.set(I.x*l,I.y*l,I.z*l,C),A}function ua(s,A){const n=[];let t=0,e=null;const i=new na((o,g)=>{if(n.push(o),t+=o.length,g||t>=A){const c=new Uint8Array(t);let I=0;for(const B of n)c.set(B,I),I+=B.length;e=c.slice(0,A)}}),a=1024;let r=0;for(;e==null&&r<s.length;){const o=s.slice(r,r+a);i.push(o,!1),r+=a}if(e==null&&(i.push(new Uint8Array,!0),e==null))throw new Error("Failed to decompress partial gzip");return e}class qe{constructor({graph:A,inputs:n,outputs:t,template:e}){this.graph=A,this.template=e,this.inputs=n??{},this.outputs=t??{};const i=new Ni({indent:this.template.indent});for(const r in this.outputs)this.outputs[r]&&i.declares.add(this.outputs[r]);const a=A.compile({inputs:this.inputs,outputs:this.outputs,compile:i});this.shader=e.generate({globals:i.globals,statements:a}),this.uniforms=i.uniforms,this.updaters=i.updaters}prepareMaterial(){return da(this)}update(){for(const A of this.updaters)A()}}class ze{constructor(A){const n=A.match(/^([ \t]*)\{\{\s*GLOBALS\s*\}\}/m),t=A.match(/^([ \t]*)\{\{\s*STATEMENTS\s*\}\}/m);if(!n||!t)throw new Error("Template must contain {{ GLOBALS }} and {{ STATEMENTS }}");this.before=A.substring(0,n.index),this.between=A.substring(n.index+n[0].length,t.index),this.after=A.substring(t.index+t[0].length),this.indent=t[1]}generate({globals:A,statements:n}){return this.before+Array.from(A).join(`

`)+this.between+n.map(t=>this.indent+t).join(`
`)+this.after}}const Wt=new Map;function da(s){let A=Wt.get(s);return A||(A=new bt({glslVersion:ue,vertexShader:Ba,fragmentShader:s.shader,uniforms:s.uniforms}),Wt.set(s,A),A)}function Ke(s,A,n="add"){const t=()=>{throw new Error(`Invalid ${n} types: ${s}, ${A}`)};if(s===A)return s;if(s==="int"){if(OA(A))return A;t()}if(A==="int"){if(OA(s))return s;t()}if(s==="uint"){if(jA(A))return A;t()}if(A==="uint"){if(jA(s))return s;t()}if(s==="float"){if(Mn(A))return A;t()}if(A==="float"){if(Mn(s))return s;t()}throw new Error(`Invalid ${n} types: ${s}, ${A}`)}function pa(s,A){return Ke(s,A,"sub")}function fa(s,A){const n=()=>{throw new Error(`Invalid mul types: ${s}, ${A}`)},t=e=>e;if(s==="int"){if(OA(A))return t(A);n()}if(A==="int"){if(OA(s))return t(s);n()}if(s==="uint"){if(jA(A))return t(A);n()}if(A==="uint"){if(jA(s))return t(s);n()}if(s==="float"){if(Mn(A))return t(A);n()}if(A==="float"){if(Mn(s))return t(s);n()}if(OA(s)||jA(s)||OA(A)||jA(A)){if(s===A)return t(s);n()}if(s==="vec2"){if(A==="vec2"||nn(A))return t("vec2");if(A==="mat3x2")return t("vec3");if(A==="mat4x2")return t("vec4");n()}if(s==="vec3"){if(A==="mat2x3")return t("vec2");if(A==="vec3"||tn(A))return t("vec3");if(A==="mat4x3")return t("vec4");n()}if(s==="vec4"){if(A==="mat2x4")return t("vec2");if(A==="mat3x4")return t("vec3");if(A==="vec4"||en(A))return t("vec4");n()}if(A==="vec2"){if(nn(s))return t("vec2");if(s==="mat2x3")return t("vec3");if(s==="mat2x4")return t("vec4");n()}if(A==="vec3"){if(s==="mat3x2")return t("vec2");if(tn(s))return t("vec3");if(s==="mat3x4")return t("vec4");n()}if(A==="vec4"){if(s==="mat4x2")return t("vec2");if(s==="mat4x3")return t("vec3");if(en(s))return t("vec4");n()}if(nn(s)){if(nn(A))return t("mat2");if(A==="mat3x2")return t("mat3x2");if(A==="mat4x2")return t("mat4x2");n()}if(s==="mat2x3"){if(nn(A))return t("mat2x3");if(A==="mat3x2")return t("mat3");if(A==="mat4x2")return t("mat4x3");n()}if(s==="mat2x4"){if(nn(A))return t("mat2x4");if(A==="mat3x2")return t("mat3x4");if(A==="mat4x2")return t("mat4");n()}if(s==="mat3x2"){if(A==="mat2x3")return t("mat2");if(tn(A))return t("mat3x2");if(A==="mat4x3")return t("mat4x2");n()}if(tn(s)){if(A==="mat2x3")return t("mat2x3");if(tn(A))return t("mat3");if(A==="mat4x3")return t("mat4x3");n()}if(s==="mat3x4"){if(A==="mat2x3")return t("mat2x4");if(tn(A))return t("mat3x4");if(A==="mat4x3")return t("mat4");n()}if(s==="mat4x2"){if(A==="mat2x4")return t("mat2");if(A==="mat3x4")return t("mat3x2");if(en(A))return t("mat4x2");n()}if(s==="mat4x3"){if(A==="mat2x4")return t("mat2x3");if(A==="mat3x4")return t("mat3");if(en(A))return t("mat4x3");n()}if(en(s)){if(A==="mat2x4")return t("mat2x4");if(A==="mat3x4")return t("mat3x4");if(en(A))return t("mat4");n()}throw new Error(`Invalid mul types: ${s}, ${A}`)}const xn=(s,A)=>new ma({a:s,b:A}),ya=(s,A)=>new wa({a:s,b:A}),Pe=(s,A)=>new Da({a:s,b:A});class ma extends Zn{constructor({a:A,b:n}){super({a:A,b:n,outKey:"sum",outTypeFunc:Ke}),this.statements=({inputs:t,outputs:e})=>[`${e.sum} = ${t.a} + ${t.b};`]}}class wa extends Zn{constructor({a:A,b:n}){super({a:A,b:n,outKey:"difference",outTypeFunc:pa}),this.statements=({inputs:t,outputs:e})=>[`${e.difference} = ${t.a} - ${t.b};`]}}class Da extends Zn{constructor({a:A,b:n}){super({a:A,b:n,outKey:"product",outTypeFunc:fa}),this.statements=({inputs:t,outputs:e})=>[`${e.product} = ${t.a} * ${t.b};`]}}const xa=s=>new Ma({value:s}),Sa=s=>new ba({value:s});class Ma extends Ft{constructor({value:A}){super({a:A,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:n,outputs:t})=>[`${t.uint} = packHalf2x16(${n.a});`]}}class ba extends Ft{constructor({value:A}){super({a:A,outKey:"rgba8",outTypeFunc:()=>"vec4"}),this.statements=({inputs:n,outputs:t})=>[`uvec4 uRgba = uvec4(${n.a} & 0xffu, (${n.a} >> 8u) & 0xffu, (${n.a} >> 16u) & 0xffu, (${n.a} >> 24u) & 0xffu);`,`${t.rgba8} = vec4(uRgba) / 255.0;`]}}const ka=s=>new Na({a:s}),Fa=({vector:s,vectorType:A,x:n,y:t,z:e,w:i,r:a,g:r,b:o,a:g})=>new La({vector:s,vectorType:A,x:n,y:t,z:e,w:i,r:a,g:r,b:o,a:g}),Ra=(s,A)=>new Ga({a:s,b:A});class Na extends Ft{constructor({a:A}){super({a:A,outTypeFunc:n=>n,outKey:"normalize"}),this.statements=({inputs:n,outputs:t})=>[`${t.normalize} = normalize(${n.a});`]}}function va(s){if(s==="float")return"vec2";if(s==="vec2")return"vec3";if(s==="vec3")return"vec4";throw new Error("Invalid type")}class Ga extends Zn{constructor({a:A,b:n}){const t=JA(A),e=va(t);super({a:A,b:n,outKey:"extend",outTypeFunc:()=>e}),this.statements=({inputs:i,outputs:a})=>[`${a.extend} = ${e}(${i.a}, ${i.b});`]}}class La extends tA{constructor({vector:A,vectorType:n,x:t,y:e,z:i,w:a,r,g:o,b:g,a:c}){if(!A&&!n)throw new Error("Either vector or vectorType must be provided");const I=n??JA(A),B=ki(I),Q=Fi(I),l={vector:I,x:B,y:B,r:B,g:B},C={vector:A,x:t,y:e,r,g:o};Q>=3&&(Object.assign(l,{z:B,b:B}),Object.assign(C,{z:i,b:g})),Q>=4&&(Object.assign(l,{w:B,a:B}),Object.assign(C,{w:a,a:c})),super({inTypes:l,outTypes:{vector:I},inputs:C}),this.statements=({inputs:E,outputs:h})=>{const{vector:f}=h,{vector:u,x:y,y:w,z:S,w:M,r:K,g:L,b:P,a:_}=E,j=[`${f}.x = ${y??K??(u?`${u}.x`:vn(B))};`,`${f}.y = ${w??L??(u?`${u}.y`:vn(B))};`];return Q>=3&&j.push(`${f}.z = ${S??P??(u?`${u}.z`:vn(B))};`),Q>=4&&j.push(`${f}.w = ${M??_??(u?`${u}.w`:vn(B))};`),j}}dynoOut(){return new QA(this,"vector")}}const Ua=(s,{scale:A,scales:n,rotate:t,translate:e})=>new Ta({position:s,scale:A,scales:n,rotate:t,translate:e}).outputs.position,_a=(s,{scale:A,scales:n,rotate:t})=>new Ya({dir:s,scale:A,scales:n,rotate:t}).outputs.dir;class Ta extends tA{constructor({position:A,scale:n,scales:t,rotate:e,translate:i}){super({inTypes:{position:"vec3",scale:"float",scales:"vec3",rotate:"vec4",translate:"vec3"},outTypes:{position:"vec3"},inputs:{position:A,scale:n,scales:t,rotate:e,translate:i},statements:({inputs:a,outputs:r})=>{const{position:o}=r;if(!o)return[];const{scale:g,scales:c,rotate:I,translate:B}=a;return[`${o} = ${a.position??"vec3(0.0, 0.0, 0.0)"};`,g?`${o} *= ${g};`:null,c?`${o} *= ${c};`:null,I?`${o} = quatVec(${I}, ${o});`:null,B?`${o} += ${B};`:null].filter(Boolean)}})}}class Ya extends tA{constructor({dir:A,scale:n,scales:t,rotate:e}){super({inTypes:{dir:"vec3",scale:"float",scales:"vec3",rotate:"vec4"},outTypes:{dir:"vec3"},inputs:{dir:A,scale:n,scales:t,rotate:e},statements:({inputs:i,outputs:a})=>{const{dir:r}=a;if(!r)return[];const{scale:o,scales:g,rotate:c}=i;return[`${r} = ${i.dir??"vec3(0.0, 0.0, 0.0)"};`,o?`${r} *= ${o};`:null,g?`${r} *= ${g};`:null,c?`${r} = quatVec(${c}, ${r});`:null].filter(Boolean)}})}}var Ja=`precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out vec4 target;

{{ GLOBALS }}

void computeReadback(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        computeReadback(index);
    } else {
        target = vec4(0.0, 0.0, 0.0, 0.0);
    }
}`;const LA=class FA{constructor({renderer:A}={}){this.renderer=A,this.capacity=0,this.count=0}dispose(){this.target&&(this.target.dispose(),this.target=void 0)}ensureBuffer(A,n){const e=Math.ceil(Math.max(1,A)/T)*T*4;if(n.byteLength>=e)return n;const i=new ArrayBuffer(e);if(n instanceof ArrayBuffer)return i;const a=n.constructor;return new a(i)}ensureCapacity(A){const{width:n,height:t,depth:e,maxSplats:i}=pA(A);(!this.target||i>this.capacity)&&(this.dispose(),this.capacity=i,this.target=new Ee(n,t,e,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:ln,minFilter:ln}),this.target.texture.format=En,this.target.texture.type=Sn,this.target.texture.internalFormat="RGBA8")}prepareProgramMaterial(A){let n=FA.readbackProgram.get(A);if(!n){const e=zA({index:"int"},{rgba8:"vec4"},({index:i})=>(A.inputs.index=i,{rgba8:new qi({rgba8:A.outputs.rgba8})}));FA.programTemplate||(FA.programTemplate=new ze(Ja)),n=new qe({graph:e,inputs:{index:"index"},outputs:{rgba8:"target"},template:FA.programTemplate}),Object.assign(n.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),FA.readbackProgram.set(A,n)}const t=n.prepareMaterial();return FA.mesh.material=t,{program:n,material:t}}saveRenderState(A){return{xrPresenting:A.xr.isPresenting,autoClear:A.autoClear,scissorTest:A.getScissorTest(),pixelRatio:A.getPixelRatio()}}resetRenderState(A,n){A.setRenderTarget(null),A.setPixelRatio(n.pixelRatio),A.xr.isPresenting=n.xrPresenting,A.autoClear=n.autoClear,A.setScissorTest(n.scissorTest)}process({count:A,material:n}){const t=this.renderer;if(!t)throw new Error("No renderer");if(!this.target)throw new Error("No target");const e=T*PA;n.uniforms.targetBase.value=0,n.uniforms.targetCount.value=A;let i=0;for(;i<A;){const a=Math.floor(i/e),r=a*e,o=Math.min(PA,Math.ceil((A-r)/T));n.uniforms.targetLayer.value=a,t.setPixelRatio(1),t.setRenderTarget(this.target,a),t.xr.isPresenting=!1,t.autoClear=!1,t.setScissorTest(!0),t.setScissor(0,0,T,o),t.render(FA.scene,FA.camera),i+=T*o}this.count=A}async read({readback:A}){const n=this.renderer;if(!n)throw new Error("No renderer");if(!this.target)throw new Error("No target");const t=Math.ceil(this.count/T)*T;if(A.byteLength<t*4)throw new Error(`Readback buffer too small: ${A.byteLength} < ${t*4}`);const e=new Uint8Array(A instanceof ArrayBuffer?A:A.buffer),i=T*PA;let a=0;const r=[];for(;a<this.count;){const o=Math.floor(a/i),g=o*i,c=Math.min(PA,Math.ceil((this.count-g)/T));n.setPixelRatio(1),n.setRenderTarget(this.target,o);const I=T*c*4,B=e.subarray(g*4,g*4+I),Q=n?.readRenderTargetPixelsAsync(this.target,0,0,T,c,B);r.push(Q),a+=T*c}return Promise.all(r).then(()=>A)}render({reader:A,count:n,renderer:t}){if(this.renderer=t||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(n);const{program:e,material:i}=this.prepareProgramMaterial(A);e.update();const a=this.saveRenderState(this.renderer);this.process({count:n,material:i}),this.resetRenderState(this.renderer,a)}async readback({readback:A}){if(!this.renderer)throw new Error("No renderer");const n=this.saveRenderState(this.renderer),t=this.read({readback:A});return this.resetRenderState(this.renderer,n),t}async renderReadback({reader:A,count:n,renderer:t,readback:e}){if(this.renderer=t||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(n);const{program:i,material:a}=this.prepareProgramMaterial(A);i.update();const r=this.saveRenderState(this.renderer);this.process({count:n,material:a});const o=this.read({readback:e});return this.resetRenderState(this.renderer,r),o}getTexture(){var A;return(A=this.target)==null?void 0:A.texture}};LA.programTemplate=null;LA.readbackProgram=new Map;LA.geometry=new Kn(2,2);LA.mesh=new $A(LA.geometry,new bt({visible:!1}));LA.scene=new NA().add(LA.mesh);LA.camera=new le;let Oe=LA;const Gt=class oA{constructor(A={}){this.capacity=0,this.count=0,this.array=null,this.readback=null,this.source=null,this.needsUpdate=!0,this.dyno=new xA({key:"rgbaArray",type:je,globals:()=>[Ve],value:{texture:oA.getEmpty(),count:0},update:n=>{var t;return n.texture=((t=this.readback)==null?void 0:t.getTexture())??this.source??oA.getEmpty(),n.count=this.count,n}}),A.array?(this.array=A.array,this.capacity=Math.floor(this.array.length/4),this.capacity=Math.floor(this.capacity/T)*T,this.count=Math.min(this.capacity,A.count??Number.POSITIVE_INFINITY)):(this.capacity=A.capacity??0,this.count=0)}dispose(){this.readback&&(this.readback.dispose(),this.readback=null),this.source&&(this.source.dispose(),this.source=null)}ensureCapacity(A){var n;if(!this.array||A>(((n=this.array)==null?void 0:n.length)??0)/4){this.capacity=pA(A).maxSplats;const t=new Uint8Array(this.capacity*4);this.array&&t.set(this.array),this.array=t}return this.array}getTexture(){var A;let n=(A=this.readback)==null?void 0:A.getTexture();return(this.source||this.array)&&(n=this.maybeUpdateSource()),n??oA.getEmpty()}maybeUpdateSource(){if(!this.array)throw new Error("No array");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:A,height:n,depth:t}=this.source.image;this.capacity!==A*n*t&&(this.source.dispose(),this.source=null)}if(this.source)this.array.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.array.buffer));else{const{width:A,height:n,depth:t}=pA(this.capacity);this.source=new XA(this.array,A,n,t),this.source.format=En,this.source.type=Sn,this.source.internalFormat="RGBA8",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}render({reader:A,count:n,renderer:t}){this.readback||(this.readback=new Oe({renderer:t})),this.readback.render({reader:A,count:n,renderer:t}),this.capacity=this.readback.capacity,this.count=this.readback.count}fromPackedSplats({packedSplats:A,base:n,count:t,renderer:e}){const{dynoSplats:i,dynoBase:a,dynoCount:r,reader:o}=oA.makeDynos();return i.packedSplats=A,a.value=n,r.value=t,this.render({reader:o,count:t,renderer:e}),this}async read(){if(!this.readback)throw new Error("No readback");return(!this.array||this.array.length<this.count*4)&&(this.array=new Uint8Array(this.capacity*4)),(await this.readback.readback({readback:this.array})).subarray(0,this.count*4)}static getEmpty(){if(!oA.emptySource){const A=new Uint8Array(4);oA.emptySource=new XA(A,1,1,1),oA.emptySource.format=En,oA.emptySource.type=Sn,oA.emptySource.internalFormat="RGBA8",oA.emptySource.needsUpdate=!0}return oA.emptySource}static makeDynos(){if(!oA.dynos){const A=new Lt,n=new dt({value:0}),t=new dt({value:0}),e=zA({index:"int"},{rgba8:"vec4"},({index:i})=>{if(!i)throw new Error("index is undefined");i=xn(i,n);const a=Gi(A,i,n,t);return{rgba8:Hn(a).outputs.rgba}});oA.dynos={dynoSplats:A,dynoBase:n,dynoCount:t,reader:e}}return oA.dynos}};Gt.emptySource=null;Gt.dynos=null;let Ha=Gt;const je={type:"RgbaArray"},Ve=lA(`
  struct RgbaArray {
    sampler2DArray texture;
    int count;
  };
`);function qa(s,A){return new tA({inTypes:{rgba:je,index:"int"},outTypes:{rgba:"vec4"},inputs:{rgba:s,index:A},globals:()=>[Ve],statements:({inputs:t,outputs:e})=>bA(`
        if ((index >= 0) && (index < ${t.rgba}.count)) {
          ${e.rgba} = texelFetch(${t.rgba}.texture, splatTexCoord(index), 0);
        } else {
          ${e.rgba} = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `)}).outputs.rgba}function za(s){switch(s){case"all":return 0;case"plane":return 1;case"sphere":return 2;case"box":return 3;case"ellipsoid":return 4;case"cylinder":return 5;case"capsule":return 6;case"infinite_cone":return 7;default:throw new Error(`Unknown SDF type: ${s}`)}}function Ka(s){switch(s){case"multiply":return 0;case"set_rgb":return 1;case"add_rgba":return 2;default:throw new Error(`Unknown blend mode: ${s}`)}}class Pa extends Rn{constructor(A={}){super();const{type:n,invert:t,opacity:e,color:i,displace:a,radius:r}=A;this.type=n??"sphere",this.invert=t??!1,this.opacity=e??1,this.color=i??new gA(1,1,1),this.displace=a??new m(0,0,0),this.radius=r??0}}const Xe=class Ze extends Rn{constructor(A={}){const{name:n,rgbaBlendMode:t="multiply",sdfSmooth:e=0,softEdge:i=0,invert:a=!1,sdfs:r=null}=A;super(),this.rgbaBlendMode=t,this.sdfSmooth=e,this.softEdge=i,this.invert=a,this.sdfs=r,this.ordering=Ze.nextOrdering++,this.name=n??`Edit ${this.ordering}`}addSdf(A){this.sdfs==null&&(this.sdfs=[]),this.sdfs.push(A)}removeSdf(A){this.sdfs!=null&&(this.sdfs=this.sdfs.filter(n=>n!==A))}};Xe.nextOrdering=1;let We=Xe;class Oa{constructor({maxSdfs:A,maxEdits:n}){this.maxSdfs=Math.max(16,A??0),this.numSdfs=0,this.sdfData=new Uint32Array(this.maxSdfs*8*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs),this.dynoSdfArray=new xA({key:"sdfArray",type:$e,globals:()=>[As],value:{numSdfs:0,sdfTexture:this.sdfTexture},update:t=>(t.numSdfs=this.numSdfs,t.sdfTexture=this.sdfTexture,t)}),this.maxEdits=Math.max(16,n??0),this.numEdits=0,this.editData=new Uint32Array(this.maxEdits*4),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoNumEdits=new dt({value:0}),this.dynoEdits=this.newEdits(this.editData,this.maxEdits)}newSdfTexture(A,n){const t=new Rs(A,8,n,In,ZA);return t.internalFormat="RGBA32UI",t.needsUpdate=!0,t}newEdits(A,n){return new xA({key:"edits",type:"uvec4",count:n,globals:()=>[ns],value:A})}ensureCapacity({maxSdfs:A,maxEdits:n}){let t=!1;return A>this.sdfTexture.image.height&&(this.sdfTexture.dispose(),this.maxSdfs=Math.max(this.maxSdfs*2,A),this.sdfData=new Uint32Array(this.maxSdfs*8*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs)),n>(this.dynoEdits.count??0)&&(this.maxEdits=Math.max(this.maxEdits*2,n),this.editData=new Uint32Array(this.maxEdits*4),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoEdits=this.newEdits(this.editData,this.maxEdits),t=!0),t}updateEditData(A,n){const t=this.editData[A]!==n;return this.editData[A]=n,t}updateEditFloatData(A,n){sn[0]=n;const t=this.editFloatData[A]!==sn[0];return t&&(this.editFloatData[A]=sn[0]),t}encodeEdit(A,{sdfFirst:n,sdfCount:t,invert:e,rgbaBlendMode:i,softEdge:a,sdfSmooth:r}){const o=A*4;let g=!1;return g=this.updateEditData(o+0,i|(e?256:0))||g,g=this.updateEditData(o+1,n|t<<16)||g,g=this.updateEditFloatData(o+2,a)||g,g=this.updateEditFloatData(o+3,r)||g,g}updateSdfData(A,n){const t=this.sdfData[A]!==n;return this.sdfData[A]=n,t}updateSdfFloatData(A,n){sn[0]=n;const t=this.sdfFloatData[A]!==sn[0];return t&&(this.sdfFloatData[A]=sn[0]),t}encodeSdf(A,{sdfType:n,invert:t,center:e,quaternion:i,scale:a,sizes:r},o){const g=A*32,c=n|(t?256:0);let I=!1;I=this.updateSdfFloatData(g+0,e?.x??0)||I,I=this.updateSdfFloatData(g+1,e?.y??0)||I,I=this.updateSdfFloatData(g+2,e?.z??0)||I,I=this.updateSdfData(g+3,c)||I,I=this.updateSdfFloatData(g+4,i?.x??0)||I,I=this.updateSdfFloatData(g+5,i?.y??0)||I,I=this.updateSdfFloatData(g+6,i?.z??0)||I,I=this.updateSdfFloatData(g+7,i?.w??0)||I,I=this.updateSdfFloatData(g+8,a?.x??0)||I,I=this.updateSdfFloatData(g+9,a?.y??0)||I,I=this.updateSdfFloatData(g+10,a?.z??0)||I,I=this.updateSdfData(g+11,0)||I,I=this.updateSdfFloatData(g+12,r?.x??0)||I,I=this.updateSdfFloatData(g+13,r?.y??0)||I,I=this.updateSdfFloatData(g+14,r?.z??0)||I,I=this.updateSdfFloatData(g+15,r?.w??0)||I;const B=Math.min(4,o.length);for(let Q=0;Q<B;++Q){const l=g+16+Q*4;I=this.updateSdfFloatData(l+0,o[Q].x)||I,I=this.updateSdfFloatData(l+1,o[Q].y)||I,I=this.updateSdfFloatData(l+2,o[Q].z)||I,I=this.updateSdfFloatData(l+3,o[Q].w)||I}return I}update(A){const n=A.reduce((I,{sdfs:B})=>I+B.length,0),t=this.ensureCapacity({maxEdits:A.length,maxSdfs:n}),e=[new HA,new HA],i=new m,a=new IA,r=new m,o=new HA;let g=0,c=t;A.length!==this.dynoNumEdits.value&&(this.dynoNumEdits.value=A.length,this.numEdits=A.length,c=!0);for(const[I,{edit:B,sdfs:Q}]of A.entries()){c=this.encodeEdit(I,{sdfFirst:g,sdfCount:Q.length,invert:B.invert,rgbaBlendMode:Ka(B.rgbaBlendMode),softEdge:B.softEdge,sdfSmooth:B.sdfSmooth})||c;let l=!1;for(const C of Q)o.set(C.scale.x,C.scale.y,C.scale.z,C.radius),C.scale.setScalar(1),C.updateMatrixWorld(),C.matrixWorld.clone().invert().decompose(i,a,r),C.scale.set(o.x,o.y,o.z),C.updateMatrixWorld(),e[0].set(C.color.r,C.color.g,C.color.b,C.opacity),e[1].set(C.displace.x,C.displace.y,C.displace.z,1),l=this.encodeSdf(g,{sdfType:za(C.type),invert:C.invert,center:i,quaternion:a,scale:r,sizes:o},e)||l,g+=1;this.numSdfs=g,l&&(this.sdfTexture.needsUpdate=!0),c||(c=l)}return{updated:c,dynoUpdated:t}}modify(A){return ja(A,this.dynoSdfArray,this.dynoNumEdits,this.dynoEdits)}}const $e={type:"SdfArray"},As=lA(`
  struct SdfArray {
    int numSdfs;
    usampler2D sdfTexture;
  };

  void unpackSdfArray(
    usampler2D sdfTexture, int sdfIndex, out uint flags,
    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,
    int numValues, out vec4 values[4]
  ) {
    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);
    flags = temp.w;
    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);
    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);
    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);
    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    for (int i = 0; i < numValues; ++i) {
      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);
      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));
    }
  }

  const uint SDF_FLAG_TYPE = 0xFFu;
  const uint SDF_FLAG_INVERT = 1u << 8u;

  const uint SDF_TYPE_ALL = 0u;
  const uint SDF_TYPE_PLANE = 1u;
  const uint SDF_TYPE_SPHERE = 2u;
  const uint SDF_TYPE_BOX = 3u;
  const uint SDF_TYPE_ELLIPSOID = 4u;
  const uint SDF_TYPE_CYLINDER = 5u;
  const uint SDF_TYPE_CAPSULE = 6u;
  const uint SDF_TYPE_INFINITE_CONE = 7u;

  float evaluateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 outValues[4]
  ) {
    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;
    float maxExp = -1.0 / 0.0;
    for (int i = 0; i < numValues; ++i) {
        outValues[i] = vec4(0.0);
    }

    uint flags;
    vec3 center, scale;
    vec4 quaternion, sizes;
    vec4 values[4];

    int sdfLast = min(sdfFirst + sdfCount, numSdfs);
    for (int index = sdfFirst; index < sdfLast; ++index) {
      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);
      uint sdfType = flags & SDF_FLAG_TYPE;
      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;

      float distance;
      switch (sdfType) {
        case SDF_TYPE_ALL:
          distance = -1.0 / 0.0;
          break;
        case SDF_TYPE_PLANE: {
          distance = sdfPos.z;
          break;
        }
        case SDF_TYPE_SPHERE: {
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_BOX: {
          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;
          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;
          break;
        }
        case SDF_TYPE_ELLIPSOID: {
          vec3 sizes = sizes.xyz;
          float k0 = length(sdfPos / sizes);
          float k1 = length(sdfPos / dot(sizes, sizes));
          distance = k0 * (k0 - 1.0) / k1;
          break;
        }
        case SDF_TYPE_CYLINDER: {
          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;
          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
          break;
        }
        case SDF_TYPE_CAPSULE: {
          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_INFINITE_CONE: {
          float angle = 0.25 * PI * sizes.w;
          vec2 c = vec2(sin(angle), cos(angle));
          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);
          float d = length(q - c * max(dot(q, c), 0.0));
          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);
          break;
        }
      }

      if ((flags & SDF_FLAG_INVERT) != 0u) {
        distance = -distance;
      }

      if (smoothK == 0.0) {
        if (distance < distanceAccum) {
          distanceAccum = distance;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] = values[i];
          }
        }
      } else {
        float scaledDistance = -distance / smoothK;
        if (scaledDistance > maxExp) {
          float scale = exp(maxExp - scaledDistance);
          distanceAccum *= scale;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] *= scale;
          }
          maxExp = scaledDistance;
        }

        float weight = exp(scaledDistance - maxExp);
        distanceAccum += weight;
        for (int i = 0; i < numValues; ++i) {
          outValues[i] += weight * values[i];
        }
      }
    }

    if (smoothK == 0.0) {
      return distanceAccum;
    } else {
      // Very distant SDFs may result in 0 accumulation
      if (distanceAccum == 0.0) {
        return 1.0 / 0.0;
      }
      for (int i = 0; i < numValues; ++i) {
        outValues[i] /= distanceAccum;
      }
      return (-log(distanceAccum) - maxExp) * smoothK;
    }
  }

  float modulateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 values[4],
    float softEdge, bool invert
  ) {
    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);
    if (invert) {
      distance = -distance;
    }

    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)
      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);
  }
`),ns=lA(`
  const uint EDIT_FLAG_BLEND = 0xFFu;
  const uint EDIT_BLEND_MULTIPLY = 0u;
  const uint EDIT_BLEND_SET_RGB = 1u;
  const uint EDIT_BLEND_ADD_RGBA = 2u;
  const uint EDIT_FLAG_INVERT = 0x100u;

  void decodeEdit(
    uvec4 packedEdit, out int sdfFirst, out int sdfCount,
    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth
  ) {
    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;
    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;

    sdfFirst = int(packedEdit.y & 0xFFFFu);
    sdfCount = int(packedEdit.y >> 16u);

    softEdge = uintBitsToFloat(packedEdit.z);
    sdfSmooth = uintBitsToFloat(packedEdit.w);
  }

  void applyRgbaDisplaceEdit(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,
    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba
  ) {
    vec4 values[4];
    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);
    // On Android, moving values[0] is necessary to work around a compiler bug.
    vec4 sdfRgba = values[0];
    vec4 sdfDisplaceScale = values[1];

    vec4 target;
    switch (rgbaBlendMode) {
      case EDIT_BLEND_MULTIPLY:
        target = rgba * sdfRgba;
        break;
      case EDIT_BLEND_SET_RGB:
        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);
        break;
      case EDIT_BLEND_ADD_RGBA:
        target = rgba + sdfRgba;
        break;
      default:
        // Debug output if blend mode not set
        target = vec4(fract(pos), 1.0);
    }
    rgba = mix(rgba, target, modulate);
    pos += sdfDisplaceScale.xyz * modulate;
  }

  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {
    int sdfFirst, sdfCount;
    bool invert;
    uint rgbaBlendMode;
    float softEdge, sdfSmooth;
    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);
    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);
  }
`);function ja(s,A,n,t){return new tA({inTypes:{gsplat:W,sdfArray:$e,numEdits:"int",rgbaDisplaceEdits:"uvec4"},outTypes:{gsplat:W},globals:()=>[As,ns],inputs:{gsplat:s,sdfArray:A,numEdits:n,rgbaDisplaceEdits:t},statements:({inputs:i,outputs:a})=>{const{sdfArray:r,numEdits:o,rgbaDisplaceEdits:g}=i,{gsplat:c}=a;return bA(`
        ${c} = ${i.gsplat};
        if (isGsplatActive(${c}.flags)) {
          for (int editIndex = 0; editIndex < ${o}; ++editIndex) {
            applyPackedRgbaDisplaceEdit(
              ${g}[editIndex], ${r}.sdfTexture, ${r}.numSdfs,
              ${c}.center, ${c}.rgba
            );
          }
        }
      `)}}).outputs.gsplat}const sn=new Float32Array(1);class Va{constructor(A){this.modifier=A,this.cache=new Map}apply(A){let n=this.cache.get(A);return n||(n=zA({index:"int"},{gsplat:W},({index:t})=>{const{gsplat:e}=A.apply({index:t});return this.modifier.apply({gsplat:e})}),this.cache.set(A,n)),n}}class Ln{constructor(){this.scale=new bn({value:Number.NEGATIVE_INFINITY}),this.rotate=new Nt({value:new IA(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}),this.translate=new jn({value:new m(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)})}apply(A){return Ua(A,{scale:this.scale,rotate:this.rotate,translate:this.translate})}applyDir(A){return _a(A,{rotate:this.rotate})}applyGsplat(A){return Ne(A,{scale:this.scale,rotate:this.rotate,translate:this.translate})}updateFromMatrix(A){const n=new m,t=new IA,e=new m;A.decompose(e,t,n);const i=(n.x+n.y+n.z)/3;let a=!1;return i!==this.scale.value&&(this.scale.value=i,a=!0),e.equals(this.translate.value)||(this.translate.value.copy(e),a=!0),t.equals(this.rotate.value)||(this.rotate.value.copy(t),a=!0),a}update(A){return A.updateMatrixWorld(),this.updateFromMatrix(A.matrixWorld)}}class ts extends Rn{constructor({numSplats:A,generator:n,construct:t,update:e}){if(super(),this.numSplats=A??0,this.generator=n,this.frameUpdate=e,this.version=0,t){const i=t(this);Object.assign(this,i)}}updateVersion(){this.version+=1}set needsUpdate(A){A&&this.updateVersion()}}const kn=class yt extends ts{constructor(A={}){const n=new Ln,t=new Ln,e=new Ln,i=new Ln,a=new Nt({value:new HA(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY)}),r=new bn({value:0}),o=new bn({value:0}),g={transform:n,viewToWorld:t,worldToView:e,viewToObject:i,recolor:a,time:r,deltaTime:o};if(super({update:({time:c,deltaTime:I,viewToWorld:B,globalEdits:Q})=>this.update({time:c,deltaTime:I,viewToWorld:B,globalEdits:Q})}),this.isInitialized=!1,this.recolor=new gA(1,1,1),this.opacity=1,this.enableViewToObject=!1,this.enableViewToWorld=!1,this.enableWorldToView=!1,this.skinning=null,this.edits=null,this.rgbaDisplaceEdits=null,this.splatRgba=null,this.maxSh=3,this.packedSplats=A.packedSplats??new hn,this.numSplats=this.packedSplats.numSplats,this.editable=A.editable??!0,this.onFrame=A.onFrame,this.context=g,this.objectModifier=A.objectModifier,this.worldModifier=A.worldModifier,this.updateGenerator(),A.url||A.fileBytes||A.constructSplats||A.packedSplats&&!A.packedSplats.isInitialized)this.initialized=this.asyncInitialize(A).then(async()=>{if(this.updateGenerator(),this.isInitialized=!0,A.onLoad){const c=A.onLoad(this);c instanceof Promise&&await c}return this});else if(this.isInitialized=!0,this.initialized=Promise.resolve(this),A.onLoad){const c=A.onLoad(this);c instanceof Promise&&(this.initialized=c.then(()=>this))}}async asyncInitialize(A){const{url:n,fileBytes:t,fileType:e,fileName:i,maxSplats:a,constructSplats:r}=A;if(n||t||r){const o={url:n,fileBytes:t,fileType:e,fileName:i,maxSplats:a,construct:r};this.packedSplats.reinitialize(o)}this.packedSplats&&(await this.packedSplats.initialized,this.numSplats=this.packedSplats.numSplats,this.updateGenerator())}static async staticInitialize(){await Fe(),yt.isStaticInitialized=!0}pushSplat(A,n,t,e,i){this.packedSplats.pushSplat(A,n,t,e,i)}forEachSplat(A){this.packedSplats.forEachSplat(A)}dispose(){this.packedSplats.dispose()}constructGenerator(A){const{transform:n,viewToObject:t,recolor:e}=A,i=zA({index:"int"},{gsplat:W},({index:a})=>{if(!a)throw new Error("index is undefined");let r=On(this.packedSplats.dyno,a);if(this.maxSh>=1){const{sh1Texture:g,sh2Texture:c,sh3Texture:I}=this.ensureShTextures();if(g){const B=t.translate,{center:Q}=Hn(r).outputs,l=ka(ya(Q,B));let C=$a(r,g,l);this.maxSh>=2&&c&&(C=xn(C,Ar(r,c,l))),this.maxSh>=3&&I&&(C=xn(C,nr(r,I,l)));let{rgba:E}=Hn(r).outputs;E=xn(E,Ra(C,ut("float",0))),r=nt({gsplat:r,rgba:E})}}if(this.splatRgba){const g=qa(this.splatRgba.dyno,a);r=nt({gsplat:r,rgba:g})}this.skinning&&(r=this.skinning.modify(r)),this.objectModifier&&(r=this.objectModifier.apply({gsplat:r}).gsplat),r=n.applyGsplat(r);const o=Pe(e,Hn(r).outputs.rgba);return r=nt({gsplat:r,rgba:o}),this.rgbaDisplaceEdits&&(r=this.rgbaDisplaceEdits.modify(r)),this.worldModifier&&(r=this.worldModifier.apply({gsplat:r}).gsplat),{gsplat:r}});this.generator=i}updateGenerator(){this.constructGenerator(this.context)}update({time:A,viewToWorld:n,deltaTime:t,globalEdits:e}){var i;this.numSplats=this.packedSplats.numSplats,this.context.time.value=A,this.context.deltaTime.value=t,yt.dynoTime.value=A;const{transform:a,viewToObject:r,recolor:o}=this.context;let g=a.update(this);this.context.viewToWorld.updateFromMatrix(n)&&this.enableViewToWorld&&(g=!0);const c=n.clone().invert();this.context.worldToView.updateFromMatrix(c)&&this.enableWorldToView&&(g=!0);const Q=new fA().compose(a.translate.value,a.rotate.value,new m().setScalar(a.scale.value)).invert().multiply(n);r.updateFromMatrix(Q)&&(this.enableViewToObject||this.packedSplats.extra.sh1)&&(g=!0);const l=new HA(this.recolor.r,this.recolor.g,this.recolor.b,this.opacity);l.equals(o.value)||(o.value.copy(l),g=!0);const C=this.editable?(this.edits??[]).concat(e):[];this.editable&&!this.edits&&this.traverseVisible(h=>{h instanceof We&&C.push(h)}),C.sort((h,f)=>h.ordering-f.ordering);const E=C.map(h=>{if(h.sdfs!=null)return{edit:h,sdfs:h.sdfs};const f=[];return h.traverseVisible(u=>{u instanceof Pa&&f.push(u)}),{edit:h,sdfs:f}});if(E.length>0&&!this.rgbaDisplaceEdits){const h=E.length,f=E.reduce((u,y)=>u+y.sdfs.length,0);this.rgbaDisplaceEdits=new Oa({maxEdits:h,maxSdfs:f}),this.updateGenerator()}if(this.rgbaDisplaceEdits){const h=this.rgbaDisplaceEdits.update(E);g||(g=h.updated),h.dynoUpdated&&this.updateGenerator()}g&&this.updateVersion(),(i=this.onFrame)==null||i.call(this,{mesh:this,time:A,deltaTime:t})}raycast(A,n){if(!this.packedSplats.packedArray||!this.packedSplats.numSplats)return;const{near:t,far:e,ray:i}=A,a=this.matrixWorld.clone().invert(),r=new Ce().setFromMatrix4(a),o=i.origin.clone().applyMatrix4(a),g=i.direction.clone().applyMatrix3(r),c=new m;a.decompose(new m,new IA,c),(c.x*c.y*c.z)**(1/3);const I=!0,B=di(o.x,o.y,o.z,g.x,g.y,g.z,t,e,this.packedSplats.numSplats,this.packedSplats.packedArray,I);for(const Q of B){const l=i.direction.clone().multiplyScalar(Q).add(i.origin);n.push({distance:Q,point:l,object:this})}}ensureShTextures(){if(!this.packedSplats.extra.sh1)return{};let A=this.packedSplats.extra.sh1Texture;if(!A){let e=this.packedSplats.extra.sh1;const{width:i,height:a,depth:r,maxSplats:o}=pA(e.length/2);if(e.length<o*2){const c=new Uint32Array(o*2);c.set(e),this.packedSplats.extra.sh1=c,e=c}const g=new XA(e,i,a,r);g.format=ms,g.type=ZA,g.internalFormat="RG32UI",g.needsUpdate=!0,A=new tt({value:g,key:"sh1"}),this.packedSplats.extra.sh1Texture=A}if(!this.packedSplats.extra.sh2)return{sh1Texture:A};let n=this.packedSplats.extra.sh2Texture;if(!n){let e=this.packedSplats.extra.sh2;const{width:i,height:a,depth:r,maxSplats:o}=pA(e.length/4);if(e.length<o*4){const c=new Uint32Array(o*4);c.set(e),this.packedSplats.extra.sh2=c,e=c}const g=new XA(e,i,a,r);g.format=In,g.type=ZA,g.internalFormat="RGBA32UI",g.needsUpdate=!0,n=new tt({value:g,key:"sh2"}),this.packedSplats.extra.sh2Texture=n}if(!this.packedSplats.extra.sh3)return{sh1Texture:A,sh2Texture:n};let t=this.packedSplats.extra.sh3Texture;if(!t){let e=this.packedSplats.extra.sh3;const{width:i,height:a,depth:r,maxSplats:o}=pA(e.length/4);if(e.length<o*4){const c=new Uint32Array(o*4);c.set(e),this.packedSplats.extra.sh3=c,e=c}const g=new XA(e,i,a,r);g.format=In,g.type=ZA,g.internalFormat="RGBA32UI",g.needsUpdate=!0,t=new tt({value:g,key:"sh3"}),this.packedSplats.extra.sh3Texture=t}return{sh1Texture:A,sh2Texture:n,sh3Texture:t}}};kn.staticInitialized=kn.staticInitialize();kn.isStaticInitialized=!1;kn.dynoTime=new bn({value:0});let Fn=kn;const Xa=lA(`
  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {
    // Extract sint7 values packed into 2 x uint32
    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;
    vec3 sh1_0 = vec3(ivec3(
      int(packed.x << 25u) >> 25,
      int(packed.x << 18u) >> 25,
      int(packed.x << 11u) >> 25
    )) / 63.0;
    vec3 sh1_1 = vec3(ivec3(
      int(packed.x << 4u) >> 25,
      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,
      int(packed.y << 22u) >> 25
    )) / 63.0;
    vec3 sh1_2 = vec3(ivec3(
      int(packed.y << 15u) >> 25,
      int(packed.y << 8u) >> 25,
      int(packed.y << 1u) >> 25
    )) / 63.0;

    return sh1_0 * (-0.4886025 * viewDir.y)
      + sh1_1 * (0.4886025 * viewDir.z)
      + sh1_2 * (-0.4886025 * viewDir.x);
  }
`),Za=lA(`
  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {
    // Extract sint8 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);
    vec3 sh2_0 = vec3(ivec3(
      int(packed.x << 24u) >> 24,
      int(packed.x << 16u) >> 24,
      int(packed.x << 8u) >> 24
    )) / 127.0;
    vec3 sh2_1 = vec3(ivec3(
      int(packed.x) >> 24,
      int(packed.y << 24u) >> 24,
      int(packed.y << 16u) >> 24
    )) / 127.0;
    vec3 sh2_2 = vec3(ivec3(
      int(packed.y << 8u) >> 24,
      int(packed.y) >> 24,
      int(packed.z << 24u) >> 24
    )) / 127.0;
    vec3 sh2_3 = vec3(ivec3(
      int(packed.z << 16u) >> 24,
      int(packed.z << 8u) >> 24,
      int(packed.z) >> 24
    )) / 127.0;
    vec3 sh2_4 = vec3(ivec3(
      int(packed.w << 24u) >> 24,
      int(packed.w << 16u) >> 24,
      int(packed.w << 8u) >> 24
    )) / 127.0;

    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)
      + sh2_1 * (1.0925484 * viewDir.y * viewDir.z)
      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))
      + sh2_3 * (1.0925484 * viewDir.x * viewDir.z)
      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));
  }
`),Wa=lA(`
  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {
    // Extract sint6 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);
    vec3 sh3_0 = vec3(ivec3(
      int(packed.x << 26u) >> 26,
      int(packed.x << 20u) >> 26,
      int(packed.x << 14u) >> 26
    )) / 31.0;
    vec3 sh3_1 = vec3(ivec3(
      int(packed.x << 8u) >> 26,
      int(packed.x << 2u) >> 26,
      int((packed.x >> 4u) | (packed.y << 28u)) >> 26
    )) / 31.0;
    vec3 sh3_2 = vec3(ivec3(
      int(packed.y << 22u) >> 26,
      int(packed.y << 16u) >> 26,
      int(packed.y << 10u) >> 26
    )) / 31.0;
    vec3 sh3_3 = vec3(ivec3(
      int(packed.y << 4u) >> 26,
      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,
      int(packed.z << 24u) >> 26
    )) / 31.0;
    vec3 sh3_4 = vec3(ivec3(
      int(packed.z << 18u) >> 26,
      int(packed.z << 12u) >> 26,
      int(packed.z << 6u) >> 26
    )) / 31.0;
    vec3 sh3_5 = vec3(ivec3(
      int(packed.z) >> 26,
      int(packed.w << 26u) >> 26,
      int(packed.w << 20u) >> 26
    )) / 31.0;
    vec3 sh3_6 = vec3(ivec3(
      int(packed.w << 14u) >> 26,
      int(packed.w << 8u) >> 26,
      int(packed.w << 2u) >> 26
    )) / 31.0;

    float xx = viewDir.x * viewDir.x;
    float yy = viewDir.y * viewDir.y;
    float zz = viewDir.z * viewDir.z;
    float xy = viewDir.x * viewDir.y;
    float yz = viewDir.y * viewDir.z;
    float zx = viewDir.z * viewDir.x;

    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))
      + sh3_1 * (2.8906114 * xy * viewDir.z) +
      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))
      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))
      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))
      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))
      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));
  }
`);function $a(s,A,n){return Xn({inTypes:{gsplat:W,sh1:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:s,sh1:A,viewDir:n},globals:()=>[kA,Xa],statements:({inputs:t,outputs:e})=>bA(`
        if (isGsplatActive(${t.gsplat}.flags)) {
          ${e.rgb} = evaluateSH1(${t.gsplat}, ${t.sh1}, ${t.viewDir});
        } else {
          ${e.rgb} = vec3(0.0);
        }
      `)}).outputs.rgb}function Ar(s,A,n){return Xn({inTypes:{gsplat:W,sh2:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:s,sh2:A,viewDir:n},globals:()=>[kA,Za],statements:({inputs:t,outputs:e})=>bA(`
        if (isGsplatActive(${t.gsplat}.flags)) {
          ${e.rgb} = evaluateSH2(${t.gsplat}, ${t.sh2}, ${t.viewDir});
        } else {
          ${e.rgb} = vec3(0.0);
        }
      `)}).outputs.rgb}function nr(s,A,n){return Xn({inTypes:{gsplat:W,sh3:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:s,sh3:A,viewDir:n},globals:()=>[kA,Wa],statements:({inputs:t,outputs:e})=>bA(`
        if (isGsplatActive(${t.gsplat}.flags)) {
          ${e.rgb} = evaluateSH3(${t.gsplat}, ${t.sh3}, ${t.viewDir});
        } else {
          ${e.rgb} = vec3(0.0);
        }
      `)}).outputs.rgb}const es=class zn{constructor({fileBytes:A}){this.header="",this.littleEndian=!0,this.elements={},this.comments=[],this.data=null,this.numSplats=0,this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A}async parseHeader(){const n=new ReadableStream({start:a=>{a.enqueue(this.fileBytes.slice(0,65536)),a.close()}}).pipeThrough(new TextDecoderStream).getReader();this.header="";const t=`end_header
`;for(;;){const{value:a,done:r}=await n.read();if(r)throw new Error("Failed to read header");this.header+=a;const o=this.header.indexOf(t);if(o>=0){this.header=this.header.slice(0,o+t.length);break}}const e=new TextEncoder().encode(this.header).length;this.data=new DataView(this.fileBytes.buffer,e),this.elements={};let i=null;this.comments=[],this.header.trim().split(`
`).forEach((a,r)=>{const o=a.trim();if(r===0){if(o!=="ply")throw new Error("Invalid PLY header");return}if(o.length===0)return;const g=o.split(" ");switch(g[0]){case"format":if(g[1]==="binary_little_endian")this.littleEndian=!0;else if(g[1]==="binary_big_endian")this.littleEndian=!1;else throw new Error(`Unsupported PLY format: ${g[1]}`);if(g[2]!=="1.0")throw new Error(`Unsupported PLY version: ${g[2]}`);break;case"end_header":break;case"comment":this.comments.push(o.slice(8));break;case"element":{const c=g[1];i={name:c,count:Number.parseInt(g[2]),properties:{}},this.elements[c]=i;break}case"property":if(i==null)throw new Error("Property must be inside an element");g[1]==="list"?i.properties[g[4]]={isList:!0,type:g[3],countType:g[2]}:i.properties[g[2]]={isList:!1,type:g[1]};break}}),this.elements.vertex&&(this.numSplats=this.elements.vertex.count)}parseData(A){let n=0;const t=this.data;if(t==null)throw new Error("No data to parse");for(const e in this.elements){const i=this.elements[e],{count:a,properties:r}=i,o={},g=[];for(const[I,B]of Object.entries(r))B.isList?(o[I]=[],g.push(()=>{const Q=o[I];Q.length=_n[B.countType](t,n,this.littleEndian),n+=an[B.countType];for(let l=0;l<Q.length;l++)Q[l]=_n[B.type](t,n,this.littleEndian),n+=an[B.type]})):(o[I]=0,g.push(()=>{o[I]=_n[B.type](t,n,this.littleEndian),n+=an[B.type]}));const c=A(i)??(()=>{});for(let I=0;I<a;I++){for(const B of g)B();c(I,o)}}}parseSplats(A,n){if(this.elements.vertex==null)throw new Error("No vertex element found");let t=!1;const e=[];let i=0,a=[],r=[],o=[],g,c,I;function B(){const h=sr[i];a=new Array(3).fill(null).flatMap((f,u)=>[0,1,2].map((y,w)=>`f_rest_${u+w*h/3}`)),r=new Array(5).fill(null).flatMap((f,u)=>[0,1,2].map((y,w)=>`f_rest_${3+u+w*h/3}`)),o=new Array(7).fill(null).flatMap((f,u)=>[0,1,2].map((y,w)=>`f_rest_${8+u+w*h/3}`)),g=i>=1?new Float32Array(3*3):void 0,c=i>=2?new Float32Array(5*3):void 0,I=i>=3?new Float32Array(7*3):void 0}function Q(h,f){if(!g)throw new Error("Missing sh1");for(const[u,y]of a.entries())g[u]=f[y]*8/255-4;if(c)for(const[u,y]of r.entries())c[u]=f[y]*8/255-4;if(I)for(const[u,y]of o.entries())I[u]=f[y]*8/255-4;n?.(h,g,c,I)}function l(h){const{min_x:f,min_y:u,min_z:y,max_x:w,max_y:S,max_z:M,min_scale_x:K,min_scale_y:L,min_scale_z:P,max_scale_x:_,max_scale_y:j,max_scale_z:eA,min_r:V,min_g:sA,min_b:O,max_r:N,max_g:iA,max_b:Y}=h.properties;if(!f||!u||!y||!w||!S||!M||!K||!L||!P||!_||!j||!eA||!V||!sA||!O||!N||!iA||!Y)throw new Error("Missing PLY chunk properties");return t=!0,(wA,CA)=>{const{min_x:cA,min_y:aA,min_z:yA,max_x:rA,max_y:BA,max_z:v,min_scale_x:hA,min_scale_y:d,min_scale_z:p,max_scale_x:x,max_scale_y:D,max_scale_z:b,min_r:k,min_g:J,min_b:H,max_r:F,max_g:U,max_b:q}=CA;e.push({min_x:cA,min_y:aA,min_z:yA,max_x:rA,max_y:BA,max_z:v,min_scale_x:hA,min_scale_y:d,min_scale_z:p,max_scale_x:x,max_scale_y:D,max_scale_z:b,min_r:k,min_g:J,min_b:H,max_r:F,max_g:U,max_b:q})}}function C(h){if(n&&h.name==="sh")return i=Ae(h.properties),B(),Q;if(h.name!=="vertex")return null;const{packed_position:f,packed_rotation:u,packed_scale:y,packed_color:w}=h.properties;if(!f||!u||!y||!w)throw new Error("Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color");const S=Math.sqrt(2);return(M,K)=>{const L=e[M>>>8];if(L==null)throw new Error("Missing PLY chunk");const{min_x:P,min_y:_,min_z:j,max_x:eA,max_y:V,max_z:sA,min_scale_x:O,min_scale_y:N,min_scale_z:iA,max_scale_x:Y,max_scale_y:wA,max_scale_z:CA,min_r:cA,min_g:aA,min_b:yA,max_r:rA,max_g:BA,max_b:v}=L,{packed_position:hA,packed_rotation:d,packed_scale:p,packed_color:x}=K,D=(hA>>>21&2047)/2047*(eA-P)+P,b=(hA>>>11&1023)/1023*(V-_)+_,k=(hA&2047)/2047*(sA-j)+j,J=((d>>>20&1023)/1023-.5)*S,H=((d>>>10&1023)/1023-.5)*S,F=((d&1023)/1023-.5)*S,U=Math.sqrt(Math.max(0,1-J*J-H*H-F*F)),q=d>>>30,$=q===0?J:q===1?U:H,UA=q<=1?H:q===2?U:F,_A=q<=2?F:U,An=q===0?U:J,ls=Math.exp((p>>>21&2047)/2047*(Y-O)+O),Es=Math.exp((p>>>11&1023)/1023*(wA-N)+N),Cs=Math.exp((p&2047)/2047*(CA-iA)+iA),hs=(x>>>24&255)/255*(rA-cA)+cA,us=(x>>>16&255)/255*(BA-aA)+aA,ds=(x>>>8&255)/255*(v-yA)+yA,ps=(x&255)/255;A(M,D,b,k,ls,Es,Cs,$,UA,_A,An,ps,hs,us,ds)}}const E=h=>{if(h.name==="chunk")return l(h);if(t)return C(h);if(h.name!=="vertex")return null;const{x:f,y:u,z:y,scale_0:w,scale_1:S,scale_2:M,rot_0:K,rot_1:L,rot_2:P,rot_3:_,opacity:j,f_dc_0:eA,f_dc_1:V,f_dc_2:sA,red:O,green:N,blue:iA,alpha:Y}=h.properties;if(!f||!u||!y)throw new Error("Missing PLY properties: x, y, z");const wA=w&&S&&M,CA=K&&L&&P&&_,cA=Y!=null?Tn[Y.type]:1,aA=O!=null?Tn[O.type]:1,yA=N!=null?Tn[N.type]:1,rA=iA!=null?Tn[iA.type]:1;return i=Ae(h.properties),B(),(BA,v)=>{const hA=wA?Math.exp(v.scale_0):zn.defaultPointScale,d=wA?Math.exp(v.scale_1):zn.defaultPointScale,p=wA?Math.exp(v.scale_2):zn.defaultPointScale,x=CA?v.rot_1:0,D=CA?v.rot_2:0,b=CA?v.rot_3:0,k=CA?v.rot_0:1,J=j!=null?1/(1+Math.exp(-v.opacity)):Y!=null?v.alpha/cA:1,H=eA!=null?v.f_dc_0*Un+.5:O!=null?v.red/aA:1,F=V!=null?v.f_dc_1*Un+.5:N!=null?v.green/yA:1,U=sA!=null?v.f_dc_2*Un+.5:iA!=null?v.blue/rA:1;if(A(BA,v.x,v.y,v.z,hA,d,p,x,D,b,k,J,H,F,U),n&&g){if(g)for(const[q,$]of a.entries())g[q]=v[$];if(c)for(const[q,$]of r.entries())c[q]=v[$];if(I)for(const[q,$]of o.entries())I[q]=v[$];n(BA,g,c,I)}}};this.parseData(E)}injectRgba(A){let n=0;const t=this.data;if(t==null)throw new Error("No parsed data");if(A.length!==this.numSplats*4)throw new Error("Invalid RGBA array length");for(const e in this.elements){const i=this.elements[e],{count:a,properties:r}=i,o=[];let g=0;const c=e==="vertex";if(c){for(const I of["opacity","f_dc_0","f_dc_1","f_dc_2"])if(!r[I]||r[I].type!=="float")throw new Error(`Can't injectRgba due to property: ${I}`)}for(const[I,B]of Object.entries(r))if(B.isList)o.push(()=>{const Q=_n[B.countType](t,n,this.littleEndian);n+=an[B.countType],n+=Q*an[B.type]});else{if(c)if(I==="f_dc_0"||I==="f_dc_1"||I==="f_dc_2"){const Q=Number.parseInt(I.slice(5));o.push(()=>{const l=(A[g+Q]/255-.5)/Un;$t[B.type](t,n,this.littleEndian,l)})}else I==="opacity"&&o.push(()=>{const Q=Math.max(-100,Math.min(100,-Math.log(1/(A[g+3]/255)-1)));$t[B.type](t,n,this.littleEndian,Q)});o.push(()=>{n+=an[B.type]})}for(let I=0;I<a;I++){for(const B of o)B();c&&(g+=4)}}}};es.defaultPointScale=.001;let tr=es;const Un=.28209479177387814,_n={char:(s,A,n)=>s.getInt8(A),uchar:(s,A,n)=>s.getUint8(A),short:(s,A,n)=>s.getInt16(A,n),ushort:(s,A,n)=>s.getUint16(A,n),int:(s,A,n)=>s.getInt32(A,n),uint:(s,A,n)=>s.getUint32(A,n),float:(s,A,n)=>s.getFloat32(A,n),double:(s,A,n)=>s.getFloat64(A,n)},$t={char:(s,A,n,t)=>{s.setInt8(A,t)},uchar:(s,A,n,t)=>{s.setUint8(A,t)},short:(s,A,n,t)=>{s.setInt16(A,t,n)},ushort:(s,A,n,t)=>{s.setUint16(A,t,n)},int:(s,A,n,t)=>{s.setInt32(A,t,n)},uint:(s,A,n,t)=>{s.setUint32(A,t,n)},float:(s,A,n,t)=>{s.setFloat32(A,t,n)},double:(s,A,n,t)=>{s.setFloat64(A,t,n)}},an={char:1,uchar:1,short:2,ushort:2,int:4,uint:4,float:4,double:8},Tn={char:127,uchar:255,short:32767,ushort:65535,int:2147483647,uint:4294967295,float:1,double:1},er={0:0,9:1,24:2,45:3},sr={0:0,1:9,2:24,3:45};function Ae(s){let A=0;for(;s[`f_rest_${A}`];)A+=1;const n=er[A];if(n==null)throw new Error(`Unsupported number of SH coefficients: ${A}`);return n}const ss=`(function() {
  "use strict";
  let wasm;
  const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
    throw Error("TextDecoder not available");
  } };
  if (typeof TextDecoder !== "undefined") {
    cachedTextDecoder.decode();
  }
  let cachedUint8ArrayMemory0 = null;
  function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
  }
  function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
  }
  function sort_splats(num_splats, readback, ordering) {
    const ret = wasm.sort_splats(num_splats, readback, ordering);
    return ret >>> 0;
  }
  function raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid) {
    const ret = wasm.raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid);
    return ret;
  }
  async function __wbg_load(module, imports) {
    if (typeof Response === "function" && module instanceof Response) {
      if (typeof WebAssembly.instantiateStreaming === "function") {
        try {
          return await WebAssembly.instantiateStreaming(module, imports);
        } catch (e) {
          if (module.headers.get("Content-Type") != "application/wasm") {
            console.warn("\`WebAssembly.instantiateStreaming\` failed because your server does not serve Wasm with \`application/wasm\` MIME type. Falling back to \`WebAssembly.instantiate\` which is slower. Original error:\\n", e);
          } else {
            throw e;
          }
        }
      }
      const bytes = await module.arrayBuffer();
      return await WebAssembly.instantiate(bytes, imports);
    } else {
      const instance = await WebAssembly.instantiate(module, imports);
      if (instance instanceof WebAssembly.Instance) {
        return { instance, module };
      } else {
        return instance;
      }
    }
  }
  function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {
      const ret = arg0.buffer;
      return ret;
    };
    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {
      const ret = arg0.length;
      return ret;
    };
    imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {
      const ret = arg0.length;
      return ret;
    };
    imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {
      const ret = arg0.length;
      return ret;
    };
    imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {
      const ret = new Uint16Array(arg0);
      return ret;
    };
    imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {
      const ret = new Uint32Array(arg0);
      return ret;
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {
      const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);
      return ret;
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {
      const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);
      return ret;
    };
    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {
      const ret = new Float32Array(arg0 >>> 0);
      return ret;
    };
    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {
      arg0.set(arg1, arg2 >>> 0);
    };
    imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {
      arg0.set(arg1, arg2 >>> 0);
    };
    imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {
      arg0.set(arg1, arg2 >>> 0);
    };
    imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {
      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
      return ret;
    };
    imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {
      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
      return ret;
    };
    imports.wbg.__wbindgen_init_externref_table = function() {
      const table = wasm.__wbindgen_export_0;
      const offset = table.grow(4);
      table.set(0, void 0);
      table.set(offset + 0, void 0);
      table.set(offset + 1, null);
      table.set(offset + 2, true);
      table.set(offset + 3, false);
    };
    imports.wbg.__wbindgen_memory = function() {
      const ret = wasm.memory;
      return ret;
    };
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
    return imports;
  }
  function __wbg_finalize_init(instance, module) {
    wasm = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedUint8ArrayMemory0 = null;
    wasm.__wbindgen_start();
    return wasm;
  }
  async function __wbg_init(module_or_path) {
    if (wasm !== void 0) return wasm;
    if (typeof module_or_path !== "undefined") {
      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
        ({ module_or_path } = module_or_path);
      } else {
        console.warn("using deprecated parameters for the initialization function; pass a single object instead");
      }
    }
    if (typeof module_or_path === "undefined") {
      module_or_path = new URL("data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUF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BSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIM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AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSAN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IABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9v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Zm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCCkGBAAEgAAALYYEAAiAAAAcmFuZ2UgZW5kIGluZGV4IOgYEAAQAAAAthgQACIAAABzbGljZSBpbmRleCBzdGFydHMgYXQgIGJ1dCBlbmRzIGF0IAAIGRAAFgAAAB4ZEAANAAAAYXR0ZW1wdGVkIHRvIGluZGV4IHNsaWNlIGZyb20gYWZ0ZXIgbWF4aW11bSB1c2l6ZQAAADwZEAAxAAAAYXR0ZW1wdGVkIHRvIGluZGV4IHNsaWNlIHVwIHRvIG1heGltdW0gdXNpemV4GRAALAAAAGF0dGVtcHRlZCB0byBpbmRleCBzdHIgdXAgdG8gbWF4aW11bSB1c2l6ZQAArBkQACoAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBorXAAAszAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwMDAwMDAwMDAwMDAwMDAwQEBAQEAEHgtcAAC8UWY29yZS9zcmMvc3RyL3BhdHRlcm4ucnMA4BoQABcAAABXBQAAEgAAAOAaEAAXAAAAVwUAACgAAADgGhAAFwAAAEoGAAAVAAAA4BoQABcAAAB4BgAAFQAAAOAaEAAXAAAAeQYAABUAAAAAWy4uLl1iZWdpbiA8PSBlbmQgKCA8PSApIHdoZW4gc2xpY2luZyBgYAAAAE4bEAAOAAAAXBsQAAQAAABgGxAAEAAAAHAbEAABAAAAYnl0ZSBpbmRleCAgaXMgbm90IGEgY2hhciBib3VuZGFyeTsgaXQgaXMgaW5zaWRlICAoYnl0ZXMgKSBvZiBgAJQbEAALAAAAnxsQACYAAADFGxAACAAAAM0bEAAGAAAAcBsQAAEAAAAgaXMgb3V0IG9mIGJvdW5kcyBvZiBgAACUGxAACwAAAPwbEAAWAAAAcBsQAAEAAABjb3JlL3NyYy9zdHIvbW9kLnJzACwcEAATAAAA8QAAACwAAABjb3JlL3NyYy91bmljb2RlL3ByaW50YWJsZS5ycwAAAFAcEAAdAAAAGgAAADYAAABQHBAAHQAAAAoAAAArAAAAAAYBAQMBBAIFBwcCCAgJAgoFCwIOBBABEQISBRMcFAEVAhcCGQ0cBR0IHwEkAWoEawKvA7ECvALPAtEC1AzVCdYC1wLaAeAF4QLnBOgC7iDwBPgC+gT7AQwnOz5OT4+enp97i5OWorK6hrEGBwk2PT5W89DRBBQYNjdWV3+qrq+9NeASh4mOngQNDhESKTE0OkVGSUpOT2RlioyNj7bBw8TGy9ZctrcbHAcICgsUFzY5Oqip2NkJN5CRqAcKOz5maY+SEW9fv+7vWmL0/P9TVJqbLi8nKFWdoKGjpKeorbq8xAYLDBUdOj9FUaanzM2gBxkaIiU+P+fs7//FxgQgIyUmKDM4OkhKTFBTVVZYWlxeYGNlZmtzeH1/iqSqr7DA0K6vbm/d3pNeInsFAwQtA2YDAS8ugIIdAzEPHAQkCR4FKwVEBA4qgKoGJAQkBCgINAtOAzQMgTcJFgoIGDtFOQNjCAkwFgUhAxsFAUA4BEsFLwQKBwkHQCAnBAwJNgM6BRoHBAwHUEk3Mw0zBy4ICgYmAx0IAoDQUhADNywIKhYaJhwUFwlOBCQJRA0ZBwoGSAgnCXULQj4qBjsFCgZRBgEFEAMFC1kIAh1iHkgICoCmXiJFCwoGDRM6BgoGFBwsBBeAuTxkUwxICQpGRRtICFMNSQcKgLYiDgoGRgodA0dJNwMOCAoGOQcKgTYZBzsDHVUBDzINg5tmdQuAxIpMYw2EMBAWCo+bBYJHmrk6hsaCOQcqBFwGJgpGCigFE4GwOoDGW2VLBDkHEUAFCwIOl/gIhNYpCqLngTMPAR0GDgQIgYyJBGsFDQMJBxCPYID6BoG0TEcJdDyA9gpzCHAVRnoUDBQMVwkZgIeBRwOFQg8VhFAfBgaA1SsFPiEBcC0DGgQCgUAfEToFAYHQKoDWKwQBgeCA9ylMBAoEAoMRREw9gMI8BgEEVQUbNAKBDiwEZAxWCoCuOB0NLAQJBwIOBoCag9gEEQMNA3cEXwYMBAEPDAQ4CAoGKAgsBAI+gVQMHQMKBTgHHAYJB4D6hAYAAQMFBQYGAgcGCAcJEQocCxkMGg0QDgwPBBADEhITCRYBFwQYARkDGgcbARwCHxYgAysDLQsuATAEMQIyAacEqQKqBKsI+gL7Bf0C/gP/Ca14eYuNojBXWIuMkBzdDg9LTPv8Li8/XF1f4oSNjpGSqbG6u8XGycre5OX/AAQREikxNDc6Oz1JSl2EjpKpsbS6u8bKzs/k5QAEDQ4REikxNDo7RUZJSl5kZYSRm53Jzs8NESk6O0VJV1tcXl9kZY2RqbS6u8XJ3+Tl8A0RRUlkZYCEsry+v9XX8PGDhYukpr6/xcfP2ttImL3Nxs7PSU5PV1leX4mOj7G2t7/BxsfXERYXW1z29/7/gG1x3t8OH25vHB1ffX6ur027vBYXHh9GR05PWFpcXn5/tcXU1dzw8fVyc490dZYmLi+nr7e/x8/X35oAQJeYMI8fzs/S1M7/Tk9aWwcIDxAnL+7vbm83PT9CRZCRU2d1yMnQ0djZ5/7/ACBfIoLfBIJECBsEBhGBrA6AqwUfCIEcAxkIAQQvBDQEBwMBBwYHEQpQDxIHVQcDBBwKCQMIAwcDAgMDAwwEBQMLBgEOFQVOBxsHVwcCBhcMUARDAy0DAQQRBg8MOgQdJV8gbQRqJYDIBYKwAxoGgv0DWQcWCRgJFAwUDGoGCgYaBlkHKwVGCiwEDAQBAzELLAQaBgsDgKwGCgYvMYD0CDwDDwM+BTgIKwWC/xEYCC8RLQMhDyEPgIwEgpoWCxWIlAUvBTsHAg4YCYC+InQMgNYagRAFgOEJ8p4DNwmBXBSAuAiA3RU7AwoGOAhGCAwGdAseA1oEWQmAgxgcChYJTASAigarpAwXBDGhBIHaJgcMBQWAphCB9QcBICoGTASAjQSAvgMbAw8NY29yZS9zcmMvdW5pY29kZS91bmljb2RlX2RhdGEucnMAAAA5IhAAIAAAAE4AAAAoAAAAOSIQACAAAABaAAAAFgAAAGNvcmUvc3JjL251bS9tb2QucnMAfCIQABMAAAAbBgAAAQAAAAADAACDBCAAkQVgAF0ToAASFyAfDCBgH+8sICsqMKArb6ZgLAKo4Cwe++AtAP4gNp7/YDb9AeE2AQohNyQN4TerDmE5LxjhOTAc4UrzHuFOQDShUh5h4VPwamFUT2/hVJ28YVUAz2FWZdGhVgDaIVcA4KFYruIhWuzk4VvQ6GFcIADuXPABf10AcAAHAC0BAQECAQIBAUgLMBUQAWUHAgYCAgEEIwEeG1sLOgkJARgEAQkBAwEFKwM7CSoYASA3AQEBBAgEAQMHCgIdAToBAQECBAgBCQEKAhoBAgI5AQQCBAICAwMBHgIDAQsCOQEEBQECBAEUAhYGAQE6AQECAQQIAQcDCgIeATsBAQEMAQkBKAEDATcBAQMFAwEEBwILAh0BOgECAgEBAwMBBAcCCwIcAjkCAQECBAgBCQEKAh0BSAEEAQIDAQEIAVEBAgcMCGIBAgkLB0kCGwEBAQEBNw4BBQECBQsBJAkBZgQBBgECAgIZAgQDEAQNAQICBgEPAQADAAQcAx0CHgJAAgEHCAECCwkBLQMBAXUCIgF2AwQCCQEGA9sCAgE6AQEHAQEBAQIIBgoCATAfMQQwCgQDJgkMAiAEAgY4AQECAwEBBTgIAgKYAwENAQcEAQYBAwLGQAABwyEAA40BYCAABmkCAAQBCiACUAIAAQMBBAEZAgUBlwIaEg0BJggZCwEBLAMwAQIEAgICASQBQwYCAgICDAEIAS8BMwEBAwICBQIBASoCCAHuAQIBBAEAAQAQEBAAAgAB4gGVBQADAQIFBCgDBAGlAgAEQQUAAk8ERgsxBHsBNg8pAQICCgMxBAICBwE9AyQFAQg+AQwCNAkBAQgEAgFfAwIEBgECAZ0BAwgVAjkCAQEBAQwBCQEOBwMFQwECBgEBAgEBAwQDAQEOAlUIAgMBARcBUQECBgEBAgEBAgEC6wECBAYCAQIbAlUIAgEBAmoBAQECCGUBAQECBAEFAAkBAvUBCgQEAZAEAgIEASAKKAYCBAgBCQYCAy4NAQIABwEGAQFSFgIHAQIBAnoGAwEBAgEHAQFIAgMBAQEAAgsCNAUFAxcBAAEGDwAMAwMABTsHAAE/BFEBCwIAAgAuAhcABQMGCAgCBx4ElAMANwQyCAEOARYFAQ8ABwERAgcBAgEFZAGgBwABPQQABP4CAAdtBwBggPAAAgICAgICAgICAwMBAQEAQbfMwAALEAEAAAAAAAAAAgIAAAAAAAIAQfbMwAALAQIAQZzNwAALAQEAQbfNwAALAQEAQZvOwAALBT8AAAC/AEG4zsAACwE2AHAJcHJvZHVjZXJzAghsYW5ndWFnZQEEUnVzdAAMcHJvY2Vzc2VkLWJ5AwVydXN0Yx0xLjgzLjAgKDkwYjM1YTYyMyAyMDI0LTExLTI2KQZ3YWxydXMGMC4yMy4zDHdhc20tYmluZGdlbgcwLjIuMTAwAEkPdGFyZ2V0X2ZlYXR1cmVzBCsPbXV0YWJsZS1nbG9iYWxzKwhzaWduLWV4dCsPcmVmZXJlbmNlLXR5cGVzKwptdWx0aXZhbHVl", self.location.href);
    }
    const imports = __wbg_get_imports();
    if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
      module_or_path = fetch(module_or_path);
    }
    const { instance, module } = await __wbg_load(await module_or_path, imports);
    return __wbg_finalize_init(instance, module);
  }
  var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
  var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */
    0,
    0,
    /* impossible */
    0
  ]);
  var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */
    0,
    0
  ]);
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var freb = function(eb, start) {
    var b = new u16(31);
    for (var i2 = 0; i2 < 31; ++i2) {
      b[i2] = start += 1 << eb[i2 - 1];
    }
    var r = new i32(b[30]);
    for (var i2 = 1; i2 < 30; ++i2) {
      for (var j = b[i2]; j < b[i2 + 1]; ++j) {
        r[j] = j - b[i2] << 5 | i2;
      }
    }
    return { b, r };
  };
  var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0), fd = _b.b;
  var rev = new u16(32768);
  for (var i = 0; i < 32768; ++i) {
    var x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  var hMap = function(cd, mb, r) {
    var s = cd.length;
    var i2 = 0;
    var l = new u16(mb);
    for (; i2 < s; ++i2) {
      if (cd[i2])
        ++l[cd[i2] - 1];
    }
    var le = new u16(mb);
    for (i2 = 1; i2 < mb; ++i2) {
      le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
    }
    var co;
    if (r) {
      co = new u16(1 << mb);
      var rvb = 15 - mb;
      for (i2 = 0; i2 < s; ++i2) {
        if (cd[i2]) {
          var sv = i2 << 4 | cd[i2];
          var r_1 = mb - cd[i2];
          var v = le[cd[i2] - 1]++ << r_1;
          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
            co[rev[v] >> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s);
      for (i2 = 0; i2 < s; ++i2) {
        if (cd[i2]) {
          co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
        }
      }
    }
    return co;
  };
  var flt = new u8(288);
  for (var i = 0; i < 144; ++i)
    flt[i] = 8;
  for (var i = 144; i < 256; ++i)
    flt[i] = 9;
  for (var i = 256; i < 280; ++i)
    flt[i] = 7;
  for (var i = 280; i < 288; ++i)
    flt[i] = 8;
  var fdt = new u8(32);
  for (var i = 0; i < 32; ++i)
    fdt[i] = 5;
  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  var max = function(a) {
    var m = a[0];
    for (var i2 = 1; i2 < a.length; ++i2) {
      if (a[i2] > m)
        m = a[i2];
    }
    return m;
  };
  var bits = function(d, p, m) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
  };
  var bits16 = function(d, p) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
  };
  var shft = function(p) {
    return (p + 7) / 8 | 0;
  };
  var slc = function(v, s, e) {
    if (s == null || s < 0)
      s = 0;
    if (e == null || e > v.length)
      e = v.length;
    return new u8(v.subarray(s, e));
  };
  var ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
    // determined by unknown compression method
  ];
  var err = function(ind, msg, nt) {
    var e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace)
      Error.captureStackTrace(e, err);
    if (!nt)
      throw e;
    return e;
  };
  var inflt = function(dat, st, buf, dict) {
    var sl = dat.length, dl = 0;
    if (!sl || st.f && !st.l)
      return buf || new u8(0);
    var noBuf = !buf;
    var resize = noBuf || st.i != 2;
    var noSt = st.i;
    if (noBuf)
      buf = new u8(sl * 3);
    var cbuf = function(l2) {
      var bl = buf.length;
      if (l2 > bl) {
        var nbuf = new u8(Math.max(bl * 2, l2));
        nbuf.set(buf);
        buf = nbuf;
      }
    };
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    var tbts = sl * 8;
    do {
      if (!lm) {
        final = bits(dat, pos, 1);
        var type = bits(dat, pos + 1, 3);
        pos += 3;
        if (!type) {
          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
          if (t > sl) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + l);
          buf.set(dat.subarray(s, t), bt);
          st.b = bt += l, st.p = pos = t * 8, st.f = final;
          continue;
        } else if (type == 1)
          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
        else if (type == 2) {
          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
          var tl = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14;
          var ldt = new u8(tl);
          var clt = new u8(19);
          for (var i2 = 0; i2 < hcLen; ++i2) {
            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
          }
          pos += hcLen * 3;
          var clb = max(clt), clbmsk = (1 << clb) - 1;
          var clm = hMap(clt, clb, 1);
          for (var i2 = 0; i2 < tl; ) {
            var r = clm[bits(dat, pos, clbmsk)];
            pos += r & 15;
            var s = r >> 4;
            if (s < 16) {
              ldt[i2++] = s;
            } else {
              var c = 0, n = 0;
              if (s == 16)
                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
              else if (s == 17)
                n = 3 + bits(dat, pos, 7), pos += 3;
              else if (s == 18)
                n = 11 + bits(dat, pos, 127), pos += 7;
              while (n--)
                ldt[i2++] = c;
            }
          }
          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
          lbt = max(lt);
          dbt = max(dt);
          lm = hMap(lt, lbt, 1);
          dm = hMap(dt, dbt, 1);
        } else
          err(1);
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
      }
      if (resize)
        cbuf(bt + 131072);
      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
      var lpos = pos;
      for (; ; lpos = pos) {
        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
        pos += c & 15;
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (!c)
          err(2);
        if (sym < 256)
          buf[bt++] = sym;
        else if (sym == 256) {
          lpos = pos, lm = null;
          break;
        } else {
          var add2 = sym - 254;
          if (sym > 264) {
            var i2 = sym - 257, b = fleb[i2];
            add2 = bits(dat, pos, (1 << b) - 1) + fl[i2];
            pos += b;
          }
          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
          if (!d)
            err(3);
          pos += d & 15;
          var dt = fd[dsym];
          if (dsym > 3) {
            var b = fdeb[dsym];
            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
          }
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + 131072);
          var end = bt + add2;
          if (bt < dt) {
            var shift = dl - dt, dend = Math.min(dt, end);
            if (shift + bt < 0)
              err(3);
            for (; bt < dend; ++bt)
              buf[bt] = dict[shift + bt];
          }
          for (; bt < end; ++bt)
            buf[bt] = buf[bt - dt];
        }
      }
      st.l = lm, st.p = lpos, st.b = bt, st.f = final;
      if (lm)
        final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
  };
  var et = /* @__PURE__ */ new u8(0);
  var gzs = function(d) {
    if (d[0] != 31 || d[1] != 139 || d[2] != 8)
      err(6, "invalid gzip data");
    var flg = d[3];
    var st = 10;
    if (flg & 4)
      st += (d[10] | d[11] << 8) + 2;
    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
      ;
    return st + (flg & 2);
  };
  var Inflate = /* @__PURE__ */ function() {
    function Inflate2(opts, cb) {
      if (typeof opts == "function")
        cb = opts, opts = {};
      this.ondata = cb;
      var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
      this.s = { i: 0, b: dict ? dict.length : 0 };
      this.o = new u8(32768);
      this.p = new u8(0);
      if (dict)
        this.o.set(dict);
    }
    Inflate2.prototype.e = function(c) {
      if (!this.ondata)
        err(5);
      if (this.d)
        err(4);
      if (!this.p.length)
        this.p = c;
      else if (c.length) {
        var n = new u8(this.p.length + c.length);
        n.set(this.p), n.set(c, this.p.length), this.p = n;
      }
    };
    Inflate2.prototype.c = function(final) {
      this.s.i = +(this.d = final || false);
      var bts = this.s.b;
      var dt = inflt(this.p, this.s, this.o);
      this.ondata(slc(dt, bts, this.s.b), this.d);
      this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
      this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    };
    Inflate2.prototype.push = function(chunk, final) {
      this.e(chunk), this.c(final);
    };
    return Inflate2;
  }();
  var Gunzip = /* @__PURE__ */ function() {
    function Gunzip2(opts, cb) {
      this.v = 1;
      this.r = 0;
      Inflate.call(this, opts, cb);
    }
    Gunzip2.prototype.push = function(chunk, final) {
      Inflate.prototype.e.call(this, chunk);
      this.r += chunk.length;
      if (this.v) {
        var p = this.p.subarray(this.v - 1);
        var s = p.length > 3 ? gzs(p) : 4;
        if (s > p.length) {
          if (!final)
            return;
        } else if (this.v > 1 && this.onmember) {
          this.onmember(this.r - p.length);
        }
        this.p = p.subarray(s), this.v = 0;
      }
      Inflate.prototype.c.call(this, final);
      if (this.s.f && !this.s.l && !final) {
        this.v = shft(this.s.p) + 9;
        this.s = { i: 0 };
        this.o = new u8(0);
        this.push(new u8(0), final);
      }
    };
    return Gunzip2;
  }();
  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
  var tds = 0;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e) {
  }
  /**
   * @license
   * Copyright 2010-2024 Three.js Authors
   * SPDX-License-Identifier: MIT
   */
  const REVISION = "172";
  const FrontSide = 0;
  const BackSide = 1;
  const NormalBlending = 1;
  const AddEquation = 100;
  const SrcAlphaFactor = 204;
  const OneMinusSrcAlphaFactor = 205;
  const LessEqualDepth = 3;
  const MultiplyOperation = 0;
  const UVMapping = 300;
  const RepeatWrapping = 1e3;
  const ClampToEdgeWrapping = 1001;
  const MirroredRepeatWrapping = 1002;
  const NearestFilter = 1003;
  const LinearFilter = 1006;
  const LinearMipmapLinearFilter = 1008;
  const UnsignedByteType = 1009;
  const UnsignedIntType = 1014;
  const FloatType = 1015;
  const RGBAFormat = 1023;
  const RGIntegerFormat = 1031;
  const RGBAIntegerFormat = 1033;
  const NoColorSpace = "";
  const SRGBColorSpace = "srgb";
  const LinearSRGBColorSpace = "srgb-linear";
  const LinearTransfer = "linear";
  const SRGBTransfer = "srgb";
  const KeepStencilOp = 7680;
  const AlwaysStencilFunc = 519;
  const StaticDrawUsage = 35044;
  const GLSL3 = "300 es";
  const WebGLCoordinateSystem = 2e3;
  const WebGPUCoordinateSystem = 2001;
  class EventDispatcher {
    addEventListener(type, listener) {
      if (this._listeners === void 0) this._listeners = {};
      const listeners = this._listeners;
      if (listeners[type] === void 0) {
        listeners[type] = [];
      }
      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    }
    hasEventListener(type, listener) {
      if (this._listeners === void 0) return false;
      const listeners = this._listeners;
      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
    }
    removeEventListener(type, listener) {
      if (this._listeners === void 0) return;
      const listeners = this._listeners;
      const listenerArray = listeners[type];
      if (listenerArray !== void 0) {
        const index = listenerArray.indexOf(listener);
        if (index !== -1) {
          listenerArray.splice(index, 1);
        }
      }
    }
    dispatchEvent(event) {
      if (this._listeners === void 0) return;
      const listeners = this._listeners;
      const listenerArray = listeners[event.type];
      if (listenerArray !== void 0) {
        event.target = this;
        const array = listenerArray.slice(0);
        for (let i2 = 0, l = array.length; i2 < l; i2++) {
          array[i2].call(this, event);
        }
        event.target = null;
      }
    }
  }
  const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
  function generateUUID() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
    return uuid.toLowerCase();
  }
  function clamp(value, min, max2) {
    return Math.max(min, Math.min(max2, value));
  }
  function euclideanModulo(n, m) {
    return (n % m + m) % m;
  }
  function lerp(x2, y, t) {
    return (1 - t) * x2 + t * y;
  }
  function denormalize(value, array) {
    switch (array.constructor) {
      case Float32Array:
        return value;
      case Uint32Array:
        return value / 4294967295;
      case Uint16Array:
        return value / 65535;
      case Uint8Array:
        return value / 255;
      case Int32Array:
        return Math.max(value / 2147483647, -1);
      case Int16Array:
        return Math.max(value / 32767, -1);
      case Int8Array:
        return Math.max(value / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function normalize$1(value, array) {
    switch (array.constructor) {
      case Float32Array:
        return value;
      case Uint32Array:
        return Math.round(value * 4294967295);
      case Uint16Array:
        return Math.round(value * 65535);
      case Uint8Array:
        return Math.round(value * 255);
      case Int32Array:
        return Math.round(value * 2147483647);
      case Int16Array:
        return Math.round(value * 32767);
      case Int8Array:
        return Math.round(value * 127);
      default:
        throw new Error("Invalid component type.");
    }
  }
  class Vector2 {
    constructor(x2 = 0, y = 0) {
      Vector2.prototype.isVector2 = true;
      this.x = x2;
      this.y = y;
    }
    get width() {
      return this.x;
    }
    set width(value) {
      this.x = value;
    }
    get height() {
      return this.y;
    }
    set height(value) {
      this.y = value;
    }
    set(x2, y) {
      this.x = x2;
      this.y = y;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      return this;
    }
    setX(x2) {
      this.x = x2;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    }
    add(v) {
      this.x += v.x;
      this.y += v.y;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      return this;
    }
    sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      return this;
    }
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m) {
      const x2 = this.x, y = this.y;
      const e = m.elements;
      this.x = e[0] * x2 + e[3] * y + e[6];
      this.y = e[1] * x2 + e[4] * y + e[7];
      return this;
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      return this;
    }
    clamp(min, max2) {
      this.x = clamp(this.x, min.x, max2.x);
      this.y = clamp(this.y, min.y, max2.y);
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = clamp(this.x, minVal, maxVal);
      this.y = clamp(this.y, minVal, maxVal);
      return this;
    }
    clampLength(min, max2) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
    roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y;
    }
    cross(v) {
      return this.x * v.y - this.y * v.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      const angle = Math.atan2(-this.y, -this.x) + Math.PI;
      return angle;
    }
    angleTo(v) {
      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0) return Math.PI / 2;
      const theta = this.dot(v) / denominator;
      return Math.acos(clamp(theta, -1, 1));
    }
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
      const dx = this.x - v.x, dy = this.y - v.y;
      return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      return this;
    }
    rotateAround(center, angle) {
      const c = Math.cos(angle), s = Math.sin(angle);
      const x2 = this.x - center.x;
      const y = this.y - center.y;
      this.x = x2 * c - y * s + center.x;
      this.y = x2 * s + y * c + center.y;
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
    }
  }
  class Matrix3 {
    constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      Matrix3.prototype.isMatrix3 = true;
      this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ];
      if (n11 !== void 0) {
        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
      }
    }
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      const te = this.elements;
      te[0] = n11;
      te[1] = n21;
      te[2] = n31;
      te[3] = n12;
      te[4] = n22;
      te[5] = n32;
      te[6] = n13;
      te[7] = n23;
      te[8] = n33;
      return this;
    }
    identity() {
      this.set(
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      );
      return this;
    }
    copy(m) {
      const te = this.elements;
      const me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrix3Column(this, 0);
      yAxis.setFromMatrix3Column(this, 1);
      zAxis.setFromMatrix3Column(this, 2);
      return this;
    }
    setFromMatrix4(m) {
      const me = m.elements;
      this.set(
        me[0],
        me[4],
        me[8],
        me[1],
        me[5],
        me[9],
        me[2],
        me[6],
        me[10]
      );
      return this;
    }
    multiply(m) {
      return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
      const ae = a.elements;
      const be = b.elements;
      const te = this.elements;
      const a11 = ae[0], a12 = ae[3], a13 = ae[6];
      const a21 = ae[1], a22 = ae[4], a23 = ae[7];
      const a31 = ae[2], a32 = ae[5], a33 = ae[8];
      const b11 = be[0], b12 = be[3], b13 = be[6];
      const b21 = be[1], b22 = be[4], b23 = be[7];
      const b31 = be[2], b32 = be[5], b33 = be[8];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    }
    multiplyScalar(s) {
      const te = this.elements;
      te[0] *= s;
      te[3] *= s;
      te[6] *= s;
      te[1] *= s;
      te[4] *= s;
      te[7] *= s;
      te[2] *= s;
      te[5] *= s;
      te[8] *= s;
      return this;
    }
    determinant() {
      const te = this.elements;
      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];
      return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;
    }
    invert() {
      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n31 * n23 - n33 * n21) * detInv;
      te[2] = (n32 * n21 - n31 * n22) * detInv;
      te[3] = t12 * detInv;
      te[4] = (n33 * n11 - n31 * n13) * detInv;
      te[5] = (n31 * n12 - n32 * n11) * detInv;
      te[6] = t13 * detInv;
      te[7] = (n21 * n13 - n23 * n11) * detInv;
      te[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    }
    transpose() {
      let tmp;
      const m = this.elements;
      tmp = m[1];
      m[1] = m[3];
      m[3] = tmp;
      tmp = m[2];
      m[2] = m[6];
      m[6] = tmp;
      tmp = m[5];
      m[5] = m[7];
      m[7] = tmp;
      return this;
    }
    getNormalMatrix(matrix4) {
      return this.setFromMatrix4(matrix4).invert().transpose();
    }
    transposeIntoArray(r) {
      const m = this.elements;
      r[0] = m[0];
      r[1] = m[3];
      r[2] = m[6];
      r[3] = m[1];
      r[4] = m[4];
      r[5] = m[7];
      r[6] = m[2];
      r[7] = m[5];
      r[8] = m[8];
      return this;
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
      const c = Math.cos(rotation);
      const s = Math.sin(rotation);
      this.set(
        sx * c,
        sx * s,
        -sx * (c * cx + s * cy) + cx + tx,
        -sy * s,
        sy * c,
        -sy * (-s * cx + c * cy) + cy + ty,
        0,
        0,
        1
      );
      return this;
    }
    //
    scale(sx, sy) {
      this.premultiply(_m3.makeScale(sx, sy));
      return this;
    }
    rotate(theta) {
      this.premultiply(_m3.makeRotation(-theta));
      return this;
    }
    translate(tx, ty) {
      this.premultiply(_m3.makeTranslation(tx, ty));
      return this;
    }
    // for 2D Transforms
    makeTranslation(x2, y) {
      if (x2.isVector2) {
        this.set(
          1,
          0,
          x2.x,
          0,
          1,
          x2.y,
          0,
          0,
          1
        );
      } else {
        this.set(
          1,
          0,
          x2,
          0,
          1,
          y,
          0,
          0,
          1
        );
      }
      return this;
    }
    makeRotation(theta) {
      const c = Math.cos(theta);
      const s = Math.sin(theta);
      this.set(
        c,
        -s,
        0,
        s,
        c,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeScale(x2, y) {
      this.set(
        x2,
        0,
        0,
        0,
        y,
        0,
        0,
        0,
        1
      );
      return this;
    }
    //
    equals(matrix) {
      const te = this.elements;
      const me = matrix.elements;
      for (let i2 = 0; i2 < 9; i2++) {
        if (te[i2] !== me[i2]) return false;
      }
      return true;
    }
    fromArray(array, offset = 0) {
      for (let i2 = 0; i2 < 9; i2++) {
        this.elements[i2] = array[i2 + offset];
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      return array;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  const _m3 = /* @__PURE__ */ new Matrix3();
  function arrayNeedsUint32(array) {
    for (let i2 = array.length - 1; i2 >= 0; --i2) {
      if (array[i2] >= 65535) return true;
    }
    return false;
  }
  function createElementNS(name) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", name);
  }
  const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322
  );
  const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715
  );
  function createColorManagement() {
    const ColorManagement2 = {
      enabled: true,
      workingColorSpace: LinearSRGBColorSpace,
      /**
       * Implementations of supported color spaces.
       *
       * Required:
       *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
       *	- whitePoint: reference white [ x y ]
       *	- transfer: transfer function (pre-defined)
       *	- toXYZ: Matrix3 RGB to XYZ transform
       *	- fromXYZ: Matrix3 XYZ to RGB transform
       *	- luminanceCoefficients: RGB luminance coefficients
       *
       * Optional:
       *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
       *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
       *
       * Reference:
       * - https://www.russellcottrell.com/photo/matrixCalculator.htm
       */
      spaces: {},
      convert: function(color, sourceColorSpace, targetColorSpace) {
        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
          return color;
        }
        if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {
          color.r = SRGBToLinear(color.r);
          color.g = SRGBToLinear(color.g);
          color.b = SRGBToLinear(color.b);
        }
        if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {
          color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);
          color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);
        }
        if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {
          color.r = LinearToSRGB(color.r);
          color.g = LinearToSRGB(color.g);
          color.b = LinearToSRGB(color.b);
        }
        return color;
      },
      fromWorkingColorSpace: function(color, targetColorSpace) {
        return this.convert(color, this.workingColorSpace, targetColorSpace);
      },
      toWorkingColorSpace: function(color, sourceColorSpace) {
        return this.convert(color, sourceColorSpace, this.workingColorSpace);
      },
      getPrimaries: function(colorSpace) {
        return this.spaces[colorSpace].primaries;
      },
      getTransfer: function(colorSpace) {
        if (colorSpace === NoColorSpace) return LinearTransfer;
        return this.spaces[colorSpace].transfer;
      },
      getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {
        return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);
      },
      define: function(colorSpaces) {
        Object.assign(this.spaces, colorSpaces);
      },
      // Internal APIs
      _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {
        return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);
      },
      _getDrawingBufferColorSpace: function(colorSpace) {
        return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {
        return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;
      }
    };
    const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];
    const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];
    const D65 = [0.3127, 0.329];
    ColorManagement2.define({
      [LinearSRGBColorSpace]: {
        primaries: REC709_PRIMARIES,
        whitePoint: D65,
        transfer: LinearTransfer,
        toXYZ: LINEAR_REC709_TO_XYZ,
        fromXYZ: XYZ_TO_LINEAR_REC709,
        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
        workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
      },
      [SRGBColorSpace]: {
        primaries: REC709_PRIMARIES,
        whitePoint: D65,
        transfer: SRGBTransfer,
        toXYZ: LINEAR_REC709_TO_XYZ,
        fromXYZ: XYZ_TO_LINEAR_REC709,
        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
      }
    });
    return ColorManagement2;
  }
  const ColorManagement = /* @__PURE__ */ createColorManagement();
  function SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
  }
  function LinearToSRGB(c) {
    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
  }
  let _canvas;
  class ImageUtils {
    static getDataURL(image) {
      if (/^data:/i.test(image.src)) {
        return image.src;
      }
      if (typeof HTMLCanvasElement === "undefined") {
        return image.src;
      }
      let canvas;
      if (image instanceof HTMLCanvasElement) {
        canvas = image;
      } else {
        if (_canvas === void 0) _canvas = createElementNS("canvas");
        _canvas.width = image.width;
        _canvas.height = image.height;
        const context = _canvas.getContext("2d");
        if (image instanceof ImageData) {
          context.putImageData(image, 0, 0);
        } else {
          context.drawImage(image, 0, 0, image.width, image.height);
        }
        canvas = _canvas;
      }
      if (canvas.width > 2048 || canvas.height > 2048) {
        console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
        return canvas.toDataURL("image/jpeg", 0.6);
      } else {
        return canvas.toDataURL("image/png");
      }
    }
    static sRGBToLinear(image) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const canvas = createElementNS("canvas");
        canvas.width = image.width;
        canvas.height = image.height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, image.width, image.height);
        const imageData = context.getImageData(0, 0, image.width, image.height);
        const data = imageData.data;
        for (let i2 = 0; i2 < data.length; i2++) {
          data[i2] = SRGBToLinear(data[i2] / 255) * 255;
        }
        context.putImageData(imageData, 0, 0);
        return canvas;
      } else if (image.data) {
        const data = image.data.slice(0);
        for (let i2 = 0; i2 < data.length; i2++) {
          if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
            data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);
          } else {
            data[i2] = SRGBToLinear(data[i2]);
          }
        }
        return {
          data,
          width: image.width,
          height: image.height
        };
      } else {
        console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
        return image;
      }
    }
  }
  let _sourceId = 0;
  class Source {
    constructor(data = null) {
      this.isSource = true;
      Object.defineProperty(this, "id", { value: _sourceId++ });
      this.uuid = generateUUID();
      this.data = data;
      this.dataReady = true;
      this.version = 0;
    }
    set needsUpdate(value) {
      if (value === true) this.version++;
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (!isRootObject && meta.images[this.uuid] !== void 0) {
        return meta.images[this.uuid];
      }
      const output = {
        uuid: this.uuid,
        url: ""
      };
      const data = this.data;
      if (data !== null) {
        let url;
        if (Array.isArray(data)) {
          url = [];
          for (let i2 = 0, l = data.length; i2 < l; i2++) {
            if (data[i2].isDataTexture) {
              url.push(serializeImage(data[i2].image));
            } else {
              url.push(serializeImage(data[i2]));
            }
          }
        } else {
          url = serializeImage(data);
        }
        output.url = url;
      }
      if (!isRootObject) {
        meta.images[this.uuid] = output;
      }
      return output;
    }
  }
  function serializeImage(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return ImageUtils.getDataURL(image);
    } else {
      if (image.data) {
        return {
          data: Array.from(image.data),
          width: image.width,
          height: image.height,
          type: image.data.constructor.name
        };
      } else {
        console.warn("THREE.Texture: Unable to serialize Texture.");
        return {};
      }
    }
  }
  let _textureId = 0;
  class Texture extends EventDispatcher {
    constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
      super();
      this.isTexture = true;
      Object.defineProperty(this, "id", { value: _textureId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.source = new Source(image);
      this.mipmaps = [];
      this.mapping = mapping;
      this.channel = 0;
      this.wrapS = wrapS;
      this.wrapT = wrapT;
      this.magFilter = magFilter;
      this.minFilter = minFilter;
      this.anisotropy = anisotropy;
      this.format = format;
      this.internalFormat = null;
      this.type = type;
      this.offset = new Vector2(0, 0);
      this.repeat = new Vector2(1, 1);
      this.center = new Vector2(0, 0);
      this.rotation = 0;
      this.matrixAutoUpdate = true;
      this.matrix = new Matrix3();
      this.generateMipmaps = true;
      this.premultiplyAlpha = false;
      this.flipY = true;
      this.unpackAlignment = 4;
      this.colorSpace = colorSpace;
      this.userData = {};
      this.version = 0;
      this.onUpdate = null;
      this.renderTarget = null;
      this.isRenderTargetTexture = false;
      this.pmremVersion = 0;
    }
    get image() {
      return this.source.data;
    }
    set image(value = null) {
      this.source.data = value;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.name = source.name;
      this.source = source.source;
      this.mipmaps = source.mipmaps.slice(0);
      this.mapping = source.mapping;
      this.channel = source.channel;
      this.wrapS = source.wrapS;
      this.wrapT = source.wrapT;
      this.magFilter = source.magFilter;
      this.minFilter = source.minFilter;
      this.anisotropy = source.anisotropy;
      this.format = source.format;
      this.internalFormat = source.internalFormat;
      this.type = source.type;
      this.offset.copy(source.offset);
      this.repeat.copy(source.repeat);
      this.center.copy(source.center);
      this.rotation = source.rotation;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrix.copy(source.matrix);
      this.generateMipmaps = source.generateMipmaps;
      this.premultiplyAlpha = source.premultiplyAlpha;
      this.flipY = source.flipY;
      this.unpackAlignment = source.unpackAlignment;
      this.colorSpace = source.colorSpace;
      this.renderTarget = source.renderTarget;
      this.isRenderTargetTexture = source.isRenderTargetTexture;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      this.needsUpdate = true;
      return this;
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (!isRootObject && meta.textures[this.uuid] !== void 0) {
        return meta.textures[this.uuid];
      }
      const output = {
        metadata: {
          version: 4.6,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(meta).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      if (Object.keys(this.userData).length > 0) output.userData = this.userData;
      if (!isRootObject) {
        meta.textures[this.uuid] = output;
      }
      return output;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(uv) {
      if (this.mapping !== UVMapping) return uv;
      uv.applyMatrix3(this.matrix);
      if (uv.x < 0 || uv.x > 1) {
        switch (this.wrapS) {
          case RepeatWrapping:
            uv.x = uv.x - Math.floor(uv.x);
            break;
          case ClampToEdgeWrapping:
            uv.x = uv.x < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.x) % 2) === 1) {
              uv.x = Math.ceil(uv.x) - uv.x;
            } else {
              uv.x = uv.x - Math.floor(uv.x);
            }
            break;
        }
      }
      if (uv.y < 0 || uv.y > 1) {
        switch (this.wrapT) {
          case RepeatWrapping:
            uv.y = uv.y - Math.floor(uv.y);
            break;
          case ClampToEdgeWrapping:
            uv.y = uv.y < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.y) % 2) === 1) {
              uv.y = Math.ceil(uv.y) - uv.y;
            } else {
              uv.y = uv.y - Math.floor(uv.y);
            }
            break;
        }
      }
      if (this.flipY) {
        uv.y = 1 - uv.y;
      }
      return uv;
    }
    set needsUpdate(value) {
      if (value === true) {
        this.version++;
        this.source.needsUpdate = true;
      }
    }
    set needsPMREMUpdate(value) {
      if (value === true) {
        this.pmremVersion++;
      }
    }
  }
  Texture.DEFAULT_IMAGE = null;
  Texture.DEFAULT_MAPPING = UVMapping;
  Texture.DEFAULT_ANISOTROPY = 1;
  class Vector4 {
    constructor(x2 = 0, y = 0, z = 0, w = 1) {
      Vector4.prototype.isVector4 = true;
      this.x = x2;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    get width() {
      return this.z;
    }
    set width(value) {
      this.z = value;
    }
    get height() {
      return this.w;
    }
    set height(value) {
      this.w = value;
    }
    set(x2, y, z, w) {
      this.x = x2;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      this.w = scalar;
      return this;
    }
    setX(x2) {
      this.x = x2;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setZ(z) {
      this.z = z;
      return this;
    }
    setW(w) {
      this.w = w;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        case 3:
          this.w = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      this.w = v.w !== void 0 ? v.w : 1;
      return this;
    }
    add(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      this.w += v.w;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      this.w += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      this.w = a.w + b.w;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      this.w += v.w * s;
      return this;
    }
    sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      this.w -= v.w;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      this.w -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      this.w = a.w - b.w;
      return this;
    }
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      this.w *= v.w;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;
      return this;
    }
    applyMatrix4(m) {
      const x2 = this.x, y = this.y, z = this.z, w = this.w;
      const e = m.elements;
      this.x = e[0] * x2 + e[4] * y + e[8] * z + e[12] * w;
      this.y = e[1] * x2 + e[5] * y + e[9] * z + e[13] * w;
      this.z = e[2] * x2 + e[6] * y + e[10] * z + e[14] * w;
      this.w = e[3] * x2 + e[7] * y + e[11] * z + e[15] * w;
      return this;
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      this.w /= v.w;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    setAxisAngleFromQuaternion(q) {
      this.w = 2 * Math.acos(q.w);
      const s = Math.sqrt(1 - q.w * q.w);
      if (s < 1e-4) {
        this.x = 1;
        this.y = 0;
        this.z = 0;
      } else {
        this.x = q.x / s;
        this.y = q.y / s;
        this.z = q.z / s;
      }
      return this;
    }
    setAxisAngleFromRotationMatrix(m) {
      let angle, x2, y, z;
      const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
          this.set(1, 0, 0, 0);
          return this;
        }
        angle = Math.PI;
        const xx = (m11 + 1) / 2;
        const yy = (m22 + 1) / 2;
        const zz = (m33 + 1) / 2;
        const xy = (m12 + m21) / 4;
        const xz = (m13 + m31) / 4;
        const yz = (m23 + m32) / 4;
        if (xx > yy && xx > zz) {
          if (xx < epsilon) {
            x2 = 0;
            y = 0.707106781;
            z = 0.707106781;
          } else {
            x2 = Math.sqrt(xx);
            y = xy / x2;
            z = xz / x2;
          }
        } else if (yy > zz) {
          if (yy < epsilon) {
            x2 = 0.707106781;
            y = 0;
            z = 0.707106781;
          } else {
            y = Math.sqrt(yy);
            x2 = xy / y;
            z = yz / y;
          }
        } else {
          if (zz < epsilon) {
            x2 = 0.707106781;
            y = 0.707106781;
            z = 0;
          } else {
            z = Math.sqrt(zz);
            x2 = xz / z;
            y = yz / z;
          }
        }
        this.set(x2, y, z, angle);
        return this;
      }
      let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
      if (Math.abs(s) < 1e-3) s = 1;
      this.x = (m32 - m23) / s;
      this.y = (m13 - m31) / s;
      this.z = (m21 - m12) / s;
      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
      return this;
    }
    setFromMatrixPosition(m) {
      const e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      this.w = e[15];
      return this;
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      this.w = Math.min(this.w, v.w);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      this.w = Math.max(this.w, v.w);
      return this;
    }
    clamp(min, max2) {
      this.x = clamp(this.x, min.x, max2.x);
      this.y = clamp(this.y, min.y, max2.y);
      this.z = clamp(this.z, min.z, max2.z);
      this.w = clamp(this.w, min.w, max2.w);
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = clamp(this.x, minVal, maxVal);
      this.y = clamp(this.y, minVal, maxVal);
      this.z = clamp(this.z, minVal, maxVal);
      this.w = clamp(this.w, minVal, maxVal);
      return this;
    }
    clampLength(min, max2) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    }
    roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      this.z = Math.trunc(this.z);
      this.w = Math.trunc(this.w);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      this.w += (v.w - this.w) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      this.w = v1.w + (v2.w - v1.w) * alpha;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      array[offset + 3] = this.w;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      this.w = attribute.getW(index);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      this.w = Math.random();
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
      yield this.z;
      yield this.w;
    }
  }
  class RenderTarget extends EventDispatcher {
    constructor(width = 1, height = 1, options = {}) {
      super();
      this.isRenderTarget = true;
      this.width = width;
      this.height = height;
      this.depth = 1;
      this.scissor = new Vector4(0, 0, width, height);
      this.scissorTest = false;
      this.viewport = new Vector4(0, 0, width, height);
      const image = { width, height, depth: 1 };
      options = Object.assign({
        generateMipmaps: false,
        internalFormat: null,
        minFilter: LinearFilter,
        depthBuffer: true,
        stencilBuffer: false,
        resolveDepthBuffer: true,
        resolveStencilBuffer: true,
        depthTexture: null,
        samples: 0,
        count: 1
      }, options);
      const texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
      texture.flipY = false;
      texture.generateMipmaps = options.generateMipmaps;
      texture.internalFormat = options.internalFormat;
      this.textures = [];
      const count = options.count;
      for (let i2 = 0; i2 < count; i2++) {
        this.textures[i2] = texture.clone();
        this.textures[i2].isRenderTargetTexture = true;
        this.textures[i2].renderTarget = this;
      }
      this.depthBuffer = options.depthBuffer;
      this.stencilBuffer = options.stencilBuffer;
      this.resolveDepthBuffer = options.resolveDepthBuffer;
      this.resolveStencilBuffer = options.resolveStencilBuffer;
      this._depthTexture = null;
      this.depthTexture = options.depthTexture;
      this.samples = options.samples;
    }
    get texture() {
      return this.textures[0];
    }
    set texture(value) {
      this.textures[0] = value;
    }
    set depthTexture(current) {
      if (this._depthTexture !== null) this._depthTexture.renderTarget = null;
      if (current !== null) current.renderTarget = this;
      this._depthTexture = current;
    }
    get depthTexture() {
      return this._depthTexture;
    }
    setSize(width, height, depth = 1) {
      if (this.width !== width || this.height !== height || this.depth !== depth) {
        this.width = width;
        this.height = height;
        this.depth = depth;
        for (let i2 = 0, il = this.textures.length; i2 < il; i2++) {
          this.textures[i2].image.width = width;
          this.textures[i2].image.height = height;
          this.textures[i2].image.depth = depth;
        }
        this.dispose();
      }
      this.viewport.set(0, 0, width, height);
      this.scissor.set(0, 0, width, height);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.width = source.width;
      this.height = source.height;
      this.depth = source.depth;
      this.scissor.copy(source.scissor);
      this.scissorTest = source.scissorTest;
      this.viewport.copy(source.viewport);
      this.textures.length = 0;
      for (let i2 = 0, il = source.textures.length; i2 < il; i2++) {
        this.textures[i2] = source.textures[i2].clone();
        this.textures[i2].isRenderTargetTexture = true;
        this.textures[i2].renderTarget = this;
      }
      const image = Object.assign({}, source.texture.image);
      this.texture.source = new Source(image);
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      this.resolveDepthBuffer = source.resolveDepthBuffer;
      this.resolveStencilBuffer = source.resolveStencilBuffer;
      if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
      this.samples = source.samples;
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  class WebGLRenderTarget extends RenderTarget {
    constructor(width = 1, height = 1, options = {}) {
      super(width, height, options);
      this.isWebGLRenderTarget = true;
    }
  }
  class DataArrayTexture extends Texture {
    constructor(data = null, width = 1, height = 1, depth = 1) {
      super(null);
      this.isDataArrayTexture = true;
      this.image = { data, width, height, depth };
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.wrapR = ClampToEdgeWrapping;
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
      this.layerUpdates = /* @__PURE__ */ new Set();
    }
    addLayerUpdate(layerIndex) {
      this.layerUpdates.add(layerIndex);
    }
    clearLayerUpdates() {
      this.layerUpdates.clear();
    }
  }
  class WebGLArrayRenderTarget extends WebGLRenderTarget {
    constructor(width = 1, height = 1, depth = 1, options = {}) {
      super(width, height, options);
      this.isWebGLArrayRenderTarget = true;
      this.depth = depth;
      this.texture = new DataArrayTexture(null, width, height, depth);
      this.texture.isRenderTargetTexture = true;
    }
  }
  class Quaternion {
    constructor(x2 = 0, y = 0, z = 0, w = 1) {
      this.isQuaternion = true;
      this._x = x2;
      this._y = y;
      this._z = z;
      this._w = w;
    }
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
      if (t === 0) {
        dst[dstOffset + 0] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
        return;
      }
      if (t === 1) {
        dst[dstOffset + 0] = x1;
        dst[dstOffset + 1] = y1;
        dst[dstOffset + 2] = z1;
        dst[dstOffset + 3] = w1;
        return;
      }
      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
        let s = 1 - t;
        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
        if (sqrSin > Number.EPSILON) {
          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
          s = Math.sin(s * len) / sin;
          t = Math.sin(t * len) / sin;
        }
        const tDir = t * dir;
        x0 = x0 * s + x1 * tDir;
        y0 = y0 * s + y1 * tDir;
        z0 = z0 * s + z1 * tDir;
        w0 = w0 * s + w1 * tDir;
        if (s === 1 - t) {
          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
          x0 *= f;
          y0 *= f;
          z0 *= f;
          w0 *= f;
        }
      }
      dst[dstOffset] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
    }
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
      const x0 = src0[srcOffset0];
      const y0 = src0[srcOffset0 + 1];
      const z0 = src0[srcOffset0 + 2];
      const w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1];
      const y1 = src1[srcOffset1 + 1];
      const z1 = src1[srcOffset1 + 2];
      const w1 = src1[srcOffset1 + 3];
      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
      return dst;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(value) {
      this._w = value;
      this._onChangeCallback();
    }
    set(x2, y, z, w) {
      this._x = x2;
      this._y = y;
      this._z = z;
      this._w = w;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;
      this._onChangeCallback();
      return this;
    }
    setFromEuler(euler, update = true) {
      const x2 = euler._x, y = euler._y, z = euler._z, order = euler._order;
      const cos = Math.cos;
      const sin = Math.sin;
      const c1 = cos(x2 / 2);
      const c2 = cos(y / 2);
      const c3 = cos(z / 2);
      const s1 = sin(x2 / 2);
      const s2 = sin(y / 2);
      const s3 = sin(z / 2);
      switch (order) {
        case "XYZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "YXZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "ZXY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "ZYX":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "YZX":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "XZY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
      }
      if (update === true) this._onChangeCallback();
      return this;
    }
    setFromAxisAngle(axis, angle) {
      const halfAngle = angle / 2, s = Math.sin(halfAngle);
      this._x = axis.x * s;
      this._y = axis.y * s;
      this._z = axis.z * s;
      this._w = Math.cos(halfAngle);
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m) {
      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
      if (trace > 0) {
        const s = 0.5 / Math.sqrt(trace + 1);
        this._w = 0.25 / s;
        this._x = (m32 - m23) * s;
        this._y = (m13 - m31) * s;
        this._z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
        this._w = (m32 - m23) / s;
        this._x = 0.25 * s;
        this._y = (m12 + m21) / s;
        this._z = (m13 + m31) / s;
      } else if (m22 > m33) {
        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
        this._w = (m13 - m31) / s;
        this._x = (m12 + m21) / s;
        this._y = 0.25 * s;
        this._z = (m23 + m32) / s;
      } else {
        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
        this._w = (m21 - m12) / s;
        this._x = (m13 + m31) / s;
        this._y = (m23 + m32) / s;
        this._z = 0.25 * s;
      }
      this._onChangeCallback();
      return this;
    }
    setFromUnitVectors(vFrom, vTo) {
      let r = vFrom.dot(vTo) + 1;
      if (r < Number.EPSILON) {
        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          this._x = -vFrom.y;
          this._y = vFrom.x;
          this._z = 0;
          this._w = r;
        } else {
          this._x = 0;
          this._y = -vFrom.z;
          this._z = vFrom.y;
          this._w = r;
        }
      } else {
        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
        this._w = r;
      }
      return this.normalize();
    }
    angleTo(q) {
      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
    }
    rotateTowards(q, step) {
      const angle = this.angleTo(q);
      if (angle === 0) return this;
      const t = Math.min(1, step / angle);
      this.slerp(q, t);
      return this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this._onChangeCallback();
      return this;
    }
    dot(v) {
      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let l = this.length();
      if (l === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l = 1 / l;
        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;
      }
      this._onChangeCallback();
      return this;
    }
    multiply(q) {
      return this.multiplyQuaternions(this, q);
    }
    premultiply(q) {
      return this.multiplyQuaternions(q, this);
    }
    multiplyQuaternions(a, b) {
      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
      this._onChangeCallback();
      return this;
    }
    slerp(qb, t) {
      if (t === 0) return this;
      if (t === 1) return this.copy(qb);
      const x2 = this._x, y = this._y, z = this._z, w = this._w;
      let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * qb._z;
      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }
      if (cosHalfTheta >= 1) {
        this._w = w;
        this._x = x2;
        this._y = y;
        this._z = z;
        return this;
      }
      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
      if (sqrSinHalfTheta <= Number.EPSILON) {
        const s = 1 - t;
        this._w = s * w + t * this._w;
        this._x = s * x2 + t * this._x;
        this._y = s * y + t * this._y;
        this._z = s * z + t * this._z;
        this.normalize();
        return this;
      }
      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      this._w = w * ratioA + this._w * ratioB;
      this._x = x2 * ratioA + this._x * ratioB;
      this._y = y * ratioA + this._y * ratioB;
      this._z = z * ratioA + this._z * ratioB;
      this._onChangeCallback();
      return this;
    }
    slerpQuaternions(qa, qb, t) {
      return this.copy(qa).slerp(qb, t);
    }
    random() {
      const theta1 = 2 * Math.PI * Math.random();
      const theta2 = 2 * Math.PI * Math.random();
      const x0 = Math.random();
      const r1 = Math.sqrt(1 - x0);
      const r2 = Math.sqrt(x0);
      return this.set(
        r1 * Math.sin(theta1),
        r1 * Math.cos(theta1),
        r2 * Math.sin(theta2),
        r2 * Math.cos(theta2)
      );
    }
    equals(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset = 0) {
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this._x = attribute.getX(index);
      this._y = attribute.getY(index);
      this._z = attribute.getZ(index);
      this._w = attribute.getW(index);
      this._onChangeCallback();
      return this;
    }
    toJSON() {
      return this.toArray();
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x;
      yield this._y;
      yield this._z;
      yield this._w;
    }
  }
  class Vector3 {
    constructor(x2 = 0, y = 0, z = 0) {
      Vector3.prototype.isVector3 = true;
      this.x = x2;
      this.y = y;
      this.z = z;
    }
    set(x2, y, z) {
      if (z === void 0) z = this.z;
      this.x = x2;
      this.y = y;
      this.z = z;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    }
    setX(x2) {
      this.x = x2;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setZ(z) {
      this.z = z;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    }
    add(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      return this;
    }
    sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    }
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    }
    multiplyVectors(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    }
    applyEuler(euler) {
      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m) {
      const x2 = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x2 + e[3] * y + e[6] * z;
      this.y = e[1] * x2 + e[4] * y + e[7] * z;
      this.z = e[2] * x2 + e[5] * y + e[8] * z;
      return this;
    }
    applyNormalMatrix(m) {
      return this.applyMatrix3(m).normalize();
    }
    applyMatrix4(m) {
      const x2 = this.x, y = this.y, z = this.z;
      const e = m.elements;
      const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    }
    applyQuaternion(q) {
      const vx = this.x, vy = this.y, vz = this.z;
      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
      const tx = 2 * (qy * vz - qz * vy);
      const ty = 2 * (qz * vx - qx * vz);
      const tz = 2 * (qx * vy - qy * vx);
      this.x = vx + qw * tx + qy * tz - qz * ty;
      this.y = vy + qw * ty + qz * tx - qx * tz;
      this.z = vz + qw * tz + qx * ty - qy * tx;
      return this;
    }
    project(camera) {
      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
    unproject(camera) {
      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
    transformDirection(m) {
      const x2 = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x2 + e[4] * y + e[8] * z;
      this.y = e[1] * x2 + e[5] * y + e[9] * z;
      this.z = e[2] * x2 + e[6] * y + e[10] * z;
      return this.normalize();
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    }
    clamp(min, max2) {
      this.x = clamp(this.x, min.x, max2.x);
      this.y = clamp(this.y, min.y, max2.y);
      this.z = clamp(this.z, min.z, max2.z);
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = clamp(this.x, minVal, maxVal);
      this.y = clamp(this.y, minVal, maxVal);
      this.z = clamp(this.z, minVal, maxVal);
      return this;
    }
    clampLength(min, max2) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    }
    roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      this.z = Math.trunc(this.z);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    // TODO lengthSquared?
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      return this;
    }
    cross(v) {
      return this.crossVectors(this, v);
    }
    crossVectors(a, b) {
      const ax = a.x, ay = a.y, az = a.z;
      const bx = b.x, by = b.y, bz = b.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    }
    projectOnVector(v) {
      const denominator = v.lengthSq();
      if (denominator === 0) return this.set(0, 0, 0);
      const scalar = v.dot(this) / denominator;
      return this.copy(v).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
      _vector$c.copy(this).projectOnVector(planeNormal);
      return this.sub(_vector$c);
    }
    reflect(normal) {
      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    angleTo(v) {
      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0) return Math.PI / 2;
      const theta = this.dot(v) / denominator;
      return Math.acos(clamp(theta, -1, 1));
    }
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    setFromSpherical(s) {
      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
      const sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    }
    setFromCylindrical(c) {
      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
    setFromCylindricalCoords(radius, theta, y) {
      this.x = radius * Math.sin(theta);
      this.y = y;
      this.z = radius * Math.cos(theta);
      return this;
    }
    setFromMatrixPosition(m) {
      const e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      return this;
    }
    setFromMatrixScale(m) {
      const sx = this.setFromMatrixColumn(m, 0).length();
      const sy = this.setFromMatrixColumn(m, 1).length();
      const sz = this.setFromMatrixColumn(m, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    }
    setFromMatrixColumn(m, index) {
      return this.fromArray(m.elements, index * 4);
    }
    setFromMatrix3Column(m, index) {
      return this.fromArray(m.elements, index * 3);
    }
    setFromEuler(e) {
      this.x = e._x;
      this.y = e._y;
      this.z = e._z;
      return this;
    }
    setFromColor(c) {
      this.x = c.r;
      this.y = c.g;
      this.z = c.b;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      return this;
    }
    randomDirection() {
      const theta = Math.random() * Math.PI * 2;
      const u = Math.random() * 2 - 1;
      const c = Math.sqrt(1 - u * u);
      this.x = c * Math.cos(theta);
      this.y = u;
      this.z = c * Math.sin(theta);
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
      yield this.z;
    }
  }
  const _vector$c = /* @__PURE__ */ new Vector3();
  const _quaternion$4 = /* @__PURE__ */ new Quaternion();
  class Box3 {
    constructor(min = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {
      this.isBox3 = true;
      this.min = min;
      this.max = max2;
    }
    set(min, max2) {
      this.min.copy(min);
      this.max.copy(max2);
      return this;
    }
    setFromArray(array) {
      this.makeEmpty();
      for (let i2 = 0, il = array.length; i2 < il; i2 += 3) {
        this.expandByPoint(_vector$b.fromArray(array, i2));
      }
      return this;
    }
    setFromBufferAttribute(attribute) {
      this.makeEmpty();
      for (let i2 = 0, il = attribute.count; i2 < il; i2++) {
        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i2));
      }
      return this;
    }
    setFromPoints(points) {
      this.makeEmpty();
      for (let i2 = 0, il = points.length; i2 < il; i2++) {
        this.expandByPoint(points[i2]);
      }
      return this;
    }
    setFromCenterAndSize(center, size) {
      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    setFromObject(object, precise = false) {
      this.makeEmpty();
      return this.expandByObject(object, precise);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    makeEmpty() {
      this.min.x = this.min.y = this.min.z = Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    expandByObject(object, precise = false) {
      object.updateWorldMatrix(false, false);
      const geometry = object.geometry;
      if (geometry !== void 0) {
        const positionAttribute = geometry.getAttribute("position");
        if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
          for (let i2 = 0, l = positionAttribute.count; i2 < l; i2++) {
            if (object.isMesh === true) {
              object.getVertexPosition(i2, _vector$b);
            } else {
              _vector$b.fromBufferAttribute(positionAttribute, i2);
            }
            _vector$b.applyMatrix4(object.matrixWorld);
            this.expandByPoint(_vector$b);
          }
        } else {
          if (object.boundingBox !== void 0) {
            if (object.boundingBox === null) {
              object.computeBoundingBox();
            }
            _box$4.copy(object.boundingBox);
          } else {
            if (geometry.boundingBox === null) {
              geometry.computeBoundingBox();
            }
            _box$4.copy(geometry.boundingBox);
          }
          _box$4.applyMatrix4(object.matrixWorld);
          this.union(_box$4);
        }
      }
      const children = object.children;
      for (let i2 = 0, l = children.length; i2 < l; i2++) {
        this.expandByObject(children[i2], precise);
      }
      return this;
    }
    containsPoint(point) {
      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
    }
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    getParameter(point, target) {
      return target.set(
        (point.x - this.min.x) / (this.max.x - this.min.x),
        (point.y - this.min.y) / (this.max.y - this.min.y),
        (point.z - this.min.z) / (this.max.z - this.min.z)
      );
    }
    intersectsBox(box) {
      return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
    }
    intersectsSphere(sphere) {
      this.clampPoint(sphere.center, _vector$b);
      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    intersectsPlane(plane) {
      let min, max2;
      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max2 = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max2 = plane.normal.x * this.min.x;
      }
      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max2 += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max2 += plane.normal.y * this.min.y;
      }
      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max2 += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max2 += plane.normal.z * this.min.z;
      }
      return min <= -plane.constant && max2 >= -plane.constant;
    }
    intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      }
      this.getCenter(_center);
      _extents.subVectors(this.max, _center);
      _v0$2.subVectors(triangle.a, _center);
      _v1$7.subVectors(triangle.b, _center);
      _v2$4.subVectors(triangle.c, _center);
      _f0.subVectors(_v1$7, _v0$2);
      _f1.subVectors(_v2$4, _v1$7);
      _f2.subVectors(_v0$2, _v2$4);
      let axes = [
        0,
        -_f0.z,
        _f0.y,
        0,
        -_f1.z,
        _f1.y,
        0,
        -_f2.z,
        _f2.y,
        _f0.z,
        0,
        -_f0.x,
        _f1.z,
        0,
        -_f1.x,
        _f2.z,
        0,
        -_f2.x,
        -_f0.y,
        _f0.x,
        0,
        -_f1.y,
        _f1.x,
        0,
        -_f2.y,
        _f2.x,
        0
      ];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
        return false;
      }
      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
        return false;
      }
      _triangleNormal.crossVectors(_f0, _f1);
      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
      return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
    }
    clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
      return this.clampPoint(point, _vector$b).distanceTo(point);
    }
    getBoundingSphere(target) {
      if (this.isEmpty()) {
        target.makeEmpty();
      } else {
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$b).length() * 0.5;
      }
      return target;
    }
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      if (this.isEmpty()) this.makeEmpty();
      return this;
    }
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    applyMatrix4(matrix) {
      if (this.isEmpty()) return this;
      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
      this.setFromPoints(_points);
      return this;
    }
    translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  }
  const _points = [
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3()
  ];
  const _vector$b = /* @__PURE__ */ new Vector3();
  const _box$4 = /* @__PURE__ */ new Box3();
  const _v0$2 = /* @__PURE__ */ new Vector3();
  const _v1$7 = /* @__PURE__ */ new Vector3();
  const _v2$4 = /* @__PURE__ */ new Vector3();
  const _f0 = /* @__PURE__ */ new Vector3();
  const _f1 = /* @__PURE__ */ new Vector3();
  const _f2 = /* @__PURE__ */ new Vector3();
  const _center = /* @__PURE__ */ new Vector3();
  const _extents = /* @__PURE__ */ new Vector3();
  const _triangleNormal = /* @__PURE__ */ new Vector3();
  const _testAxis = /* @__PURE__ */ new Vector3();
  function satForAxes(axes, v0, v1, v2, extents) {
    for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {
      _testAxis.fromArray(axes, i2);
      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
      const p0 = v0.dot(_testAxis);
      const p1 = v1.dot(_testAxis);
      const p2 = v2.dot(_testAxis);
      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
        return false;
      }
    }
    return true;
  }
  const _box$3 = /* @__PURE__ */ new Box3();
  const _v1$6 = /* @__PURE__ */ new Vector3();
  const _v2$3 = /* @__PURE__ */ new Vector3();
  class Sphere {
    constructor(center = new Vector3(), radius = -1) {
      this.isSphere = true;
      this.center = center;
      this.radius = radius;
    }
    set(center, radius) {
      this.center.copy(center);
      this.radius = radius;
      return this;
    }
    setFromPoints(points, optionalCenter) {
      const center = this.center;
      if (optionalCenter !== void 0) {
        center.copy(optionalCenter);
      } else {
        _box$3.setFromPoints(points).getCenter(center);
      }
      let maxRadiusSq = 0;
      for (let i2 = 0, il = points.length; i2 < il; i2++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    }
    copy(sphere) {
      this.center.copy(sphere.center);
      this.radius = sphere.radius;
      return this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      this.center.set(0, 0, 0);
      this.radius = -1;
      return this;
    }
    containsPoint(point) {
      return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(point) {
      return point.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(sphere) {
      const radiusSum = this.radius + sphere.radius;
      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
    intersectsBox(box) {
      return box.intersectsSphere(this);
    }
    intersectsPlane(plane) {
      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(point, target) {
      const deltaLengthSq = this.center.distanceToSquared(point);
      target.copy(point);
      if (deltaLengthSq > this.radius * this.radius) {
        target.sub(this.center).normalize();
        target.multiplyScalar(this.radius).add(this.center);
      }
      return target;
    }
    getBoundingBox(target) {
      if (this.isEmpty()) {
        target.makeEmpty();
        return target;
      }
      target.set(this.center, this.center);
      target.expandByScalar(this.radius);
      return target;
    }
    applyMatrix4(matrix) {
      this.center.applyMatrix4(matrix);
      this.radius = this.radius * matrix.getMaxScaleOnAxis();
      return this;
    }
    translate(offset) {
      this.center.add(offset);
      return this;
    }
    expandByPoint(point) {
      if (this.isEmpty()) {
        this.center.copy(point);
        this.radius = 0;
        return this;
      }
      _v1$6.subVectors(point, this.center);
      const lengthSq = _v1$6.lengthSq();
      if (lengthSq > this.radius * this.radius) {
        const length = Math.sqrt(lengthSq);
        const delta = (length - this.radius) * 0.5;
        this.center.addScaledVector(_v1$6, delta / length);
        this.radius += delta;
      }
      return this;
    }
    union(sphere) {
      if (sphere.isEmpty()) {
        return this;
      }
      if (this.isEmpty()) {
        this.copy(sphere);
        return this;
      }
      if (this.center.equals(sphere.center) === true) {
        this.radius = Math.max(this.radius, sphere.radius);
      } else {
        _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
        this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
        this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
      }
      return this;
    }
    equals(sphere) {
      return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const _vector$a = /* @__PURE__ */ new Vector3();
  const _segCenter = /* @__PURE__ */ new Vector3();
  const _segDir = /* @__PURE__ */ new Vector3();
  const _diff = /* @__PURE__ */ new Vector3();
  const _edge1 = /* @__PURE__ */ new Vector3();
  const _edge2 = /* @__PURE__ */ new Vector3();
  const _normal$1 = /* @__PURE__ */ new Vector3();
  class Ray {
    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
      this.origin = origin;
      this.direction = direction;
    }
    set(origin, direction) {
      this.origin.copy(origin);
      this.direction.copy(direction);
      return this;
    }
    copy(ray) {
      this.origin.copy(ray.origin);
      this.direction.copy(ray.direction);
      return this;
    }
    at(t, target) {
      return target.copy(this.origin).addScaledVector(this.direction, t);
    }
    lookAt(v) {
      this.direction.copy(v).sub(this.origin).normalize();
      return this;
    }
    recast(t) {
      this.origin.copy(this.at(t, _vector$a));
      return this;
    }
    closestPointToPoint(point, target) {
      target.subVectors(point, this.origin);
      const directionDistance = target.dot(this.direction);
      if (directionDistance < 0) {
        return target.copy(this.origin);
      }
      return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
    }
    distanceToPoint(point) {
      return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
      const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }
      _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
      return _vector$a.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      _segDir.copy(v1).sub(v0).normalize();
      _diff.copy(this.origin).sub(_segCenter);
      const segExtent = v0.distanceTo(v1) * 0.5;
      const a01 = -this.direction.dot(_segDir);
      const b0 = _diff.dot(this.direction);
      const b1 = -_diff.dot(_segDir);
      const c = _diff.lengthSq();
      const det = Math.abs(1 - a01 * a01);
      let s0, s1, sqrDist, extDet;
      if (det > 0) {
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              const invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          if (s1 <= -extDet) {
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }
      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
      }
      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
      }
      return sqrDist;
    }
    intersectSphere(sphere, target) {
      _vector$a.subVectors(sphere.center, this.origin);
      const tca = _vector$a.dot(this.direction);
      const d2 = _vector$a.dot(_vector$a) - tca * tca;
      const radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2) return null;
      const thc = Math.sqrt(radius2 - d2);
      const t0 = tca - thc;
      const t1 = tca + thc;
      if (t1 < 0) return null;
      if (t0 < 0) return this.at(t1, target);
      return this.at(t0, target);
    }
    intersectsSphere(sphere) {
      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
      const denominator = plane.normal.dot(this.direction);
      if (denominator === 0) {
        if (plane.distanceToPoint(this.origin) === 0) {
          return 0;
        }
        return null;
      }
      const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
      return t >= 0 ? t : null;
    }
    intersectPlane(plane, target) {
      const t = this.distanceToPlane(plane);
      if (t === null) {
        return null;
      }
      return this.at(t, target);
    }
    intersectsPlane(plane) {
      const distToPoint = plane.distanceToPoint(this.origin);
      if (distToPoint === 0) {
        return true;
      }
      const denominator = plane.normal.dot(this.direction);
      if (denominator * distToPoint < 0) {
        return true;
      }
      return false;
    }
    intersectBox(box, target) {
      let tmin, tmax, tymin, tymax, tzmin, tzmax;
      const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
      const origin = this.origin;
      if (invdirx >= 0) {
        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
      } else {
        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
      }
      if (invdiry >= 0) {
        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
      } else {
        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
      }
      if (tmin > tymax || tymin > tmax) return null;
      if (tymin > tmin || isNaN(tmin)) tmin = tymin;
      if (tymax < tmax || isNaN(tmax)) tmax = tymax;
      if (invdirz >= 0) {
        tzmin = (box.min.z - origin.z) * invdirz;
        tzmax = (box.max.z - origin.z) * invdirz;
      } else {
        tzmin = (box.max.z - origin.z) * invdirz;
        tzmax = (box.min.z - origin.z) * invdirz;
      }
      if (tmin > tzmax || tzmin > tmax) return null;
      if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
      if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
      if (tmax < 0) return null;
      return this.at(tmin >= 0 ? tmin : tmax, target);
    }
    intersectsBox(box) {
      return this.intersectBox(box, _vector$a) !== null;
    }
    intersectTriangle(a, b, c, backfaceCulling, target) {
      _edge1.subVectors(b, a);
      _edge2.subVectors(c, a);
      _normal$1.crossVectors(_edge1, _edge2);
      let DdN = this.direction.dot(_normal$1);
      let sign;
      if (DdN > 0) {
        if (backfaceCulling) return null;
        sign = 1;
      } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      _diff.subVectors(this.origin, a);
      const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
      if (DdQxE2 < 0) {
        return null;
      }
      const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
      if (DdE1xQ < 0) {
        return null;
      }
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      const QdN = -sign * _diff.dot(_normal$1);
      if (QdN < 0) {
        return null;
      }
      return this.at(QdN / DdN, target);
    }
    applyMatrix4(matrix4) {
      this.origin.applyMatrix4(matrix4);
      this.direction.transformDirection(matrix4);
      return this;
    }
    equals(ray) {
      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Matrix4 {
    constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      Matrix4.prototype.isMatrix4 = true;
      this.elements = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ];
      if (n11 !== void 0) {
        this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
      }
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      const te = this.elements;
      te[0] = n11;
      te[4] = n12;
      te[8] = n13;
      te[12] = n14;
      te[1] = n21;
      te[5] = n22;
      te[9] = n23;
      te[13] = n24;
      te[2] = n31;
      te[6] = n32;
      te[10] = n33;
      te[14] = n34;
      te[3] = n41;
      te[7] = n42;
      te[11] = n43;
      te[15] = n44;
      return this;
    }
    identity() {
      this.set(
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    clone() {
      return new Matrix4().fromArray(this.elements);
    }
    copy(m) {
      const te = this.elements;
      const me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      te[9] = me[9];
      te[10] = me[10];
      te[11] = me[11];
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      te[15] = me[15];
      return this;
    }
    copyPosition(m) {
      const te = this.elements, me = m.elements;
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      return this;
    }
    setFromMatrix3(m) {
      const me = m.elements;
      this.set(
        me[0],
        me[3],
        me[6],
        0,
        me[1],
        me[4],
        me[7],
        0,
        me[2],
        me[5],
        me[8],
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrixColumn(this, 0);
      yAxis.setFromMatrixColumn(this, 1);
      zAxis.setFromMatrixColumn(this, 2);
      return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
      this.set(
        xAxis.x,
        yAxis.x,
        zAxis.x,
        0,
        xAxis.y,
        yAxis.y,
        zAxis.y,
        0,
        xAxis.z,
        yAxis.z,
        zAxis.z,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    extractRotation(m) {
      const te = this.elements;
      const me = m.elements;
      const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
      const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
      const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[3] = 0;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[7] = 0;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
    makeRotationFromEuler(euler) {
      const te = this.elements;
      const x2 = euler.x, y = euler.y, z = euler.z;
      const a = Math.cos(x2), b = Math.sin(x2);
      const c = Math.cos(y), d = Math.sin(y);
      const e = Math.cos(z), f = Math.sin(z);
      if (euler.order === "XYZ") {
        const ae = a * e, af = a * f, be = b * e, bf = b * f;
        te[0] = c * e;
        te[4] = -c * f;
        te[8] = d;
        te[1] = af + be * d;
        te[5] = ae - bf * d;
        te[9] = -b * c;
        te[2] = bf - ae * d;
        te[6] = be + af * d;
        te[10] = a * c;
      } else if (euler.order === "YXZ") {
        const ce = c * e, cf = c * f, de = d * e, df = d * f;
        te[0] = ce + df * b;
        te[4] = de * b - cf;
        te[8] = a * d;
        te[1] = a * f;
        te[5] = a * e;
        te[9] = -b;
        te[2] = cf * b - de;
        te[6] = df + ce * b;
        te[10] = a * c;
      } else if (euler.order === "ZXY") {
        const ce = c * e, cf = c * f, de = d * e, df = d * f;
        te[0] = ce - df * b;
        te[4] = -a * f;
        te[8] = de + cf * b;
        te[1] = cf + de * b;
        te[5] = a * e;
        te[9] = df - ce * b;
        te[2] = -a * d;
        te[6] = b;
        te[10] = a * c;
      } else if (euler.order === "ZYX") {
        const ae = a * e, af = a * f, be = b * e, bf = b * f;
        te[0] = c * e;
        te[4] = be * d - af;
        te[8] = ae * d + bf;
        te[1] = c * f;
        te[5] = bf * d + ae;
        te[9] = af * d - be;
        te[2] = -d;
        te[6] = b * c;
        te[10] = a * c;
      } else if (euler.order === "YZX") {
        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
        te[0] = c * e;
        te[4] = bd - ac * f;
        te[8] = bc * f + ad;
        te[1] = f;
        te[5] = a * e;
        te[9] = -b * e;
        te[2] = -d * e;
        te[6] = ad * f + bc;
        te[10] = ac - bd * f;
      } else if (euler.order === "XZY") {
        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
        te[0] = c * e;
        te[4] = -f;
        te[8] = d * e;
        te[1] = ac * f + bd;
        te[5] = a * e;
        te[9] = ad * f - bc;
        te[2] = bc * f - ad;
        te[6] = b * e;
        te[10] = bd * f + ac;
      }
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
    makeRotationFromQuaternion(q) {
      return this.compose(_zero, q, _one);
    }
    lookAt(eye, target, up) {
      const te = this.elements;
      _z.subVectors(eye, target);
      if (_z.lengthSq() === 0) {
        _z.z = 1;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
      if (_x.lengthSq() === 0) {
        if (Math.abs(up.z) === 1) {
          _z.x += 1e-4;
        } else {
          _z.z += 1e-4;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
      }
      _x.normalize();
      _y.crossVectors(_z, _x);
      te[0] = _x.x;
      te[4] = _y.x;
      te[8] = _z.x;
      te[1] = _x.y;
      te[5] = _y.y;
      te[9] = _z.y;
      te[2] = _x.z;
      te[6] = _y.z;
      te[10] = _z.z;
      return this;
    }
    multiply(m) {
      return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
      const ae = a.elements;
      const be = b.elements;
      const te = this.elements;
      const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
      const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
      const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
      const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
      const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
      const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
      const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
      const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    }
    multiplyScalar(s) {
      const te = this.elements;
      te[0] *= s;
      te[4] *= s;
      te[8] *= s;
      te[12] *= s;
      te[1] *= s;
      te[5] *= s;
      te[9] *= s;
      te[13] *= s;
      te[2] *= s;
      te[6] *= s;
      te[10] *= s;
      te[14] *= s;
      te[3] *= s;
      te[7] *= s;
      te[11] *= s;
      te[15] *= s;
      return this;
    }
    determinant() {
      const te = this.elements;
      const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
      const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
      const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
      const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
      const te = this.elements;
      let tmp;
      tmp = te[1];
      te[1] = te[4];
      te[4] = tmp;
      tmp = te[2];
      te[2] = te[8];
      te[8] = tmp;
      tmp = te[6];
      te[6] = te[9];
      te[9] = tmp;
      tmp = te[3];
      te[3] = te[12];
      te[12] = tmp;
      tmp = te[7];
      te[7] = te[13];
      te[13] = tmp;
      tmp = te[11];
      te[11] = te[14];
      te[14] = tmp;
      return this;
    }
    setPosition(x2, y, z) {
      const te = this.elements;
      if (x2.isVector3) {
        te[12] = x2.x;
        te[13] = x2.y;
        te[14] = x2.z;
      } else {
        te[12] = x2;
        te[13] = y;
        te[14] = z;
      }
      return this;
    }
    invert() {
      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
      te[4] = t12 * detInv;
      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
      te[8] = t13 * detInv;
      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
      te[12] = t14 * detInv;
      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
      return this;
    }
    scale(v) {
      const te = this.elements;
      const x2 = v.x, y = v.y, z = v.z;
      te[0] *= x2;
      te[4] *= y;
      te[8] *= z;
      te[1] *= x2;
      te[5] *= y;
      te[9] *= z;
      te[2] *= x2;
      te[6] *= y;
      te[10] *= z;
      te[3] *= x2;
      te[7] *= y;
      te[11] *= z;
      return this;
    }
    getMaxScaleOnAxis() {
      const te = this.elements;
      const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
      const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
      const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x2, y, z) {
      if (x2.isVector3) {
        this.set(
          1,
          0,
          0,
          x2.x,
          0,
          1,
          0,
          x2.y,
          0,
          0,
          1,
          x2.z,
          0,
          0,
          0,
          1
        );
      } else {
        this.set(
          1,
          0,
          0,
          x2,
          0,
          1,
          0,
          y,
          0,
          0,
          1,
          z,
          0,
          0,
          0,
          1
        );
      }
      return this;
    }
    makeRotationX(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(
        1,
        0,
        0,
        0,
        0,
        c,
        -s,
        0,
        0,
        s,
        c,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeRotationY(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(
        c,
        0,
        s,
        0,
        0,
        1,
        0,
        0,
        -s,
        0,
        c,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeRotationZ(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(
        c,
        -s,
        0,
        0,
        s,
        c,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeRotationAxis(axis, angle) {
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      const t = 1 - c;
      const x2 = axis.x, y = axis.y, z = axis.z;
      const tx = t * x2, ty = t * y;
      this.set(
        tx * x2 + c,
        tx * y - s * z,
        tx * z + s * y,
        0,
        tx * y + s * z,
        ty * y + c,
        ty * z - s * x2,
        0,
        tx * z - s * y,
        ty * z + s * x2,
        t * z * z + c,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeScale(x2, y, z) {
      this.set(
        x2,
        0,
        0,
        0,
        0,
        y,
        0,
        0,
        0,
        0,
        z,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeShear(xy, xz, yx, yz, zx, zy) {
      this.set(
        1,
        yx,
        zx,
        0,
        xy,
        1,
        zy,
        0,
        xz,
        yz,
        1,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    compose(position, quaternion, scale) {
      const te = this.elements;
      const x2 = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
      const x22 = x2 + x2, y2 = y + y, z2 = z + z;
      const xx = x2 * x22, xy = x2 * y2, xz = x2 * z2;
      const yy = y * y2, yz = y * z2, zz = z * z2;
      const wx = w * x22, wy = w * y2, wz = w * z2;
      const sx = scale.x, sy = scale.y, sz = scale.z;
      te[0] = (1 - (yy + zz)) * sx;
      te[1] = (xy + wz) * sx;
      te[2] = (xz - wy) * sx;
      te[3] = 0;
      te[4] = (xy - wz) * sy;
      te[5] = (1 - (xx + zz)) * sy;
      te[6] = (yz + wx) * sy;
      te[7] = 0;
      te[8] = (xz + wy) * sz;
      te[9] = (yz - wx) * sz;
      te[10] = (1 - (xx + yy)) * sz;
      te[11] = 0;
      te[12] = position.x;
      te[13] = position.y;
      te[14] = position.z;
      te[15] = 1;
      return this;
    }
    decompose(position, quaternion, scale) {
      const te = this.elements;
      let sx = _v1$5.set(te[0], te[1], te[2]).length();
      const sy = _v1$5.set(te[4], te[5], te[6]).length();
      const sz = _v1$5.set(te[8], te[9], te[10]).length();
      const det = this.determinant();
      if (det < 0) sx = -sx;
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];
      _m1$2.copy(this);
      const invSX = 1 / sx;
      const invSY = 1 / sy;
      const invSZ = 1 / sz;
      _m1$2.elements[0] *= invSX;
      _m1$2.elements[1] *= invSX;
      _m1$2.elements[2] *= invSX;
      _m1$2.elements[4] *= invSY;
      _m1$2.elements[5] *= invSY;
      _m1$2.elements[6] *= invSY;
      _m1$2.elements[8] *= invSZ;
      _m1$2.elements[9] *= invSZ;
      _m1$2.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(_m1$2);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    }
    makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
      const te = this.elements;
      const x2 = 2 * near / (right - left);
      const y = 2 * near / (top - bottom);
      const a = (right + left) / (right - left);
      const b = (top + bottom) / (top - bottom);
      let c, d;
      if (coordinateSystem === WebGLCoordinateSystem) {
        c = -(far + near) / (far - near);
        d = -2 * far * near / (far - near);
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        c = -far / (far - near);
        d = -far * near / (far - near);
      } else {
        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
      }
      te[0] = x2;
      te[4] = 0;
      te[8] = a;
      te[12] = 0;
      te[1] = 0;
      te[5] = y;
      te[9] = b;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = c;
      te[14] = d;
      te[3] = 0;
      te[7] = 0;
      te[11] = -1;
      te[15] = 0;
      return this;
    }
    makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
      const te = this.elements;
      const w = 1 / (right - left);
      const h = 1 / (top - bottom);
      const p = 1 / (far - near);
      const x2 = (right + left) * w;
      const y = (top + bottom) * h;
      let z, zInv;
      if (coordinateSystem === WebGLCoordinateSystem) {
        z = (far + near) * p;
        zInv = -2 * p;
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        z = near * p;
        zInv = -1 * p;
      } else {
        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
      }
      te[0] = 2 * w;
      te[4] = 0;
      te[8] = 0;
      te[12] = -x2;
      te[1] = 0;
      te[5] = 2 * h;
      te[9] = 0;
      te[13] = -y;
      te[2] = 0;
      te[6] = 0;
      te[10] = zInv;
      te[14] = -z;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    }
    equals(matrix) {
      const te = this.elements;
      const me = matrix.elements;
      for (let i2 = 0; i2 < 16; i2++) {
        if (te[i2] !== me[i2]) return false;
      }
      return true;
    }
    fromArray(array, offset = 0) {
      for (let i2 = 0; i2 < 16; i2++) {
        this.elements[i2] = array[i2 + offset];
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      array[offset + 9] = te[9];
      array[offset + 10] = te[10];
      array[offset + 11] = te[11];
      array[offset + 12] = te[12];
      array[offset + 13] = te[13];
      array[offset + 14] = te[14];
      array[offset + 15] = te[15];
      return array;
    }
  }
  const _v1$5 = /* @__PURE__ */ new Vector3();
  const _m1$2 = /* @__PURE__ */ new Matrix4();
  const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
  const _one = /* @__PURE__ */ new Vector3(1, 1, 1);
  const _x = /* @__PURE__ */ new Vector3();
  const _y = /* @__PURE__ */ new Vector3();
  const _z = /* @__PURE__ */ new Vector3();
  const _matrix$2 = /* @__PURE__ */ new Matrix4();
  const _quaternion$3 = /* @__PURE__ */ new Quaternion();
  class Euler {
    constructor(x2 = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
      this.isEuler = true;
      this._x = x2;
      this._y = y;
      this._z = z;
      this._order = order;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(value) {
      this._order = value;
      this._onChangeCallback();
    }
    set(x2, y, z, order = this._order) {
      this._x = x2;
      this._y = y;
      this._z = z;
      this._order = order;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
      this._x = euler._x;
      this._y = euler._y;
      this._z = euler._z;
      this._order = euler._order;
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m, order = this._order, update = true) {
      const te = m.elements;
      const m11 = te[0], m12 = te[4], m13 = te[8];
      const m21 = te[1], m22 = te[5], m23 = te[9];
      const m31 = te[2], m32 = te[6], m33 = te[10];
      switch (order) {
        case "XYZ":
          this._y = Math.asin(clamp(m13, -1, 1));
          if (Math.abs(m13) < 0.9999999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
          break;
        case "YXZ":
          this._x = Math.asin(-clamp(m23, -1, 1));
          if (Math.abs(m23) < 0.9999999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
          break;
        case "ZXY":
          this._x = Math.asin(clamp(m32, -1, 1));
          if (Math.abs(m32) < 0.9999999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
          break;
        case "ZYX":
          this._y = Math.asin(-clamp(m31, -1, 1));
          if (Math.abs(m31) < 0.9999999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
          break;
        case "YZX":
          this._z = Math.asin(clamp(m21, -1, 1));
          if (Math.abs(m21) < 0.9999999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
          break;
        case "XZY":
          this._z = Math.asin(-clamp(m12, -1, 1));
          if (Math.abs(m12) < 0.9999999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
      }
      this._order = order;
      if (update === true) this._onChangeCallback();
      return this;
    }
    setFromQuaternion(q, order, update) {
      _matrix$2.makeRotationFromQuaternion(q);
      return this.setFromRotationMatrix(_matrix$2, order, update);
    }
    setFromVector3(v, order = this._order) {
      return this.set(v.x, v.y, v.z, order);
    }
    reorder(newOrder) {
      _quaternion$3.setFromEuler(this);
      return this.setFromQuaternion(_quaternion$3, newOrder);
    }
    equals(euler) {
      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
      this._x = array[0];
      this._y = array[1];
      this._z = array[2];
      if (array[3] !== void 0) this._order = array[3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._order;
      return array;
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x;
      yield this._y;
      yield this._z;
      yield this._order;
    }
  }
  Euler.DEFAULT_ORDER = "XYZ";
  class Layers {
    constructor() {
      this.mask = 1 | 0;
    }
    set(channel) {
      this.mask = (1 << channel | 0) >>> 0;
    }
    enable(channel) {
      this.mask |= 1 << channel | 0;
    }
    enableAll() {
      this.mask = 4294967295 | 0;
    }
    toggle(channel) {
      this.mask ^= 1 << channel | 0;
    }
    disable(channel) {
      this.mask &= ~(1 << channel | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(layers) {
      return (this.mask & layers.mask) !== 0;
    }
    isEnabled(channel) {
      return (this.mask & (1 << channel | 0)) !== 0;
    }
  }
  let _object3DId = 0;
  const _v1$4 = /* @__PURE__ */ new Vector3();
  const _q1 = /* @__PURE__ */ new Quaternion();
  const _m1$1 = /* @__PURE__ */ new Matrix4();
  const _target = /* @__PURE__ */ new Vector3();
  const _position$3 = /* @__PURE__ */ new Vector3();
  const _scale$2 = /* @__PURE__ */ new Vector3();
  const _quaternion$2 = /* @__PURE__ */ new Quaternion();
  const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
  const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
  const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
  const _addedEvent = { type: "added" };
  const _removedEvent = { type: "removed" };
  const _childaddedEvent = { type: "childadded", child: null };
  const _childremovedEvent = { type: "childremoved", child: null };
  class Object3D extends EventDispatcher {
    constructor() {
      super();
      this.isObject3D = true;
      Object.defineProperty(this, "id", { value: _object3DId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "Object3D";
      this.parent = null;
      this.children = [];
      this.up = Object3D.DEFAULT_UP.clone();
      const position = new Vector3();
      const rotation = new Euler();
      const quaternion = new Quaternion();
      const scale = new Vector3(1, 1, 1);
      function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
      }
      function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, void 0, false);
      }
      rotation._onChange(onRotationChange);
      quaternion._onChange(onQuaternionChange);
      Object.defineProperties(this, {
        position: {
          configurable: true,
          enumerable: true,
          value: position
        },
        rotation: {
          configurable: true,
          enumerable: true,
          value: rotation
        },
        quaternion: {
          configurable: true,
          enumerable: true,
          value: quaternion
        },
        scale: {
          configurable: true,
          enumerable: true,
          value: scale
        },
        modelViewMatrix: {
          value: new Matrix4()
        },
        normalMatrix: {
          value: new Matrix3()
        }
      });
      this.matrix = new Matrix4();
      this.matrixWorld = new Matrix4();
      this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
      this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
      this.matrixWorldNeedsUpdate = false;
      this.layers = new Layers();
      this.visible = true;
      this.castShadow = false;
      this.receiveShadow = false;
      this.frustumCulled = true;
      this.renderOrder = 0;
      this.animations = [];
      this.userData = {};
    }
    onBeforeShadow() {
    }
    onAfterShadow() {
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(matrix) {
      if (this.matrixAutoUpdate) this.updateMatrix();
      this.matrix.premultiply(matrix);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(q) {
      this.quaternion.premultiply(q);
      return this;
    }
    setRotationFromAxisAngle(axis, angle) {
      this.quaternion.setFromAxisAngle(axis, angle);
    }
    setRotationFromEuler(euler) {
      this.quaternion.setFromEuler(euler, true);
    }
    setRotationFromMatrix(m) {
      this.quaternion.setFromRotationMatrix(m);
    }
    setRotationFromQuaternion(q) {
      this.quaternion.copy(q);
    }
    rotateOnAxis(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(_q1);
      return this;
    }
    rotateOnWorldAxis(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.premultiply(_q1);
      return this;
    }
    rotateX(angle) {
      return this.rotateOnAxis(_xAxis, angle);
    }
    rotateY(angle) {
      return this.rotateOnAxis(_yAxis, angle);
    }
    rotateZ(angle) {
      return this.rotateOnAxis(_zAxis, angle);
    }
    translateOnAxis(axis, distance) {
      _v1$4.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(_v1$4.multiplyScalar(distance));
      return this;
    }
    translateX(distance) {
      return this.translateOnAxis(_xAxis, distance);
    }
    translateY(distance) {
      return this.translateOnAxis(_yAxis, distance);
    }
    translateZ(distance) {
      return this.translateOnAxis(_zAxis, distance);
    }
    localToWorld(vector) {
      this.updateWorldMatrix(true, false);
      return vector.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(vector) {
      this.updateWorldMatrix(true, false);
      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
    }
    lookAt(x2, y, z) {
      if (x2.isVector3) {
        _target.copy(x2);
      } else {
        _target.set(x2, y, z);
      }
      const parent = this.parent;
      this.updateWorldMatrix(true, false);
      _position$3.setFromMatrixPosition(this.matrixWorld);
      if (this.isCamera || this.isLight) {
        _m1$1.lookAt(_position$3, _target, this.up);
      } else {
        _m1$1.lookAt(_target, _position$3, this.up);
      }
      this.quaternion.setFromRotationMatrix(_m1$1);
      if (parent) {
        _m1$1.extractRotation(parent.matrixWorld);
        _q1.setFromRotationMatrix(_m1$1);
        this.quaternion.premultiply(_q1.invert());
      }
    }
    add(object) {
      if (arguments.length > 1) {
        for (let i2 = 0; i2 < arguments.length; i2++) {
          this.add(arguments[i2]);
        }
        return this;
      }
      if (object === this) {
        console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
        return this;
      }
      if (object && object.isObject3D) {
        object.removeFromParent();
        object.parent = this;
        this.children.push(object);
        object.dispatchEvent(_addedEvent);
        _childaddedEvent.child = object;
        this.dispatchEvent(_childaddedEvent);
        _childaddedEvent.child = null;
      } else {
        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
      }
      return this;
    }
    remove(object) {
      if (arguments.length > 1) {
        for (let i2 = 0; i2 < arguments.length; i2++) {
          this.remove(arguments[i2]);
        }
        return this;
      }
      const index = this.children.indexOf(object);
      if (index !== -1) {
        object.parent = null;
        this.children.splice(index, 1);
        object.dispatchEvent(_removedEvent);
        _childremovedEvent.child = object;
        this.dispatchEvent(_childremovedEvent);
        _childremovedEvent.child = null;
      }
      return this;
    }
    removeFromParent() {
      const parent = this.parent;
      if (parent !== null) {
        parent.remove(this);
      }
      return this;
    }
    clear() {
      return this.remove(...this.children);
    }
    attach(object) {
      this.updateWorldMatrix(true, false);
      _m1$1.copy(this.matrixWorld).invert();
      if (object.parent !== null) {
        object.parent.updateWorldMatrix(true, false);
        _m1$1.multiply(object.parent.matrixWorld);
      }
      object.applyMatrix4(_m1$1);
      object.removeFromParent();
      object.parent = this;
      this.children.push(object);
      object.updateWorldMatrix(false, true);
      object.dispatchEvent(_addedEvent);
      _childaddedEvent.child = object;
      this.dispatchEvent(_childaddedEvent);
      _childaddedEvent.child = null;
      return this;
    }
    getObjectById(id) {
      return this.getObjectByProperty("id", id);
    }
    getObjectByName(name) {
      return this.getObjectByProperty("name", name);
    }
    getObjectByProperty(name, value) {
      if (this[name] === value) return this;
      for (let i2 = 0, l = this.children.length; i2 < l; i2++) {
        const child = this.children[i2];
        const object = child.getObjectByProperty(name, value);
        if (object !== void 0) {
          return object;
        }
      }
      return void 0;
    }
    getObjectsByProperty(name, value, result = []) {
      if (this[name] === value) result.push(this);
      const children = this.children;
      for (let i2 = 0, l = children.length; i2 < l; i2++) {
        children[i2].getObjectsByProperty(name, value, result);
      }
      return result;
    }
    getWorldPosition(target) {
      this.updateWorldMatrix(true, false);
      return target.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, target, _scale$2);
      return target;
    }
    getWorldScale(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, _quaternion$2, target);
      return target;
    }
    getWorldDirection(target) {
      this.updateWorldMatrix(true, false);
      const e = this.matrixWorld.elements;
      return target.set(e[8], e[9], e[10]).normalize();
    }
    raycast() {
    }
    traverse(callback) {
      callback(this);
      const children = this.children;
      for (let i2 = 0, l = children.length; i2 < l; i2++) {
        children[i2].traverse(callback);
      }
    }
    traverseVisible(callback) {
      if (this.visible === false) return;
      callback(this);
      const children = this.children;
      for (let i2 = 0, l = children.length; i2 < l; i2++) {
        children[i2].traverseVisible(callback);
      }
    }
    traverseAncestors(callback) {
      const parent = this.parent;
      if (parent !== null) {
        callback(parent);
        parent.traverseAncestors(callback);
      }
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(force) {
      if (this.matrixAutoUpdate) this.updateMatrix();
      if (this.matrixWorldNeedsUpdate || force) {
        if (this.matrixWorldAutoUpdate === true) {
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
        }
        this.matrixWorldNeedsUpdate = false;
        force = true;
      }
      const children = this.children;
      for (let i2 = 0, l = children.length; i2 < l; i2++) {
        const child = children[i2];
        child.updateMatrixWorld(force);
      }
    }
    updateWorldMatrix(updateParents, updateChildren) {
      const parent = this.parent;
      if (updateParents === true && parent !== null) {
        parent.updateWorldMatrix(true, false);
      }
      if (this.matrixAutoUpdate) this.updateMatrix();
      if (this.matrixWorldAutoUpdate === true) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
      }
      if (updateChildren === true) {
        const children = this.children;
        for (let i2 = 0, l = children.length; i2 < l; i2++) {
          const child = children[i2];
          child.updateWorldMatrix(false, true);
        }
      }
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      const output = {};
      if (isRootObject) {
        meta = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {}
        };
        output.metadata = {
          version: 4.6,
          type: "Object",
          generator: "Object3D.toJSON"
        };
      }
      const object = {};
      object.uuid = this.uuid;
      object.type = this.type;
      if (this.name !== "") object.name = this.name;
      if (this.castShadow === true) object.castShadow = true;
      if (this.receiveShadow === true) object.receiveShadow = true;
      if (this.visible === false) object.visible = false;
      if (this.frustumCulled === false) object.frustumCulled = false;
      if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
      if (Object.keys(this.userData).length > 0) object.userData = this.userData;
      object.layers = this.layers.mask;
      object.matrix = this.matrix.toArray();
      object.up = this.up.toArray();
      if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
      if (this.isInstancedMesh) {
        object.type = "InstancedMesh";
        object.count = this.count;
        object.instanceMatrix = this.instanceMatrix.toJSON();
        if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
      }
      if (this.isBatchedMesh) {
        object.type = "BatchedMesh";
        object.perObjectFrustumCulled = this.perObjectFrustumCulled;
        object.sortObjects = this.sortObjects;
        object.drawRanges = this._drawRanges;
        object.reservedRanges = this._reservedRanges;
        object.visibility = this._visibility;
        object.active = this._active;
        object.bounds = this._bounds.map((bound) => ({
          boxInitialized: bound.boxInitialized,
          boxMin: bound.box.min.toArray(),
          boxMax: bound.box.max.toArray(),
          sphereInitialized: bound.sphereInitialized,
          sphereRadius: bound.sphere.radius,
          sphereCenter: bound.sphere.center.toArray()
        }));
        object.maxInstanceCount = this._maxInstanceCount;
        object.maxVertexCount = this._maxVertexCount;
        object.maxIndexCount = this._maxIndexCount;
        object.geometryInitialized = this._geometryInitialized;
        object.geometryCount = this._geometryCount;
        object.matricesTexture = this._matricesTexture.toJSON(meta);
        if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);
        if (this.boundingSphere !== null) {
          object.boundingSphere = {
            center: object.boundingSphere.center.toArray(),
            radius: object.boundingSphere.radius
          };
        }
        if (this.boundingBox !== null) {
          object.boundingBox = {
            min: object.boundingBox.min.toArray(),
            max: object.boundingBox.max.toArray()
          };
        }
      }
      function serialize(library, element) {
        if (library[element.uuid] === void 0) {
          library[element.uuid] = element.toJSON(meta);
        }
        return element.uuid;
      }
      if (this.isScene) {
        if (this.background) {
          if (this.background.isColor) {
            object.background = this.background.toJSON();
          } else if (this.background.isTexture) {
            object.background = this.background.toJSON(meta).uuid;
          }
        }
        if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
          object.environment = this.environment.toJSON(meta).uuid;
        }
      } else if (this.isMesh || this.isLine || this.isPoints) {
        object.geometry = serialize(meta.geometries, this.geometry);
        const parameters = this.geometry.parameters;
        if (parameters !== void 0 && parameters.shapes !== void 0) {
          const shapes = parameters.shapes;
          if (Array.isArray(shapes)) {
            for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
              const shape = shapes[i2];
              serialize(meta.shapes, shape);
            }
          } else {
            serialize(meta.shapes, shapes);
          }
        }
      }
      if (this.isSkinnedMesh) {
        object.bindMode = this.bindMode;
        object.bindMatrix = this.bindMatrix.toArray();
        if (this.skeleton !== void 0) {
          serialize(meta.skeletons, this.skeleton);
          object.skeleton = this.skeleton.uuid;
        }
      }
      if (this.material !== void 0) {
        if (Array.isArray(this.material)) {
          const uuids = [];
          for (let i2 = 0, l = this.material.length; i2 < l; i2++) {
            uuids.push(serialize(meta.materials, this.material[i2]));
          }
          object.material = uuids;
        } else {
          object.material = serialize(meta.materials, this.material);
        }
      }
      if (this.children.length > 0) {
        object.children = [];
        for (let i2 = 0; i2 < this.children.length; i2++) {
          object.children.push(this.children[i2].toJSON(meta).object);
        }
      }
      if (this.animations.length > 0) {
        object.animations = [];
        for (let i2 = 0; i2 < this.animations.length; i2++) {
          const animation = this.animations[i2];
          object.animations.push(serialize(meta.animations, animation));
        }
      }
      if (isRootObject) {
        const geometries = extractFromCache(meta.geometries);
        const materials = extractFromCache(meta.materials);
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        const shapes = extractFromCache(meta.shapes);
        const skeletons = extractFromCache(meta.skeletons);
        const animations = extractFromCache(meta.animations);
        const nodes = extractFromCache(meta.nodes);
        if (geometries.length > 0) output.geometries = geometries;
        if (materials.length > 0) output.materials = materials;
        if (textures.length > 0) output.textures = textures;
        if (images.length > 0) output.images = images;
        if (shapes.length > 0) output.shapes = shapes;
        if (skeletons.length > 0) output.skeletons = skeletons;
        if (animations.length > 0) output.animations = animations;
        if (nodes.length > 0) output.nodes = nodes;
      }
      output.object = object;
      return output;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data = cache[key];
          delete data.metadata;
          values.push(data);
        }
        return values;
      }
    }
    clone(recursive) {
      return new this.constructor().copy(this, recursive);
    }
    copy(source, recursive = true) {
      this.name = source.name;
      this.up.copy(source.up);
      this.position.copy(source.position);
      this.rotation.order = source.rotation.order;
      this.quaternion.copy(source.quaternion);
      this.scale.copy(source.scale);
      this.matrix.copy(source.matrix);
      this.matrixWorld.copy(source.matrixWorld);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
      this.layers.mask = source.layers.mask;
      this.visible = source.visible;
      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;
      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;
      this.animations = source.animations.slice();
      this.userData = JSON.parse(JSON.stringify(source.userData));
      if (recursive === true) {
        for (let i2 = 0; i2 < source.children.length; i2++) {
          const child = source.children[i2];
          this.add(child.clone());
        }
      }
      return this;
    }
  }
  Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);
  Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
  Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
  const _v0$1 = /* @__PURE__ */ new Vector3();
  const _v1$3 = /* @__PURE__ */ new Vector3();
  const _v2$2 = /* @__PURE__ */ new Vector3();
  const _v3$2 = /* @__PURE__ */ new Vector3();
  const _vab = /* @__PURE__ */ new Vector3();
  const _vac = /* @__PURE__ */ new Vector3();
  const _vbc = /* @__PURE__ */ new Vector3();
  const _vap = /* @__PURE__ */ new Vector3();
  const _vbp = /* @__PURE__ */ new Vector3();
  const _vcp = /* @__PURE__ */ new Vector3();
  const _v40 = /* @__PURE__ */ new Vector4();
  const _v41 = /* @__PURE__ */ new Vector4();
  const _v42 = /* @__PURE__ */ new Vector4();
  class Triangle {
    constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
      this.a = a;
      this.b = b;
      this.c = c;
    }
    static getNormal(a, b, c, target) {
      target.subVectors(c, b);
      _v0$1.subVectors(a, b);
      target.cross(_v0$1);
      const targetLengthSq = target.lengthSq();
      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }
      return target.set(0, 0, 0);
    }
    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    static getBarycoord(point, a, b, c, target) {
      _v0$1.subVectors(c, a);
      _v1$3.subVectors(b, a);
      _v2$2.subVectors(point, a);
      const dot00 = _v0$1.dot(_v0$1);
      const dot01 = _v0$1.dot(_v1$3);
      const dot02 = _v0$1.dot(_v2$2);
      const dot11 = _v1$3.dot(_v1$3);
      const dot12 = _v1$3.dot(_v2$2);
      const denom = dot00 * dot11 - dot01 * dot01;
      if (denom === 0) {
        target.set(0, 0, 0);
        return null;
      }
      const invDenom = 1 / denom;
      const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return target.set(1 - u - v, v, u);
    }
    static containsPoint(point, a, b, c) {
      if (this.getBarycoord(point, a, b, c, _v3$2) === null) {
        return false;
      }
      return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
    }
    static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
      if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
        target.x = 0;
        target.y = 0;
        if ("z" in target) target.z = 0;
        if ("w" in target) target.w = 0;
        return null;
      }
      target.setScalar(0);
      target.addScaledVector(v1, _v3$2.x);
      target.addScaledVector(v2, _v3$2.y);
      target.addScaledVector(v3, _v3$2.z);
      return target;
    }
    static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {
      _v40.setScalar(0);
      _v41.setScalar(0);
      _v42.setScalar(0);
      _v40.fromBufferAttribute(attr, i1);
      _v41.fromBufferAttribute(attr, i2);
      _v42.fromBufferAttribute(attr, i3);
      target.setScalar(0);
      target.addScaledVector(_v40, barycoord.x);
      target.addScaledVector(_v41, barycoord.y);
      target.addScaledVector(_v42, barycoord.z);
      return target;
    }
    static isFrontFacing(a, b, c, direction) {
      _v0$1.subVectors(c, b);
      _v1$3.subVectors(a, b);
      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
    }
    set(a, b, c) {
      this.a.copy(a);
      this.b.copy(b);
      this.c.copy(c);
      return this;
    }
    setFromPointsAndIndices(points, i0, i1, i2) {
      this.a.copy(points[i0]);
      this.b.copy(points[i1]);
      this.c.copy(points[i2]);
      return this;
    }
    setFromAttributeAndIndices(attribute, i0, i1, i2) {
      this.a.fromBufferAttribute(attribute, i0);
      this.b.fromBufferAttribute(attribute, i1);
      this.c.fromBufferAttribute(attribute, i2);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(triangle) {
      this.a.copy(triangle.a);
      this.b.copy(triangle.b);
      this.c.copy(triangle.c);
      return this;
    }
    getArea() {
      _v0$1.subVectors(this.c, this.b);
      _v1$3.subVectors(this.a, this.b);
      return _v0$1.cross(_v1$3).length() * 0.5;
    }
    getMidpoint(target) {
      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(target) {
      return Triangle.getNormal(this.a, this.b, this.c, target);
    }
    getPlane(target) {
      return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(point, target) {
      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    }
    getInterpolation(point, v1, v2, v3, target) {
      return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
    }
    containsPoint(point) {
      return Triangle.containsPoint(point, this.a, this.b, this.c);
    }
    isFrontFacing(direction) {
      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    }
    intersectsBox(box) {
      return box.intersectsTriangle(this);
    }
    closestPointToPoint(p, target) {
      const a = this.a, b = this.b, c = this.c;
      let v, w;
      _vab.subVectors(b, a);
      _vac.subVectors(c, a);
      _vap.subVectors(p, a);
      const d1 = _vab.dot(_vap);
      const d2 = _vac.dot(_vap);
      if (d1 <= 0 && d2 <= 0) {
        return target.copy(a);
      }
      _vbp.subVectors(p, b);
      const d3 = _vab.dot(_vbp);
      const d4 = _vac.dot(_vbp);
      if (d3 >= 0 && d4 <= d3) {
        return target.copy(b);
      }
      const vc = d1 * d4 - d3 * d2;
      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v = d1 / (d1 - d3);
        return target.copy(a).addScaledVector(_vab, v);
      }
      _vcp.subVectors(p, c);
      const d5 = _vab.dot(_vcp);
      const d6 = _vac.dot(_vcp);
      if (d6 >= 0 && d5 <= d6) {
        return target.copy(c);
      }
      const vb = d5 * d2 - d1 * d6;
      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w = d2 / (d2 - d6);
        return target.copy(a).addScaledVector(_vac, w);
      }
      const va = d3 * d6 - d5 * d4;
      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        _vbc.subVectors(c, b);
        w = (d4 - d3) / (d4 - d3 + (d5 - d6));
        return target.copy(b).addScaledVector(_vbc, w);
      }
      const denom = 1 / (va + vb + vc);
      v = vb * denom;
      w = vc * denom;
      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
    }
    equals(triangle) {
      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
  }
  const _colorKeywords = {
    "aliceblue": 15792383,
    "antiquewhite": 16444375,
    "aqua": 65535,
    "aquamarine": 8388564,
    "azure": 15794175,
    "beige": 16119260,
    "bisque": 16770244,
    "black": 0,
    "blanchedalmond": 16772045,
    "blue": 255,
    "blueviolet": 9055202,
    "brown": 10824234,
    "burlywood": 14596231,
    "cadetblue": 6266528,
    "chartreuse": 8388352,
    "chocolate": 13789470,
    "coral": 16744272,
    "cornflowerblue": 6591981,
    "cornsilk": 16775388,
    "crimson": 14423100,
    "cyan": 65535,
    "darkblue": 139,
    "darkcyan": 35723,
    "darkgoldenrod": 12092939,
    "darkgray": 11119017,
    "darkgreen": 25600,
    "darkgrey": 11119017,
    "darkkhaki": 12433259,
    "darkmagenta": 9109643,
    "darkolivegreen": 5597999,
    "darkorange": 16747520,
    "darkorchid": 10040012,
    "darkred": 9109504,
    "darksalmon": 15308410,
    "darkseagreen": 9419919,
    "darkslateblue": 4734347,
    "darkslategray": 3100495,
    "darkslategrey": 3100495,
    "darkturquoise": 52945,
    "darkviolet": 9699539,
    "deeppink": 16716947,
    "deepskyblue": 49151,
    "dimgray": 6908265,
    "dimgrey": 6908265,
    "dodgerblue": 2003199,
    "firebrick": 11674146,
    "floralwhite": 16775920,
    "forestgreen": 2263842,
    "fuchsia": 16711935,
    "gainsboro": 14474460,
    "ghostwhite": 16316671,
    "gold": 16766720,
    "goldenrod": 14329120,
    "gray": 8421504,
    "green": 32768,
    "greenyellow": 11403055,
    "grey": 8421504,
    "honeydew": 15794160,
    "hotpink": 16738740,
    "indianred": 13458524,
    "indigo": 4915330,
    "ivory": 16777200,
    "khaki": 15787660,
    "lavender": 15132410,
    "lavenderblush": 16773365,
    "lawngreen": 8190976,
    "lemonchiffon": 16775885,
    "lightblue": 11393254,
    "lightcoral": 15761536,
    "lightcyan": 14745599,
    "lightgoldenrodyellow": 16448210,
    "lightgray": 13882323,
    "lightgreen": 9498256,
    "lightgrey": 13882323,
    "lightpink": 16758465,
    "lightsalmon": 16752762,
    "lightseagreen": 2142890,
    "lightskyblue": 8900346,
    "lightslategray": 7833753,
    "lightslategrey": 7833753,
    "lightsteelblue": 11584734,
    "lightyellow": 16777184,
    "lime": 65280,
    "limegreen": 3329330,
    "linen": 16445670,
    "magenta": 16711935,
    "maroon": 8388608,
    "mediumaquamarine": 6737322,
    "mediumblue": 205,
    "mediumorchid": 12211667,
    "mediumpurple": 9662683,
    "mediumseagreen": 3978097,
    "mediumslateblue": 8087790,
    "mediumspringgreen": 64154,
    "mediumturquoise": 4772300,
    "mediumvioletred": 13047173,
    "midnightblue": 1644912,
    "mintcream": 16121850,
    "mistyrose": 16770273,
    "moccasin": 16770229,
    "navajowhite": 16768685,
    "navy": 128,
    "oldlace": 16643558,
    "olive": 8421376,
    "olivedrab": 7048739,
    "orange": 16753920,
    "orangered": 16729344,
    "orchid": 14315734,
    "palegoldenrod": 15657130,
    "palegreen": 10025880,
    "paleturquoise": 11529966,
    "palevioletred": 14381203,
    "papayawhip": 16773077,
    "peachpuff": 16767673,
    "peru": 13468991,
    "pink": 16761035,
    "plum": 14524637,
    "powderblue": 11591910,
    "purple": 8388736,
    "rebeccapurple": 6697881,
    "red": 16711680,
    "rosybrown": 12357519,
    "royalblue": 4286945,
    "saddlebrown": 9127187,
    "salmon": 16416882,
    "sandybrown": 16032864,
    "seagreen": 3050327,
    "seashell": 16774638,
    "sienna": 10506797,
    "silver": 12632256,
    "skyblue": 8900331,
    "slateblue": 6970061,
    "slategray": 7372944,
    "slategrey": 7372944,
    "snow": 16775930,
    "springgreen": 65407,
    "steelblue": 4620980,
    "tan": 13808780,
    "teal": 32896,
    "thistle": 14204888,
    "tomato": 16737095,
    "turquoise": 4251856,
    "violet": 15631086,
    "wheat": 16113331,
    "white": 16777215,
    "whitesmoke": 16119285,
    "yellow": 16776960,
    "yellowgreen": 10145074
  };
  const _hslA = { h: 0, s: 0, l: 0 };
  const _hslB = { h: 0, s: 0, l: 0 };
  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
    return p;
  }
  class Color {
    constructor(r, g, b) {
      this.isColor = true;
      this.r = 1;
      this.g = 1;
      this.b = 1;
      return this.set(r, g, b);
    }
    set(r, g, b) {
      if (g === void 0 && b === void 0) {
        const value = r;
        if (value && value.isColor) {
          this.copy(value);
        } else if (typeof value === "number") {
          this.setHex(value);
        } else if (typeof value === "string") {
          this.setStyle(value);
        }
      } else {
        this.setRGB(r, g, b);
      }
      return this;
    }
    setScalar(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    }
    setHex(hex, colorSpace = SRGBColorSpace) {
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
    setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
      this.r = r;
      this.g = g;
      this.b = b;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
    setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
      h = euclideanModulo(h, 1);
      s = clamp(s, 0, 1);
      l = clamp(l, 0, 1);
      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        const q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
    setStyle(style, colorSpace = SRGBColorSpace) {
      function handleAlpha(string) {
        if (string === void 0) return;
        if (parseFloat(string) < 1) {
          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
        }
      }
      let m;
      if (m = /^(\\w+)\\(([^\\)]*)\\)/.exec(style)) {
        let color;
        const name = m[1];
        const components = m[2];
        switch (name) {
          case "rgb":
          case "rgba":
            if (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {
              handleAlpha(color[4]);
              return this.setRGB(
                Math.min(255, parseInt(color[1], 10)) / 255,
                Math.min(255, parseInt(color[2], 10)) / 255,
                Math.min(255, parseInt(color[3], 10)) / 255,
                colorSpace
              );
            }
            if (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {
              handleAlpha(color[4]);
              return this.setRGB(
                Math.min(100, parseInt(color[1], 10)) / 100,
                Math.min(100, parseInt(color[2], 10)) / 100,
                Math.min(100, parseInt(color[3], 10)) / 100,
                colorSpace
              );
            }
            break;
          case "hsl":
          case "hsla":
            if (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {
              handleAlpha(color[4]);
              return this.setHSL(
                parseFloat(color[1]) / 360,
                parseFloat(color[2]) / 100,
                parseFloat(color[3]) / 100,
                colorSpace
              );
            }
            break;
          default:
            console.warn("THREE.Color: Unknown color model " + style);
        }
      } else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {
        const hex = m[1];
        const size = hex.length;
        if (size === 3) {
          return this.setRGB(
            parseInt(hex.charAt(0), 16) / 15,
            parseInt(hex.charAt(1), 16) / 15,
            parseInt(hex.charAt(2), 16) / 15,
            colorSpace
          );
        } else if (size === 6) {
          return this.setHex(parseInt(hex, 16), colorSpace);
        } else {
          console.warn("THREE.Color: Invalid hex color " + style);
        }
      } else if (style && style.length > 0) {
        return this.setColorName(style, colorSpace);
      }
      return this;
    }
    setColorName(style, colorSpace = SRGBColorSpace) {
      const hex = _colorKeywords[style.toLowerCase()];
      if (hex !== void 0) {
        this.setHex(hex, colorSpace);
      } else {
        console.warn("THREE.Color: Unknown color " + style);
      }
      return this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    }
    copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    }
    copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    }
    convertSRGBToLinear() {
      this.copySRGBToLinear(this);
      return this;
    }
    convertLinearToSRGB() {
      this.copyLinearToSRGB(this);
      return this;
    }
    getHex(colorSpace = SRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
    }
    getHexString(colorSpace = SRGBColorSpace) {
      return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
    }
    getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      const r = _color.r, g = _color.g, b = _color.b;
      const max2 = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let hue, saturation;
      const lightness = (min + max2) / 2;
      if (min === max2) {
        hue = 0;
        saturation = 0;
      } else {
        const delta = max2 - min;
        saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);
        switch (max2) {
          case r:
            hue = (g - b) / delta + (g < b ? 6 : 0);
            break;
          case g:
            hue = (b - r) / delta + 2;
            break;
          case b:
            hue = (r - g) / delta + 4;
            break;
        }
        hue /= 6;
      }
      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    }
    getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      target.r = _color.r;
      target.g = _color.g;
      target.b = _color.b;
      return target;
    }
    getStyle(colorSpace = SRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      const r = _color.r, g = _color.g, b = _color.b;
      if (colorSpace !== SRGBColorSpace) {
        return \`color(\${colorSpace} \${r.toFixed(3)} \${g.toFixed(3)} \${b.toFixed(3)})\`;
      }
      return \`rgb(\${Math.round(r * 255)},\${Math.round(g * 255)},\${Math.round(b * 255)})\`;
    }
    offsetHSL(h, s, l) {
      this.getHSL(_hslA);
      return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
    }
    add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    }
    addColors(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    }
    addScalar(s) {
      this.r += s;
      this.g += s;
      this.b += s;
      return this;
    }
    sub(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    }
    multiply(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    }
    multiplyScalar(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      return this;
    }
    lerp(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    }
    lerpColors(color1, color2, alpha) {
      this.r = color1.r + (color2.r - color1.r) * alpha;
      this.g = color1.g + (color2.g - color1.g) * alpha;
      this.b = color1.b + (color2.b - color1.b) * alpha;
      return this;
    }
    lerpHSL(color, alpha) {
      this.getHSL(_hslA);
      color.getHSL(_hslB);
      const h = lerp(_hslA.h, _hslB.h, alpha);
      const s = lerp(_hslA.s, _hslB.s, alpha);
      const l = lerp(_hslA.l, _hslB.l, alpha);
      this.setHSL(h, s, l);
      return this;
    }
    setFromVector3(v) {
      this.r = v.x;
      this.g = v.y;
      this.b = v.z;
      return this;
    }
    applyMatrix3(m) {
      const r = this.r, g = this.g, b = this.b;
      const e = m.elements;
      this.r = e[0] * r + e[3] * g + e[6] * b;
      this.g = e[1] * r + e[4] * g + e[7] * b;
      this.b = e[2] * r + e[5] * g + e[8] * b;
      return this;
    }
    equals(c) {
      return c.r === this.r && c.g === this.g && c.b === this.b;
    }
    fromArray(array, offset = 0) {
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this.r = attribute.getX(index);
      this.g = attribute.getY(index);
      this.b = attribute.getZ(index);
      return this;
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r;
      yield this.g;
      yield this.b;
    }
  }
  const _color = /* @__PURE__ */ new Color();
  Color.NAMES = _colorKeywords;
  let _materialId = 0;
  class Material extends EventDispatcher {
    constructor() {
      super();
      this.isMaterial = true;
      Object.defineProperty(this, "id", { value: _materialId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "Material";
      this.blending = NormalBlending;
      this.side = FrontSide;
      this.vertexColors = false;
      this.opacity = 1;
      this.transparent = false;
      this.alphaHash = false;
      this.blendSrc = SrcAlphaFactor;
      this.blendDst = OneMinusSrcAlphaFactor;
      this.blendEquation = AddEquation;
      this.blendSrcAlpha = null;
      this.blendDstAlpha = null;
      this.blendEquationAlpha = null;
      this.blendColor = new Color(0, 0, 0);
      this.blendAlpha = 0;
      this.depthFunc = LessEqualDepth;
      this.depthTest = true;
      this.depthWrite = true;
      this.stencilWriteMask = 255;
      this.stencilFunc = AlwaysStencilFunc;
      this.stencilRef = 0;
      this.stencilFuncMask = 255;
      this.stencilFail = KeepStencilOp;
      this.stencilZFail = KeepStencilOp;
      this.stencilZPass = KeepStencilOp;
      this.stencilWrite = false;
      this.clippingPlanes = null;
      this.clipIntersection = false;
      this.clipShadows = false;
      this.shadowSide = null;
      this.colorWrite = true;
      this.precision = null;
      this.polygonOffset = false;
      this.polygonOffsetFactor = 0;
      this.polygonOffsetUnits = 0;
      this.dithering = false;
      this.alphaToCoverage = false;
      this.premultipliedAlpha = false;
      this.forceSinglePass = false;
      this.visible = true;
      this.toneMapped = true;
      this.userData = {};
      this.version = 0;
      this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(value) {
      if (this._alphaTest > 0 !== value > 0) {
        this.version++;
      }
      this._alphaTest = value;
    }
    // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
    onBeforeRender() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(values) {
      if (values === void 0) return;
      for (const key in values) {
        const newValue = values[key];
        if (newValue === void 0) {
          console.warn(\`THREE.Material: parameter '\${key}' has value of undefined.\`);
          continue;
        }
        const currentValue = this[key];
        if (currentValue === void 0) {
          console.warn(\`THREE.Material: '\${key}' is not a property of THREE.\${this.type}.\`);
          continue;
        }
        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
          currentValue.copy(newValue);
        } else {
          this[key] = newValue;
        }
      }
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (isRootObject) {
        meta = {
          textures: {},
          images: {}
        };
      }
      const data = {
        metadata: {
          version: 4.6,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "") data.name = this.name;
      if (this.color && this.color.isColor) data.color = this.color.getHex();
      if (this.roughness !== void 0) data.roughness = this.roughness;
      if (this.metalness !== void 0) data.metalness = this.metalness;
      if (this.sheen !== void 0) data.sheen = this.sheen;
      if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
      if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;
      if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
      if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
      if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
      if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;
      if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
      if (this.shininess !== void 0) data.shininess = this.shininess;
      if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;
      if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;
      if (this.clearcoatMap && this.clearcoatMap.isTexture) {
        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
      }
      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
      }
      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
      }
      if (this.dispersion !== void 0) data.dispersion = this.dispersion;
      if (this.iridescence !== void 0) data.iridescence = this.iridescence;
      if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;
      if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
      if (this.iridescenceMap && this.iridescenceMap.isTexture) {
        data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
      }
      if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
        data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
      }
      if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;
      if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;
      if (this.anisotropyMap && this.anisotropyMap.isTexture) {
        data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
      }
      if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
      if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
      if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
      if (this.lightMap && this.lightMap.isTexture) {
        data.lightMap = this.lightMap.toJSON(meta).uuid;
        data.lightMapIntensity = this.lightMapIntensity;
      }
      if (this.aoMap && this.aoMap.isTexture) {
        data.aoMap = this.aoMap.toJSON(meta).uuid;
        data.aoMapIntensity = this.aoMapIntensity;
      }
      if (this.bumpMap && this.bumpMap.isTexture) {
        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
        data.bumpScale = this.bumpScale;
      }
      if (this.normalMap && this.normalMap.isTexture) {
        data.normalMap = this.normalMap.toJSON(meta).uuid;
        data.normalMapType = this.normalMapType;
        data.normalScale = this.normalScale.toArray();
      }
      if (this.displacementMap && this.displacementMap.isTexture) {
        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
        data.displacementScale = this.displacementScale;
        data.displacementBias = this.displacementBias;
      }
      if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
      if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
      if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
      if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
      if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
      if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
      if (this.envMap && this.envMap.isTexture) {
        data.envMap = this.envMap.toJSON(meta).uuid;
        if (this.combine !== void 0) data.combine = this.combine;
      }
      if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();
      if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;
      if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;
      if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;
      if (this.gradientMap && this.gradientMap.isTexture) {
        data.gradientMap = this.gradientMap.toJSON(meta).uuid;
      }
      if (this.transmission !== void 0) data.transmission = this.transmission;
      if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
      if (this.thickness !== void 0) data.thickness = this.thickness;
      if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
      if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
      if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();
      if (this.size !== void 0) data.size = this.size;
      if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
      if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;
      if (this.blending !== NormalBlending) data.blending = this.blending;
      if (this.side !== FrontSide) data.side = this.side;
      if (this.vertexColors === true) data.vertexColors = true;
      if (this.opacity < 1) data.opacity = this.opacity;
      if (this.transparent === true) data.transparent = true;
      if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
      if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
      if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;
      if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
      if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
      if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
      if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
      if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
      if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
      if (this.depthTest === false) data.depthTest = this.depthTest;
      if (this.depthWrite === false) data.depthWrite = this.depthWrite;
      if (this.colorWrite === false) data.colorWrite = this.colorWrite;
      if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;
      if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;
      if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
      if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;
      if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
      if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;
      if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;
      if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;
      if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;
      if (this.polygonOffset === true) data.polygonOffset = true;
      if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
      if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
      if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;
      if (this.dashSize !== void 0) data.dashSize = this.dashSize;
      if (this.gapSize !== void 0) data.gapSize = this.gapSize;
      if (this.scale !== void 0) data.scale = this.scale;
      if (this.dithering === true) data.dithering = true;
      if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
      if (this.alphaHash === true) data.alphaHash = true;
      if (this.alphaToCoverage === true) data.alphaToCoverage = true;
      if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
      if (this.forceSinglePass === true) data.forceSinglePass = true;
      if (this.wireframe === true) data.wireframe = true;
      if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
      if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
      if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
      if (this.flatShading === true) data.flatShading = true;
      if (this.visible === false) data.visible = false;
      if (this.toneMapped === false) data.toneMapped = false;
      if (this.fog === false) data.fog = false;
      if (Object.keys(this.userData).length > 0) data.userData = this.userData;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data2 = cache[key];
          delete data2.metadata;
          values.push(data2);
        }
        return values;
      }
      if (isRootObject) {
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        if (textures.length > 0) data.textures = textures;
        if (images.length > 0) data.images = images;
      }
      return data;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.name = source.name;
      this.blending = source.blending;
      this.side = source.side;
      this.vertexColors = source.vertexColors;
      this.opacity = source.opacity;
      this.transparent = source.transparent;
      this.blendSrc = source.blendSrc;
      this.blendDst = source.blendDst;
      this.blendEquation = source.blendEquation;
      this.blendSrcAlpha = source.blendSrcAlpha;
      this.blendDstAlpha = source.blendDstAlpha;
      this.blendEquationAlpha = source.blendEquationAlpha;
      this.blendColor.copy(source.blendColor);
      this.blendAlpha = source.blendAlpha;
      this.depthFunc = source.depthFunc;
      this.depthTest = source.depthTest;
      this.depthWrite = source.depthWrite;
      this.stencilWriteMask = source.stencilWriteMask;
      this.stencilFunc = source.stencilFunc;
      this.stencilRef = source.stencilRef;
      this.stencilFuncMask = source.stencilFuncMask;
      this.stencilFail = source.stencilFail;
      this.stencilZFail = source.stencilZFail;
      this.stencilZPass = source.stencilZPass;
      this.stencilWrite = source.stencilWrite;
      const srcPlanes = source.clippingPlanes;
      let dstPlanes = null;
      if (srcPlanes !== null) {
        const n = srcPlanes.length;
        dstPlanes = new Array(n);
        for (let i2 = 0; i2 !== n; ++i2) {
          dstPlanes[i2] = srcPlanes[i2].clone();
        }
      }
      this.clippingPlanes = dstPlanes;
      this.clipIntersection = source.clipIntersection;
      this.clipShadows = source.clipShadows;
      this.shadowSide = source.shadowSide;
      this.colorWrite = source.colorWrite;
      this.precision = source.precision;
      this.polygonOffset = source.polygonOffset;
      this.polygonOffsetFactor = source.polygonOffsetFactor;
      this.polygonOffsetUnits = source.polygonOffsetUnits;
      this.dithering = source.dithering;
      this.alphaTest = source.alphaTest;
      this.alphaHash = source.alphaHash;
      this.alphaToCoverage = source.alphaToCoverage;
      this.premultipliedAlpha = source.premultipliedAlpha;
      this.forceSinglePass = source.forceSinglePass;
      this.visible = source.visible;
      this.toneMapped = source.toneMapped;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(value) {
      if (value === true) this.version++;
    }
    onBuild() {
      console.warn("Material: onBuild() has been removed.");
    }
  }
  class MeshBasicMaterial extends Material {
    constructor(parameters) {
      super();
      this.isMeshBasicMaterial = true;
      this.type = "MeshBasicMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.envMapRotation = new Euler();
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.envMapRotation.copy(source.envMapRotation);
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.fog = source.fog;
      return this;
    }
  }
  const _vector$9 = /* @__PURE__ */ new Vector3();
  const _vector2$1 = /* @__PURE__ */ new Vector2();
  class BufferAttribute {
    constructor(array, itemSize, normalized = false) {
      if (Array.isArray(array)) {
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      }
      this.isBufferAttribute = true;
      this.name = "";
      this.array = array;
      this.itemSize = itemSize;
      this.count = array !== void 0 ? array.length / itemSize : 0;
      this.normalized = normalized;
      this.usage = StaticDrawUsage;
      this.updateRanges = [];
      this.gpuType = FloatType;
      this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(value) {
      if (value === true) this.version++;
    }
    setUsage(value) {
      this.usage = value;
      return this;
    }
    addUpdateRange(start, count) {
      this.updateRanges.push({ start, count });
    }
    clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
    copy(source) {
      this.name = source.name;
      this.array = new source.array.constructor(source.array);
      this.itemSize = source.itemSize;
      this.count = source.count;
      this.normalized = source.normalized;
      this.usage = source.usage;
      this.gpuType = source.gpuType;
      return this;
    }
    copyAt(index1, attribute, index2) {
      index1 *= this.itemSize;
      index2 *= attribute.itemSize;
      for (let i2 = 0, l = this.itemSize; i2 < l; i2++) {
        this.array[index1 + i2] = attribute.array[index2 + i2];
      }
      return this;
    }
    copyArray(array) {
      this.array.set(array);
      return this;
    }
    applyMatrix3(m) {
      if (this.itemSize === 2) {
        for (let i2 = 0, l = this.count; i2 < l; i2++) {
          _vector2$1.fromBufferAttribute(this, i2);
          _vector2$1.applyMatrix3(m);
          this.setXY(i2, _vector2$1.x, _vector2$1.y);
        }
      } else if (this.itemSize === 3) {
        for (let i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$9.fromBufferAttribute(this, i2);
          _vector$9.applyMatrix3(m);
          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
        }
      }
      return this;
    }
    applyMatrix4(m) {
      for (let i2 = 0, l = this.count; i2 < l; i2++) {
        _vector$9.fromBufferAttribute(this, i2);
        _vector$9.applyMatrix4(m);
        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    applyNormalMatrix(m) {
      for (let i2 = 0, l = this.count; i2 < l; i2++) {
        _vector$9.fromBufferAttribute(this, i2);
        _vector$9.applyNormalMatrix(m);
        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    transformDirection(m) {
      for (let i2 = 0, l = this.count; i2 < l; i2++) {
        _vector$9.fromBufferAttribute(this, i2);
        _vector$9.transformDirection(m);
        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    set(value, offset = 0) {
      this.array.set(value, offset);
      return this;
    }
    getComponent(index, component) {
      let value = this.array[index * this.itemSize + component];
      if (this.normalized) value = denormalize(value, this.array);
      return value;
    }
    setComponent(index, component, value) {
      if (this.normalized) value = normalize$1(value, this.array);
      this.array[index * this.itemSize + component] = value;
      return this;
    }
    getX(index) {
      let x2 = this.array[index * this.itemSize];
      if (this.normalized) x2 = denormalize(x2, this.array);
      return x2;
    }
    setX(index, x2) {
      if (this.normalized) x2 = normalize$1(x2, this.array);
      this.array[index * this.itemSize] = x2;
      return this;
    }
    getY(index) {
      let y = this.array[index * this.itemSize + 1];
      if (this.normalized) y = denormalize(y, this.array);
      return y;
    }
    setY(index, y) {
      if (this.normalized) y = normalize$1(y, this.array);
      this.array[index * this.itemSize + 1] = y;
      return this;
    }
    getZ(index) {
      let z = this.array[index * this.itemSize + 2];
      if (this.normalized) z = denormalize(z, this.array);
      return z;
    }
    setZ(index, z) {
      if (this.normalized) z = normalize$1(z, this.array);
      this.array[index * this.itemSize + 2] = z;
      return this;
    }
    getW(index) {
      let w = this.array[index * this.itemSize + 3];
      if (this.normalized) w = denormalize(w, this.array);
      return w;
    }
    setW(index, w) {
      if (this.normalized) w = normalize$1(w, this.array);
      this.array[index * this.itemSize + 3] = w;
      return this;
    }
    setXY(index, x2, y) {
      index *= this.itemSize;
      if (this.normalized) {
        x2 = normalize$1(x2, this.array);
        y = normalize$1(y, this.array);
      }
      this.array[index + 0] = x2;
      this.array[index + 1] = y;
      return this;
    }
    setXYZ(index, x2, y, z) {
      index *= this.itemSize;
      if (this.normalized) {
        x2 = normalize$1(x2, this.array);
        y = normalize$1(y, this.array);
        z = normalize$1(z, this.array);
      }
      this.array[index + 0] = x2;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      return this;
    }
    setXYZW(index, x2, y, z, w) {
      index *= this.itemSize;
      if (this.normalized) {
        x2 = normalize$1(x2, this.array);
        y = normalize$1(y, this.array);
        z = normalize$1(z, this.array);
        w = normalize$1(w, this.array);
      }
      this.array[index + 0] = x2;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      this.array[index + 3] = w;
      return this;
    }
    onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const data = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized
      };
      if (this.name !== "") data.name = this.name;
      if (this.usage !== StaticDrawUsage) data.usage = this.usage;
      return data;
    }
  }
  class Uint16BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Uint16Array(array), itemSize, normalized);
    }
  }
  class Uint32BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Uint32Array(array), itemSize, normalized);
    }
  }
  class Float32BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Float32Array(array), itemSize, normalized);
    }
  }
  let _id$1 = 0;
  const _m1 = /* @__PURE__ */ new Matrix4();
  const _obj = /* @__PURE__ */ new Object3D();
  const _offset = /* @__PURE__ */ new Vector3();
  const _box$2 = /* @__PURE__ */ new Box3();
  const _boxMorphTargets = /* @__PURE__ */ new Box3();
  const _vector$8 = /* @__PURE__ */ new Vector3();
  class BufferGeometry extends EventDispatcher {
    constructor() {
      super();
      this.isBufferGeometry = true;
      Object.defineProperty(this, "id", { value: _id$1++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "BufferGeometry";
      this.index = null;
      this.indirect = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.morphTargetsRelative = false;
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.drawRange = { start: 0, count: Infinity };
      this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(index) {
      if (Array.isArray(index)) {
        this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
      } else {
        this.index = index;
      }
      return this;
    }
    setIndirect(indirect) {
      this.indirect = indirect;
      return this;
    }
    getIndirect() {
      return this.indirect;
    }
    getAttribute(name) {
      return this.attributes[name];
    }
    setAttribute(name, attribute) {
      this.attributes[name] = attribute;
      return this;
    }
    deleteAttribute(name) {
      delete this.attributes[name];
      return this;
    }
    hasAttribute(name) {
      return this.attributes[name] !== void 0;
    }
    addGroup(start, count, materialIndex = 0) {
      this.groups.push({
        start,
        count,
        materialIndex
      });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(start, count) {
      this.drawRange.start = start;
      this.drawRange.count = count;
    }
    applyMatrix4(matrix) {
      const position = this.attributes.position;
      if (position !== void 0) {
        position.applyMatrix4(matrix);
        position.needsUpdate = true;
      }
      const normal = this.attributes.normal;
      if (normal !== void 0) {
        const normalMatrix = new Matrix3().getNormalMatrix(matrix);
        normal.applyNormalMatrix(normalMatrix);
        normal.needsUpdate = true;
      }
      const tangent = this.attributes.tangent;
      if (tangent !== void 0) {
        tangent.transformDirection(matrix);
        tangent.needsUpdate = true;
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      return this;
    }
    applyQuaternion(q) {
      _m1.makeRotationFromQuaternion(q);
      this.applyMatrix4(_m1);
      return this;
    }
    rotateX(angle) {
      _m1.makeRotationX(angle);
      this.applyMatrix4(_m1);
      return this;
    }
    rotateY(angle) {
      _m1.makeRotationY(angle);
      this.applyMatrix4(_m1);
      return this;
    }
    rotateZ(angle) {
      _m1.makeRotationZ(angle);
      this.applyMatrix4(_m1);
      return this;
    }
    translate(x2, y, z) {
      _m1.makeTranslation(x2, y, z);
      this.applyMatrix4(_m1);
      return this;
    }
    scale(x2, y, z) {
      _m1.makeScale(x2, y, z);
      this.applyMatrix4(_m1);
      return this;
    }
    lookAt(vector) {
      _obj.lookAt(vector);
      _obj.updateMatrix();
      this.applyMatrix4(_obj.matrix);
      return this;
    }
    center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(_offset).negate();
      this.translate(_offset.x, _offset.y, _offset.z);
      return this;
    }
    setFromPoints(points) {
      const positionAttribute = this.getAttribute("position");
      if (positionAttribute === void 0) {
        const position = [];
        for (let i2 = 0, l = points.length; i2 < l; i2++) {
          const point = points[i2];
          position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute("position", new Float32BufferAttribute(position, 3));
      } else {
        const l = Math.min(points.length, positionAttribute.count);
        for (let i2 = 0; i2 < l; i2++) {
          const point = points[i2];
          positionAttribute.setXYZ(i2, point.x, point.y, point.z || 0);
        }
        if (points.length > positionAttribute.count) {
          console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.");
        }
        positionAttribute.needsUpdate = true;
      }
      return this;
    }
    computeBoundingBox() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);
        this.boundingBox.set(
          new Vector3(-Infinity, -Infinity, -Infinity),
          new Vector3(Infinity, Infinity, Infinity)
        );
        return;
      }
      if (position !== void 0) {
        this.boundingBox.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
            const morphAttribute = morphAttributesPosition[i2];
            _box$2.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(this.boundingBox.min, _box$2.min);
              this.boundingBox.expandByPoint(_vector$8);
              _vector$8.addVectors(this.boundingBox.max, _box$2.max);
              this.boundingBox.expandByPoint(_vector$8);
            } else {
              this.boundingBox.expandByPoint(_box$2.min);
              this.boundingBox.expandByPoint(_box$2.max);
            }
          }
        }
      } else {
        this.boundingBox.makeEmpty();
      }
      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);
        this.boundingSphere.set(new Vector3(), Infinity);
        return;
      }
      if (position) {
        const center = this.boundingSphere.center;
        _box$2.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
            const morphAttribute = morphAttributesPosition[i2];
            _boxMorphTargets.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
              _box$2.expandByPoint(_vector$8);
              _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
              _box$2.expandByPoint(_vector$8);
            } else {
              _box$2.expandByPoint(_boxMorphTargets.min);
              _box$2.expandByPoint(_boxMorphTargets.max);
            }
          }
        }
        _box$2.getCenter(center);
        let maxRadiusSq = 0;
        for (let i2 = 0, il = position.count; i2 < il; i2++) {
          _vector$8.fromBufferAttribute(position, i2);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
        }
        if (morphAttributesPosition) {
          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
            const morphAttribute = morphAttributesPosition[i2];
            const morphTargetsRelative = this.morphTargetsRelative;
            for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
              _vector$8.fromBufferAttribute(morphAttribute, j);
              if (morphTargetsRelative) {
                _offset.fromBufferAttribute(position, j);
                _vector$8.add(_offset);
              }
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
          }
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    }
    computeTangents() {
      const index = this.index;
      const attributes = this.attributes;
      if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        return;
      }
      const positionAttribute = attributes.position;
      const normalAttribute = attributes.normal;
      const uvAttribute = attributes.uv;
      if (this.hasAttribute("tangent") === false) {
        this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
      }
      const tangentAttribute = this.getAttribute("tangent");
      const tan1 = [], tan2 = [];
      for (let i2 = 0; i2 < positionAttribute.count; i2++) {
        tan1[i2] = new Vector3();
        tan2[i2] = new Vector3();
      }
      const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
      function handleTriangle(a, b, c) {
        vA.fromBufferAttribute(positionAttribute, a);
        vB.fromBufferAttribute(positionAttribute, b);
        vC.fromBufferAttribute(positionAttribute, c);
        uvA.fromBufferAttribute(uvAttribute, a);
        uvB.fromBufferAttribute(uvAttribute, b);
        uvC.fromBufferAttribute(uvAttribute, c);
        vB.sub(vA);
        vC.sub(vA);
        uvB.sub(uvA);
        uvC.sub(uvA);
        const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
        if (!isFinite(r)) return;
        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
        tan1[a].add(sdir);
        tan1[b].add(sdir);
        tan1[c].add(sdir);
        tan2[a].add(tdir);
        tan2[b].add(tdir);
        tan2[c].add(tdir);
      }
      let groups = this.groups;
      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: index.count
        }];
      }
      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
        const group = groups[i2];
        const start = group.start;
        const count = group.count;
        for (let j = start, jl = start + count; j < jl; j += 3) {
          handleTriangle(
            index.getX(j + 0),
            index.getX(j + 1),
            index.getX(j + 2)
          );
        }
      }
      const tmp = new Vector3(), tmp2 = new Vector3();
      const n = new Vector3(), n2 = new Vector3();
      function handleVertex(v) {
        n.fromBufferAttribute(normalAttribute, v);
        n2.copy(n);
        const t = tan1[v];
        tmp.copy(t);
        tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
        tmp2.crossVectors(n2, t);
        const test = tmp2.dot(tan2[v]);
        const w = test < 0 ? -1 : 1;
        tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);
      }
      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
        const group = groups[i2];
        const start = group.start;
        const count = group.count;
        for (let j = start, jl = start + count; j < jl; j += 3) {
          handleVertex(index.getX(j + 0));
          handleVertex(index.getX(j + 1));
          handleVertex(index.getX(j + 2));
        }
      }
    }
    computeVertexNormals() {
      const index = this.index;
      const positionAttribute = this.getAttribute("position");
      if (positionAttribute !== void 0) {
        let normalAttribute = this.getAttribute("normal");
        if (normalAttribute === void 0) {
          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
          this.setAttribute("normal", normalAttribute);
        } else {
          for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
            normalAttribute.setXYZ(i2, 0, 0, 0);
          }
        }
        const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
        const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
        const cb = new Vector3(), ab = new Vector3();
        if (index) {
          for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
            const vA = index.getX(i2 + 0);
            const vB = index.getX(i2 + 1);
            const vC = index.getX(i2 + 2);
            pA.fromBufferAttribute(positionAttribute, vA);
            pB.fromBufferAttribute(positionAttribute, vB);
            pC.fromBufferAttribute(positionAttribute, vC);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            nA.fromBufferAttribute(normalAttribute, vA);
            nB.fromBufferAttribute(normalAttribute, vB);
            nC.fromBufferAttribute(normalAttribute, vC);
            nA.add(cb);
            nB.add(cb);
            nC.add(cb);
            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
          }
        } else {
          for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
            pA.fromBufferAttribute(positionAttribute, i2 + 0);
            pB.fromBufferAttribute(positionAttribute, i2 + 1);
            pC.fromBufferAttribute(positionAttribute, i2 + 2);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
          }
        }
        this.normalizeNormals();
        normalAttribute.needsUpdate = true;
      }
    }
    normalizeNormals() {
      const normals = this.attributes.normal;
      for (let i2 = 0, il = normals.count; i2 < il; i2++) {
        _vector$8.fromBufferAttribute(normals, i2);
        _vector$8.normalize();
        normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
      }
    }
    toNonIndexed() {
      function convertBufferAttribute(attribute, indices2) {
        const array = attribute.array;
        const itemSize = attribute.itemSize;
        const normalized = attribute.normalized;
        const array2 = new array.constructor(indices2.length * itemSize);
        let index = 0, index2 = 0;
        for (let i2 = 0, l = indices2.length; i2 < l; i2++) {
          if (attribute.isInterleavedBufferAttribute) {
            index = indices2[i2] * attribute.data.stride + attribute.offset;
          } else {
            index = indices2[i2] * itemSize;
          }
          for (let j = 0; j < itemSize; j++) {
            array2[index2++] = array[index++];
          }
        }
        return new BufferAttribute(array2, itemSize, normalized);
      }
      if (this.index === null) {
        console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
        return this;
      }
      const geometry2 = new BufferGeometry();
      const indices = this.index.array;
      const attributes = this.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        const newAttribute = convertBufferAttribute(attribute, indices);
        geometry2.setAttribute(name, newAttribute);
      }
      const morphAttributes = this.morphAttributes;
      for (const name in morphAttributes) {
        const morphArray = [];
        const morphAttribute = morphAttributes[name];
        for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
          const attribute = morphAttribute[i2];
          const newAttribute = convertBufferAttribute(attribute, indices);
          morphArray.push(newAttribute);
        }
        geometry2.morphAttributes[name] = morphArray;
      }
      geometry2.morphTargetsRelative = this.morphTargetsRelative;
      const groups = this.groups;
      for (let i2 = 0, l = groups.length; i2 < l; i2++) {
        const group = groups[i2];
        geometry2.addGroup(group.start, group.count, group.materialIndex);
      }
      return geometry2;
    }
    toJSON() {
      const data = {
        metadata: {
          version: 4.6,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "") data.name = this.name;
      if (Object.keys(this.userData).length > 0) data.userData = this.userData;
      if (this.parameters !== void 0) {
        const parameters = this.parameters;
        for (const key in parameters) {
          if (parameters[key] !== void 0) data[key] = parameters[key];
        }
        return data;
      }
      data.data = { attributes: {} };
      const index = this.index;
      if (index !== null) {
        data.data.index = {
          type: index.array.constructor.name,
          array: Array.prototype.slice.call(index.array)
        };
      }
      const attributes = this.attributes;
      for (const key in attributes) {
        const attribute = attributes[key];
        data.data.attributes[key] = attribute.toJSON(data.data);
      }
      const morphAttributes = {};
      let hasMorphAttributes = false;
      for (const key in this.morphAttributes) {
        const attributeArray = this.morphAttributes[key];
        const array = [];
        for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
          const attribute = attributeArray[i2];
          array.push(attribute.toJSON(data.data));
        }
        if (array.length > 0) {
          morphAttributes[key] = array;
          hasMorphAttributes = true;
        }
      }
      if (hasMorphAttributes) {
        data.data.morphAttributes = morphAttributes;
        data.data.morphTargetsRelative = this.morphTargetsRelative;
      }
      const groups = this.groups;
      if (groups.length > 0) {
        data.data.groups = JSON.parse(JSON.stringify(groups));
      }
      const boundingSphere = this.boundingSphere;
      if (boundingSphere !== null) {
        data.data.boundingSphere = {
          center: boundingSphere.center.toArray(),
          radius: boundingSphere.radius
        };
      }
      return data;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      const data = {};
      this.name = source.name;
      const index = source.index;
      if (index !== null) {
        this.setIndex(index.clone(data));
      }
      const attributes = source.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        this.setAttribute(name, attribute.clone(data));
      }
      const morphAttributes = source.morphAttributes;
      for (const name in morphAttributes) {
        const array = [];
        const morphAttribute = morphAttributes[name];
        for (let i2 = 0, l = morphAttribute.length; i2 < l; i2++) {
          array.push(morphAttribute[i2].clone(data));
        }
        this.morphAttributes[name] = array;
      }
      this.morphTargetsRelative = source.morphTargetsRelative;
      const groups = source.groups;
      for (let i2 = 0, l = groups.length; i2 < l; i2++) {
        const group = groups[i2];
        this.addGroup(group.start, group.count, group.materialIndex);
      }
      const boundingBox = source.boundingBox;
      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }
      const boundingSphere = source.boundingSphere;
      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }
      this.drawRange.start = source.drawRange.start;
      this.drawRange.count = source.drawRange.count;
      this.userData = source.userData;
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  const _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();
  const _ray$3 = /* @__PURE__ */ new Ray();
  const _sphere$6 = /* @__PURE__ */ new Sphere();
  const _sphereHitAt = /* @__PURE__ */ new Vector3();
  const _vA$1 = /* @__PURE__ */ new Vector3();
  const _vB$1 = /* @__PURE__ */ new Vector3();
  const _vC$1 = /* @__PURE__ */ new Vector3();
  const _tempA = /* @__PURE__ */ new Vector3();
  const _morphA = /* @__PURE__ */ new Vector3();
  const _intersectionPoint = /* @__PURE__ */ new Vector3();
  const _intersectionPointWorld = /* @__PURE__ */ new Vector3();
  class Mesh extends Object3D {
    constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
      super();
      this.isMesh = true;
      this.type = "Mesh";
      this.geometry = geometry;
      this.material = material;
      this.updateMorphTargets();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      if (source.morphTargetInfluences !== void 0) {
        this.morphTargetInfluences = source.morphTargetInfluences.slice();
      }
      if (source.morphTargetDictionary !== void 0) {
        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
      }
      this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
      this.geometry = source.geometry;
      return this;
    }
    updateMorphTargets() {
      const geometry = this.geometry;
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    }
    getVertexPosition(index, target) {
      const geometry = this.geometry;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      target.fromBufferAttribute(position, index);
      const morphInfluences = this.morphTargetInfluences;
      if (morphPosition && morphInfluences) {
        _morphA.set(0, 0, 0);
        for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
          const influence = morphInfluences[i2];
          const morphAttribute = morphPosition[i2];
          if (influence === 0) continue;
          _tempA.fromBufferAttribute(morphAttribute, index);
          if (morphTargetsRelative) {
            _morphA.addScaledVector(_tempA, influence);
          } else {
            _morphA.addScaledVector(_tempA.sub(target), influence);
          }
        }
        target.add(_morphA);
      }
      return target;
    }
    raycast(raycaster, intersects) {
      const geometry = this.geometry;
      const material = this.material;
      const matrixWorld = this.matrixWorld;
      if (material === void 0) return;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere$6.copy(geometry.boundingSphere);
      _sphere$6.applyMatrix4(matrixWorld);
      _ray$3.copy(raycaster.ray).recast(raycaster.near);
      if (_sphere$6.containsPoint(_ray$3.origin) === false) {
        if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
        if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;
      }
      _inverseMatrix$3.copy(matrixWorld).invert();
      _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
      if (geometry.boundingBox !== null) {
        if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
      }
      this._computeIntersections(raycaster, intersects, _ray$3);
    }
    _computeIntersections(raycaster, intersects, rayLocalSpace) {
      let intersection;
      const geometry = this.geometry;
      const material = this.material;
      const index = geometry.index;
      const position = geometry.attributes.position;
      const uv = geometry.attributes.uv;
      const uv1 = geometry.attributes.uv1;
      const normal = geometry.attributes.normal;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index !== null) {
        if (Array.isArray(material)) {
          for (let i2 = 0, il = groups.length; i2 < il; i2++) {
            const group = groups[i2];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j = start, jl = end; j < jl; j += 3) {
              const a = index.getX(j);
              const b = index.getX(j + 1);
              const c = index.getX(j + 2);
              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i2 = start, il = end; i2 < il; i2 += 3) {
            const a = index.getX(i2);
            const b = index.getX(i2 + 1);
            const c = index.getX(i2 + 2);
            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i2 / 3);
              intersects.push(intersection);
            }
          }
        }
      } else if (position !== void 0) {
        if (Array.isArray(material)) {
          for (let i2 = 0, il = groups.length; i2 < il; i2++) {
            const group = groups[i2];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j = start, jl = end; j < jl; j += 3) {
              const a = j;
              const b = j + 1;
              const c = j + 2;
              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);
          for (let i2 = start, il = end; i2 < il; i2 += 3) {
            const a = i2;
            const b = i2 + 1;
            const c = i2 + 2;
            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i2 / 3);
              intersects.push(intersection);
            }
          }
        }
      }
    }
  }
  function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) {
      intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
      intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
    }
    if (intersect === null) return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far) return null;
    return {
      distance,
      point: _intersectionPointWorld.clone(),
      object
    };
  }
  function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {
    object.getVertexPosition(a, _vA$1);
    object.getVertexPosition(b, _vB$1);
    object.getVertexPosition(c, _vC$1);
    const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (intersection) {
      const barycoord = new Vector3();
      Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);
      if (uv) {
        intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());
      }
      if (uv1) {
        intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());
      }
      if (normal) {
        intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());
        if (intersection.normal.dot(ray.direction) > 0) {
          intersection.normal.multiplyScalar(-1);
        }
      }
      const face = {
        a,
        b,
        c,
        normal: new Vector3(),
        materialIndex: 0
      };
      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
      intersection.face = face;
      intersection.barycoord = barycoord;
    }
    return intersection;
  }
  function cloneUniforms(src) {
    const dst = {};
    for (const u in src) {
      dst[u] = {};
      for (const p in src[u]) {
        const property = src[u][p];
        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
          if (property.isRenderTargetTexture) {
            console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
            dst[u][p] = null;
          } else {
            dst[u][p] = property.clone();
          }
        } else if (Array.isArray(property)) {
          dst[u][p] = property.slice();
        } else {
          dst[u][p] = property;
        }
      }
    }
    return dst;
  }
  function cloneUniformsGroups(src) {
    const dst = [];
    for (let u = 0; u < src.length; u++) {
      dst.push(src[u].clone());
    }
    return dst;
  }
  var default_vertex = "void main() {\\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}";
  var default_fragment = "void main() {\\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}";
  class ShaderMaterial extends Material {
    constructor(parameters) {
      super();
      this.isShaderMaterial = true;
      this.type = "ShaderMaterial";
      this.defines = {};
      this.uniforms = {};
      this.uniformsGroups = [];
      this.vertexShader = default_vertex;
      this.fragmentShader = default_fragment;
      this.linewidth = 1;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.lights = false;
      this.clipping = false;
      this.forceSinglePass = true;
      this.extensions = {
        clipCullDistance: false,
        // set to use vertex shader clipping
        multiDraw: false
        // set to use vertex shader multi_draw / enable gl_DrawID
      };
      this.defaultAttributeValues = {
        "color": [1, 1, 1],
        "uv": [0, 0],
        "uv1": [0, 0]
      };
      this.index0AttributeName = void 0;
      this.uniformsNeedUpdate = false;
      this.glslVersion = null;
      if (parameters !== void 0) {
        this.setValues(parameters);
      }
    }
    copy(source) {
      super.copy(source);
      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;
      this.uniforms = cloneUniforms(source.uniforms);
      this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
      this.defines = Object.assign({}, source.defines);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.fog = source.fog;
      this.lights = source.lights;
      this.clipping = source.clipping;
      this.extensions = Object.assign({}, source.extensions);
      this.glslVersion = source.glslVersion;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.glslVersion = this.glslVersion;
      data.uniforms = {};
      for (const name in this.uniforms) {
        const uniform = this.uniforms[name];
        const value = uniform.value;
        if (value && value.isTexture) {
          data.uniforms[name] = {
            type: "t",
            value: value.toJSON(meta).uuid
          };
        } else if (value && value.isColor) {
          data.uniforms[name] = {
            type: "c",
            value: value.getHex()
          };
        } else if (value && value.isVector2) {
          data.uniforms[name] = {
            type: "v2",
            value: value.toArray()
          };
        } else if (value && value.isVector3) {
          data.uniforms[name] = {
            type: "v3",
            value: value.toArray()
          };
        } else if (value && value.isVector4) {
          data.uniforms[name] = {
            type: "v4",
            value: value.toArray()
          };
        } else if (value && value.isMatrix3) {
          data.uniforms[name] = {
            type: "m3",
            value: value.toArray()
          };
        } else if (value && value.isMatrix4) {
          data.uniforms[name] = {
            type: "m4",
            value: value.toArray()
          };
        } else {
          data.uniforms[name] = {
            value
          };
        }
      }
      if (Object.keys(this.defines).length > 0) data.defines = this.defines;
      data.vertexShader = this.vertexShader;
      data.fragmentShader = this.fragmentShader;
      data.lights = this.lights;
      data.clipping = this.clipping;
      const extensions = {};
      for (const key in this.extensions) {
        if (this.extensions[key] === true) extensions[key] = true;
      }
      if (Object.keys(extensions).length > 0) data.extensions = extensions;
      return data;
    }
  }
  class Camera extends Object3D {
    constructor() {
      super();
      this.isCamera = true;
      this.type = "Camera";
      this.matrixWorldInverse = new Matrix4();
      this.projectionMatrix = new Matrix4();
      this.projectionMatrixInverse = new Matrix4();
      this.coordinateSystem = WebGLCoordinateSystem;
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
      this.coordinateSystem = source.coordinateSystem;
      return this;
    }
    getWorldDirection(target) {
      return super.getWorldDirection(target).negate();
    }
    updateMatrixWorld(force) {
      super.updateMatrixWorld(force);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(updateParents, updateChildren) {
      super.updateWorldMatrix(updateParents, updateChildren);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Scene extends Object3D {
    constructor() {
      super();
      this.isScene = true;
      this.type = "Scene";
      this.background = null;
      this.environment = null;
      this.fog = null;
      this.backgroundBlurriness = 0;
      this.backgroundIntensity = 1;
      this.backgroundRotation = new Euler();
      this.environmentIntensity = 1;
      this.environmentRotation = new Euler();
      this.overrideMaterial = null;
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
      }
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      if (source.background !== null) this.background = source.background.clone();
      if (source.environment !== null) this.environment = source.environment.clone();
      if (source.fog !== null) this.fog = source.fog.clone();
      this.backgroundBlurriness = source.backgroundBlurriness;
      this.backgroundIntensity = source.backgroundIntensity;
      this.backgroundRotation.copy(source.backgroundRotation);
      this.environmentIntensity = source.environmentIntensity;
      this.environmentRotation.copy(source.environmentRotation);
      if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      if (this.fog !== null) data.object.fog = this.fog.toJSON();
      if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
      if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
      data.object.backgroundRotation = this.backgroundRotation.toArray();
      if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;
      data.object.environmentRotation = this.environmentRotation.toArray();
      return data;
    }
  }
  class DataTexture extends Texture {
    constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {
      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
      this.isDataTexture = true;
      this.image = { data, width, height };
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
    }
  }
  class PlaneGeometry extends BufferGeometry {
    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
      super();
      this.type = "PlaneGeometry";
      this.parameters = {
        width,
        height,
        widthSegments,
        heightSegments
      };
      const width_half = width / 2;
      const height_half = height / 2;
      const gridX = Math.floor(widthSegments);
      const gridY = Math.floor(heightSegments);
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      const segment_width = width / gridX;
      const segment_height = height / gridY;
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segment_height - height_half;
        for (let ix = 0; ix < gridX1; ix++) {
          const x2 = ix * segment_width - width_half;
          vertices.push(x2, -y, 0);
          normals.push(0, 0, 1);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = ix + gridX1 * iy;
          const b = ix + gridX1 * (iy + 1);
          const c = ix + 1 + gridX1 * (iy + 1);
          const d = ix + 1 + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    copy(source) {
      super.copy(source);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
    static fromJSON(data) {
      return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
    }
  }
  class RawShaderMaterial extends ShaderMaterial {
    constructor(parameters) {
      super(parameters);
      this.isRawShaderMaterial = true;
      this.type = "RawShaderMaterial";
    }
  }
  class Matrix2 {
    constructor(n11, n12, n21, n22) {
      Matrix2.prototype.isMatrix2 = true;
      this.elements = [
        1,
        0,
        0,
        1
      ];
      if (n11 !== void 0) {
        this.set(n11, n12, n21, n22);
      }
    }
    identity() {
      this.set(
        1,
        0,
        0,
        1
      );
      return this;
    }
    fromArray(array, offset = 0) {
      for (let i2 = 0; i2 < 4; i2++) {
        this.elements[i2] = array[i2 + offset];
      }
      return this;
    }
    set(n11, n12, n21, n22) {
      const te = this.elements;
      te[0] = n11;
      te[2] = n12;
      te[1] = n21;
      te[3] = n22;
      return this;
    }
  }
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
      revision: REVISION
    } }));
  }
  if (typeof window !== "undefined") {
    if (window.__THREE__) {
      console.warn("WARNING: Multiple instances of Three.js being imported.");
    } else {
      window.__THREE__ = REVISION;
    }
  }
  const LN_SCALE_MIN = -9;
  const LN_SCALE_MAX = 9;
  const LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254;
  const SCALE_MIN = Math.exp(LN_SCALE_MIN);
  const SPLAT_TEX_WIDTH_BITS = 11;
  const SPLAT_TEX_HEIGHT_BITS = 11;
  const SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;
  const SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS;
  const SPLAT_TEX_MIN_HEIGHT = 1;
  const WASM_SPLAT_SORT = true;
  function isIntType(type) {
    return type === "int" || type === "ivec2" || type === "ivec3" || type === "ivec4";
  }
  function isUintType(type) {
    return type === "uint" || type === "uvec2" || type === "uvec3" || type === "uvec4";
  }
  function isFloatType(type) {
    return type === "float" || type === "vec2" || type === "vec3" || type === "vec4";
  }
  function isMatFloatType(type) {
    return type === "mat2" || type === "mat2x2" || type === "mat2x3" || type === "mat2x4" || type === "mat3" || type === "mat3x2" || type === "mat3x3" || type === "mat3x4" || type === "mat4" || type === "mat4x2" || type === "mat4x3" || type === "mat4x4";
  }
  function isAllFloatType(type) {
    return isFloatType(type) || isMatFloatType(type);
  }
  function isMat2(type) {
    return type === "mat2" || type === "mat2x2";
  }
  function isMat3(type) {
    return type === "mat3" || type === "mat3x3";
  }
  function isMat4(type) {
    return type === "mat4" || type === "mat4x4";
  }
  function numberAsInt(value) {
    return Math.trunc(value).toString();
  }
  function numberAsUint(value) {
    const v = Math.max(0, Math.trunc(value));
    return \`\${v.toString()}u\`;
  }
  function numberAsFloat(value) {
    return value === Number.POSITIVE_INFINITY ? "INFINITY" : value === Number.NEGATIVE_INFINITY ? "-INFINITY" : Number.isInteger(value) ? value.toFixed(1) : value.toString();
  }
  function valType(val) {
    if (val instanceof DynoValue) {
      return val.type;
    }
    const value = val.dynoOut();
    return value.type;
  }
  class DynoValue {
    constructor(type) {
      this.__isDynoValue = true;
      this.type = type;
    }
  }
  class DynoOutput extends DynoValue {
    constructor(dyno2, key) {
      super(dyno2.outTypes[key]);
      this.dyno = dyno2;
      this.key = key;
    }
  }
  class DynoLiteral extends DynoValue {
    constructor(type, literal) {
      super(type);
      this.literal = literal;
    }
    getLiteral() {
      return this.literal;
    }
  }
  class DynoConst extends DynoLiteral {
    constructor(type, value) {
      super(type, "");
      this.value = value;
    }
    getLiteral() {
      const { type, value } = this;
      switch (type) {
        case "bool":
          return value ? "true" : "false";
        case "uint":
          return numberAsUint(value);
        case "int":
          return numberAsInt(value);
        case "float":
          return numberAsFloat(value);
        case "bvec2": {
          const v = value;
          return \`bvec2(\${v[0]}, \${v[1]})\`;
        }
        case "uvec2": {
          if (value instanceof Vector2) {
            return \`uvec2(\${numberAsUint(value.x)}, \${numberAsUint(value.y)})\`;
          }
          const v = value;
          return \`uvec2(\${numberAsUint(v[0])}, \${numberAsUint(v[1])})\`;
        }
        case "ivec2": {
          if (value instanceof Vector2) {
            return \`ivec2(\${numberAsInt(value.x)}, \${numberAsInt(value.y)})\`;
          }
          const v = value;
          return \`ivec2(\${numberAsInt(v[0])}, \${numberAsInt(v[1])})\`;
        }
        case "vec2": {
          if (value instanceof Vector2) {
            return \`vec2(\${numberAsFloat(value.x)}, \${numberAsFloat(value.y)})\`;
          }
          const v = value;
          return \`vec2(\${numberAsFloat(v[0])}, \${numberAsFloat(v[1])})\`;
        }
        case "bvec3": {
          const v = value;
          return \`bvec3(\${v[0]}, \${v[1]}, \${v[2]})\`;
        }
        case "uvec3": {
          if (value instanceof Vector3) {
            return \`uvec3(\${numberAsUint(value.x)}, \${numberAsUint(value.y)}, \${numberAsUint(value.z)})\`;
          }
          const v = value;
          return \`uvec3(\${numberAsUint(v[0])}, \${numberAsUint(v[1])}, \${numberAsUint(v[2])})\`;
        }
        case "ivec3": {
          if (value instanceof Vector3) {
            return \`ivec3(\${numberAsInt(value.x)}, \${numberAsInt(value.y)}, \${numberAsInt(value.z)})\`;
          }
          const v = value;
          return \`ivec3(\${numberAsInt(v[0])}, \${numberAsInt(v[1])}, \${numberAsInt(v[2])})\`;
        }
        case "vec3": {
          if (value instanceof Vector3) {
            return \`vec3(\${numberAsFloat(value.x)}, \${numberAsFloat(value.y)}, \${numberAsFloat(value.z)})\`;
          }
          const v = value;
          return \`vec3(\${numberAsFloat(v[0])}, \${numberAsFloat(v[1])}, \${numberAsFloat(v[2])})\`;
        }
        case "bvec4": {
          const v = value;
          return \`bvec4(\${v[0]}, \${v[1]}, \${v[2]}, \${v[3]})\`;
        }
        case "uvec4": {
          if (value instanceof Vector4) {
            return \`uvec4(\${numberAsUint(value.x)}, \${numberAsUint(value.y)}, \${numberAsUint(value.z)}, \${numberAsUint(value.w)})\`;
          }
          const v = value;
          return \`uvec4(\${numberAsUint(v[0])}, \${numberAsUint(v[1])}, \${numberAsUint(v[2])}, \${numberAsUint(v[3])})\`;
        }
        case "ivec4": {
          if (value instanceof Vector4) {
            return \`ivec4(\${numberAsInt(value.x)}, \${numberAsInt(value.y)}, \${numberAsInt(value.z)}, \${numberAsInt(value.w)})\`;
          }
          const v = value;
          return \`ivec4(\${numberAsInt(v[0])}, \${numberAsInt(v[1])}, \${numberAsInt(v[2])}, \${numberAsInt(v[3])})\`;
        }
        case "vec4": {
          if (value instanceof Vector4) {
            return \`vec4(\${numberAsFloat(value.x)}, \${numberAsFloat(value.y)}, \${numberAsFloat(value.z)}, \${numberAsFloat(value.w)})\`;
          }
          if (value instanceof Quaternion) {
            return \`vec4(\${numberAsFloat(value.x)}, \${numberAsFloat(value.y)}, \${numberAsFloat(value.z)}, \${numberAsFloat(value.w)})\`;
          }
          const v = value;
          return \`vec4(\${numberAsFloat(v[0])}, \${numberAsFloat(v[1])}, \${numberAsFloat(v[2])}, \${numberAsFloat(v[3])})\`;
        }
        case "mat2":
        case "mat2x2": {
          const m = value;
          const e = m instanceof Matrix2 ? m.elements : value;
          const arg = new Array(4).fill(0).map((_, i2) => numberAsFloat(e[i2]));
          return \`\${type}(\${arg.join(", ")})\`;
        }
        case "mat2x3": {
          const e = value;
          const arg = new Array(6).fill(0).map((_, i2) => numberAsFloat(e[i2]));
          return \`\${type}(\${arg.join(", ")})\`;
        }
        case "mat2x4": {
          const e = value;
          const arg = new Array(8).fill(0).map((_, i2) => numberAsFloat(e[i2]));
          return \`\${type}(\${arg.join(", ")})\`;
        }
        case "mat3":
        case "mat3x3": {
          const m = value;
          const e = m instanceof Matrix3 ? m.elements : value;
          const arg = new Array(9).fill(0).map((_, i2) => numberAsFloat(e[i2]));
          return \`\${type}(\${arg.join(", ")})\`;
        }
        case "mat3x2": {
          const e = value;
          const arg = new Array(6).fill(0).map((_, i2) => numberAsFloat(e[i2]));
          return \`\${type}(\${arg.join(", ")})\`;
        }
        case "mat3x4": {
          const e = value;
          const arg = new Array(12).fill(0).map((_, i2) => numberAsFloat(e[i2]));
          return \`\${type}(\${arg.join(", ")})\`;
        }
        case "mat4":
        case "mat4x4": {
          const m = value;
          const e = m instanceof Matrix4 ? m.elements : value;
          const arg = new Array(16).fill(0).map((_, i2) => numberAsFloat(e[i2]));
          return \`\${type}(\${arg.join(", ")})\`;
        }
        case "mat4x2": {
          const e = value;
          const arg = new Array(8).fill(0).map((_, i2) => numberAsFloat(e[i2]));
          return \`\${type}(\${arg.join(", ")})\`;
        }
        case "mat4x3": {
          const e = value;
          const arg = new Array(12).fill(0).map((_, i2) => numberAsFloat(e[i2]));
          return \`\${type}(\${arg.join(", ")})\`;
        }
        default:
          throw new Error(\`Type not implemented: \${String(type)}\`);
      }
    }
  }
  function dynoConst(type, value) {
    return new DynoConst(type, value);
  }
  const DEFAULT_INDENT = "    ";
  class Compilation {
    constructor({ indent } = {}) {
      this.globals = /* @__PURE__ */ new Set();
      this.statements = [];
      this.uniforms = {};
      this.declares = /* @__PURE__ */ new Set();
      this.updaters = [];
      this.sequence = 0;
      this.indent = DEFAULT_INDENT;
      this.indent = indent ?? DEFAULT_INDENT;
    }
    nextSequence() {
      return this.sequence++;
    }
  }
  class Dyno {
    constructor({
      inTypes,
      outTypes,
      inputs,
      update,
      globals,
      statements,
      generate
    }) {
      this.inTypes = inTypes ?? {};
      this.outTypes = outTypes ?? {};
      this.inputs = inputs ?? {};
      this.update = update;
      this.globals = globals;
      this.statements = statements;
      this.generate = generate ?? (({ inputs: inputs2, outputs, compile }) => {
        var _a2, _b2;
        return {
          globals: (_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs: inputs2, outputs, compile }),
          statements: (_b2 = this.statements) == null ? void 0 : _b2.call(this, { inputs: inputs2, outputs, compile })
        };
      });
    }
    get outputs() {
      const outputs = {};
      for (const key in this.outTypes) {
        outputs[key] = new DynoOutput(this, key);
      }
      return outputs;
    }
    apply(inputs) {
      Object.assign(this.inputs, inputs);
      return this.outputs;
    }
    compile({
      inputs,
      outputs,
      compile
    }) {
      const result = [
        \`// \${this.constructor.name}(\${Object.values(inputs).join(", ")}) => (\${Object.values(outputs).join(", ")})\`
      ];
      const declares = [];
      for (const key in outputs) {
        const name = outputs[key];
        if (name && !compile.declares.has(name)) {
          compile.declares.add(name);
          declares.push(key);
        }
      }
      const { globals, statements, uniforms } = this.generate({
        inputs,
        outputs,
        compile
      });
      for (const global of globals ?? []) {
        compile.globals.add(global);
      }
      for (const key in uniforms) {
        compile.uniforms[key] = uniforms[key];
      }
      if (this.update) {
        compile.updaters.push(this.update);
      }
      for (const key of declares) {
        const name = outputs[key];
        if (name) {
          if (!compile.uniforms[name]) {
            result.push(\`\${dynoDeclare(name, this.outTypes[key])};\`);
          }
        }
      }
      if (statements == null ? void 0 : statements.length) {
        result.push("{");
        result.push(...statements.map((line) => compile.indent + line));
        result.push("}");
      }
      return result;
    }
  }
  class DynoBlock extends Dyno {
    constructor({
      inTypes,
      outTypes,
      inputs,
      update,
      globals,
      construct
    }) {
      super({
        inTypes,
        outTypes,
        inputs,
        update,
        globals,
        generate: (args) => this.generateBlock(args)
      });
      this.construct = construct;
    }
    generateBlock({
      inputs,
      outputs,
      compile
    }) {
      var _a2, _b2;
      const blockInputs = {};
      const blockOutputs = {};
      for (const key in inputs) {
        if (inputs[key] != null) {
          blockInputs[key] = new DynoLiteral(this.inTypes[key], inputs[key]);
        }
      }
      for (const key in outputs) {
        if (outputs[key] != null) {
          blockOutputs[key] = new DynoValue(this.outTypes[key]);
        }
      }
      const options = { roots: [] };
      const returned = this.construct(blockInputs, blockOutputs, options);
      for (const global of ((_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs, outputs, compile })) ?? []) {
        compile.globals.add(global);
      }
      const ordering = [];
      const nodeOuts = /* @__PURE__ */ new Map();
      function visit(node, outKey, outName) {
        let outs = nodeOuts.get(node);
        if (!outs) {
          outs = {
            sequence: compile.nextSequence(),
            outNames: /* @__PURE__ */ new Map(),
            newOuts: /* @__PURE__ */ new Set()
          };
          nodeOuts.set(node, outs);
          for (const key in node.inputs) {
            let input = node.inputs[key];
            while (input) {
              if (input instanceof DynoValue) {
                if (input instanceof DynoOutput) {
                  visit(input.dyno, input.key);
                }
                break;
              }
              input = input.dynoOut();
            }
          }
          ordering.push(node);
        }
        if (outKey) {
          if (!outName) {
            outs.newOuts.add(outKey);
          }
          outs.outNames.set(outKey, outName ?? \`\${outKey}_\${outs.sequence}\`);
        }
      }
      for (const root of options.roots) {
        visit(root);
      }
      for (const key in blockOutputs) {
        let value = (returned == null ? void 0 : returned[key]) ?? blockOutputs[key];
        while (value) {
          if (value instanceof DynoValue) {
            if (value instanceof DynoOutput) {
              visit(value.dyno, value.key, outputs[key]);
            }
            break;
          }
          value = value.dynoOut();
        }
        blockOutputs[key] = value;
      }
      const steps = [];
      for (const dyno2 of ordering) {
        const inputs2 = {};
        const outputs2 = {};
        for (const key in dyno2.inputs) {
          let value = dyno2.inputs[key];
          while (value) {
            if (value instanceof DynoValue) {
              if (value instanceof DynoLiteral) {
                inputs2[key] = value.getLiteral();
              } else if (value instanceof DynoOutput) {
                const source = (_b2 = nodeOuts.get(value.dyno)) == null ? void 0 : _b2.outNames.get(value.key);
                if (!source) {
                  throw new Error(
                    \`Source not found for \${value.dyno.constructor.name}.\${value.key}\`
                  );
                }
                inputs2[key] = source;
              }
              break;
            }
            value = value.dynoOut();
          }
        }
        const outs = nodeOuts.get(dyno2) ?? { outNames: /* @__PURE__ */ new Map() };
        for (const [key, name] of outs.outNames.entries()) {
          outputs2[key] = name;
        }
        const newSteps = dyno2.compile({ inputs: inputs2, outputs: outputs2, compile });
        steps.push(newSteps);
      }
      const literalOutputs = [];
      for (const key in outputs) {
        if (blockOutputs[key] instanceof DynoLiteral) {
          literalOutputs.push(
            \`\${outputs[key]} = \${blockOutputs[key].getLiteral()};\`
          );
        }
      }
      if (literalOutputs.length > 0) {
        steps.push(literalOutputs);
      }
      const statements = steps.flatMap((step, index) => {
        return index === 0 ? step : ["", ...step];
      });
      return { statements };
    }
  }
  function dynoBlock(inTypes, outTypes, construct, { update, globals } = {}) {
    return new DynoBlock({ inTypes, outTypes, construct, update, globals });
  }
  function dyno({
    inTypes,
    outTypes,
    inputs,
    update,
    globals,
    statements,
    generate
  }) {
    return new Dyno({
      inTypes,
      outTypes,
      inputs,
      update,
      globals,
      statements,
      generate
    });
  }
  function dynoDeclare(name, type, count) {
    const typeStr = typeof type === "string" ? type : type.type;
    if (!typeStr) {
      throw new Error(\`Invalid DynoType: \${String(type)}\`);
    }
    return \`\${typeStr} \${name}\${count != null ? \`[\${count}]\` : ""}\`;
  }
  function unindentLines(s) {
    var _a2;
    let seenNonEmpty = false;
    const lines = s.split("\\n").map((line) => {
      const trimmedLine = line.trimEnd();
      if (seenNonEmpty) {
        return trimmedLine;
      }
      if (trimmedLine.length > 0) {
        seenNonEmpty = true;
        return trimmedLine;
      }
      return null;
    }).filter((line) => line != null);
    while (lines.length > 0 && lines[lines.length - 1].length === 0) {
      lines.pop();
    }
    if (lines.length === 0) {
      return [];
    }
    const indent = (_a2 = lines[0].match(/^\\s*/)) == null ? void 0 : _a2[0];
    if (!indent) {
      return lines;
    }
    const regex = new RegExp(\`^\${indent}\`);
    return lines.map((line) => line.replace(regex, ""));
  }
  function unindent(s) {
    return unindentLines(s).join("\\n");
  }
  class UnaryOp extends Dyno {
    constructor({
      a,
      outKey,
      outTypeFunc
    }) {
      const inTypes = { a: valType(a) };
      const outType = outTypeFunc(valType(a));
      const outTypes = { [outKey]: outType };
      super({ inTypes, outTypes, inputs: { a } });
      this.outKey = outKey;
    }
    dynoOut() {
      return new DynoOutput(this, this.outKey);
    }
  }
  class BinaryOp extends Dyno {
    constructor({
      a,
      b,
      outKey,
      outTypeFunc
    }) {
      const inTypes = { a: valType(a), b: valType(b) };
      const outType = outTypeFunc(valType(a), valType(b));
      const outTypes = { [outKey]: outType };
      super({ inTypes, outTypes, inputs: { a, b } });
      this.outKey = outKey;
    }
    dynoOut() {
      return new DynoOutput(this, this.outKey);
    }
  }
  const f32buffer = new Float32Array(1);
  const u32buffer = new Uint32Array(f32buffer.buffer);
  function toHalf(f) {
    f32buffer[0] = f;
    const bits2 = u32buffer[0];
    const sign = bits2 >> 31 & 1;
    const exp = bits2 >> 23 & 255;
    const frac = bits2 & 8388607;
    const halfSign = sign << 15;
    if (exp === 255) {
      if (frac !== 0) {
        return halfSign | 32767;
      }
      return halfSign | 31744;
    }
    const newExp = exp - 127 + 15;
    if (newExp >= 31) {
      return halfSign | 31744;
    }
    if (newExp <= 0) {
      if (newExp < -10) {
        return halfSign;
      }
      const subFrac = (frac | 8388608) >> 1 - newExp + 13;
      return halfSign | subFrac;
    }
    const halfFrac = frac >> 13;
    return halfSign | newExp << 10 | halfFrac;
  }
  function fromHalf(h) {
    const sign = h >> 15 & 1;
    const exp = h >> 10 & 31;
    const frac = h & 1023;
    let f32bits;
    if (exp === 0) {
      if (frac === 0) {
        f32bits = sign << 31;
      } else {
        let mant = frac;
        let e = -14;
        while ((mant & 1024) === 0) {
          mant <<= 1;
          e--;
        }
        mant &= 1023;
        const newExp = e + 127;
        const newFrac = mant << 13;
        f32bits = sign << 31 | newExp << 23 | newFrac;
      }
    } else if (exp === 31) {
      if (frac === 0) {
        f32bits = sign << 31 | 2139095040;
      } else {
        f32bits = sign << 31 | 2143289344;
      }
    } else {
      const newExp = exp - 15 + 127;
      const newFrac = frac << 13;
      f32bits = sign << 31 | newExp << 23 | newFrac;
    }
    u32buffer[0] = f32bits;
    return f32buffer[0];
  }
  function floatToUint8(v) {
    return Math.max(0, Math.min(255, Math.round(v * 255)));
  }
  function getArrayBuffers(ctx) {
    const buffers = [];
    const seen = /* @__PURE__ */ new Set();
    function traverse(obj) {
      if (obj && typeof obj === "object" && !seen.has(obj)) {
        seen.add(obj);
        if (obj instanceof ArrayBuffer) {
          buffers.push(obj);
        } else if (ArrayBuffer.isView(obj)) {
          buffers.push(obj.buffer);
        } else if (Array.isArray(obj)) {
          obj.forEach(traverse);
        } else {
          Object.values(obj).forEach(traverse);
        }
      }
    }
    traverse(ctx);
    return buffers;
  }
  function setPackedSplat(packedSplats, index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) {
    const uR = floatToUint8(r);
    const uG = floatToUint8(g);
    const uB = floatToUint8(b);
    const uA = floatToUint8(opacity);
    const uQuat = encodeQuatOctXy88R8(
      new Quaternion(quatX, quatY, quatZ, quatW)
    );
    const uQuatX = uQuat & 255;
    const uQuatY = uQuat >>> 8 & 255;
    const uQuatZ = uQuat >>> 16 & 255;
    const uScaleX = scaleX === 0 ? 0 : Math.min(
      255,
      Math.max(
        0,
        Math.round((Math.log(scaleX) - LN_SCALE_MIN) / LN_RESCALE) + 1
      )
    );
    const uScaleY = scaleY === 0 ? 0 : Math.min(
      255,
      Math.max(
        0,
        Math.round((Math.log(scaleY) - LN_SCALE_MIN) / LN_RESCALE) + 1
      )
    );
    const uScaleZ = scaleZ === 0 ? 0 : Math.min(
      255,
      Math.max(
        0,
        Math.round((Math.log(scaleZ) - LN_SCALE_MIN) / LN_RESCALE) + 1
      )
    );
    const uCenterX = toHalf(x2);
    const uCenterY = toHalf(y);
    const uCenterZ = toHalf(z);
    const i4 = index * 4;
    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;
    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;
    packedSplats[i4 + 2] = uCenterZ | uQuatX << 16 | uQuatY << 24;
    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;
  }
  function setPackedSplatCenter(packedSplats, index, x2, y, z) {
    const uCenterX = toHalf(x2);
    const uCenterY = toHalf(y);
    const uCenterZ = toHalf(z);
    const i4 = index * 4;
    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;
    packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & 4294901760;
  }
  function setPackedSplatScales(packedSplats, index, scaleX, scaleY, scaleZ) {
    const uScaleX = scaleX === 0 ? 0 : Math.min(
      255,
      Math.max(
        0,
        Math.round((Math.log(scaleX) - LN_SCALE_MIN) / LN_RESCALE) + 1
      )
    );
    const uScaleY = scaleY === 0 ? 0 : Math.min(
      255,
      Math.max(
        0,
        Math.round((Math.log(scaleY) - LN_SCALE_MIN) / LN_RESCALE) + 1
      )
    );
    const uScaleZ = scaleZ === 0 ? 0 : Math.min(
      255,
      Math.max(
        0,
        Math.round((Math.log(scaleZ) - LN_SCALE_MIN) / LN_RESCALE) + 1
      )
    );
    const i4 = index * 4;
    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;
  }
  function setPackedSplatQuat(packedSplats, index, quatX, quatY, quatZ, quatW) {
    const uQuat = encodeQuatOctXy88R8(
      new Quaternion(quatX, quatY, quatZ, quatW)
    );
    const uQuatX = uQuat & 255;
    const uQuatY = uQuat >>> 8 & 255;
    const uQuatZ = uQuat >>> 16 & 255;
    const i4 = index * 4;
    packedSplats[i4 + 2] = packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;
    packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;
  }
  function setPackedSplatRgb(packedSplats, index, r, g, b) {
    const uR = floatToUint8(r);
    const uG = floatToUint8(g);
    const uB = floatToUint8(b);
    const i4 = index * 4;
    packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & 4278190080;
  }
  function setPackedSplatOpacity(packedSplats, index, opacity) {
    const uA = floatToUint8(opacity);
    const i4 = index * 4;
    packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;
  }
  const packedCenter = new Vector3();
  const packedScales = new Vector3();
  const packedQuaternion = new Quaternion();
  const packedColor = new Color();
  const packedFields = {
    center: packedCenter,
    scales: packedScales,
    quaternion: packedQuaternion,
    color: packedColor,
    opacity: 0
  };
  function unpackSplat(packedSplats, index) {
    const result = packedFields;
    const i4 = index * 4;
    const word0 = packedSplats[i4];
    const word1 = packedSplats[i4 + 1];
    const word2 = packedSplats[i4 + 2];
    const word3 = packedSplats[i4 + 3];
    result.color.set(
      (word0 & 255) / 255,
      (word0 >>> 8 & 255) / 255,
      (word0 >>> 16 & 255) / 255
    );
    result.opacity = (word0 >>> 24 & 255) / 255;
    result.center.set(
      fromHalf(word1 & 65535),
      fromHalf(word1 >>> 16 & 65535),
      fromHalf(word2 & 65535)
    );
    const uScalesX = word3 & 255;
    result.scales.x = uScalesX === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesX - 1) * LN_RESCALE);
    const uScalesY = word3 >>> 8 & 255;
    result.scales.y = uScalesY === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesY - 1) * LN_RESCALE);
    const uScalesZ = word3 >>> 16 & 255;
    result.scales.z = uScalesZ === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesZ - 1) * LN_RESCALE);
    const uQuat = word2 >>> 16 & 65535 | word3 >>> 8 & 16711680;
    decodeQuatOctXy88R8(uQuat, result.quaternion);
    return result;
  }
  function getTextureSize(numSplats) {
    const width = SPLAT_TEX_WIDTH;
    const height = Math.max(
      SPLAT_TEX_MIN_HEIGHT,
      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))
    );
    const depth = Math.ceil(numSplats / (width * height));
    const maxSplats = width * height * depth;
    return { width, height, depth, maxSplats };
  }
  function computeMaxSplats(numSplats) {
    const width = SPLAT_TEX_WIDTH;
    const height = Math.max(
      SPLAT_TEX_MIN_HEIGHT,
      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))
    );
    const depth = Math.ceil(numSplats / (width * height));
    return width * height * depth;
  }
  const IDENT_VERTEX_SHADER = unindent(\`
  precision highp float;

  in vec3 position;

  void main() {
    gl_Position = vec4(position.xy, 0.0, 1.0);
  }
\`);
  function encodeQuatOctXy88R8(q) {
    const qnorm = q.clone().normalize();
    if (qnorm.w < 0) {
      qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);
    }
    const theta = 2 * Math.acos(qnorm.w);
    const xyz_norm = Math.sqrt(
      qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z
    );
    const axis = xyz_norm < 1e-6 ? new Vector3(1, 0, 0) : new Vector3(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);
    const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);
    let p_x = axis.x / sum;
    let p_y = axis.y / sum;
    if (axis.z < 0) {
      const tmp = p_x;
      p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);
      p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);
    }
    const u_f = p_x * 0.5 + 0.5;
    const v_f = p_y * 0.5 + 0.5;
    const quantU = Math.round(u_f * 255);
    const quantV = Math.round(v_f * 255);
    const angleInt = Math.round(theta * (255 / Math.PI));
    return angleInt << 16 | quantV << 8 | quantU;
  }
  function decodeQuatOctXy88R8(encoded, out) {
    const quantU = encoded & 255;
    const quantV = encoded >>> 8 & 255;
    const angleInt = encoded >>> 16 & 255;
    const u_f = quantU / 255;
    const v_f = quantV / 255;
    let f_x = (u_f - 0.5) * 2;
    let f_y = (v_f - 0.5) * 2;
    const f_z = 1 - (Math.abs(f_x) + Math.abs(f_y));
    const t = Math.max(-f_z, 0);
    f_x += f_x >= 0 ? -t : t;
    f_y += f_y >= 0 ? -t : t;
    const axis = new Vector3(f_x, f_y, f_z).normalize();
    const theta = angleInt / 255 * Math.PI;
    const halfTheta = theta * 0.5;
    const s = Math.sin(halfTheta);
    const w = Math.cos(halfTheta);
    out.set(axis.x * s, axis.y * s, axis.z * s, w);
    return out;
  }
  function packSint8Bytes(b0, b1, b2, b3) {
    const clampedB0 = Math.max(-127, Math.min(127, b0 * 127));
    const clampedB1 = Math.max(-127, Math.min(127, b1 * 127));
    const clampedB2 = Math.max(-127, Math.min(127, b2 * 127));
    const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));
    return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << 24;
  }
  function encodeSh1Rgb(sh1Array, index, sh1Rgb) {
    const base = index * 2;
    for (let i2 = 0; i2 < 9; ++i2) {
      const value = Math.max(-63, Math.min(63, sh1Rgb[i2] * 63)) & 127;
      const bitStart = i2 * 7;
      const bitEnd = bitStart + 7;
      const wordStart = Math.floor(bitStart / 32);
      const bitOffset = bitStart - wordStart * 32;
      const firstWord = value << bitOffset & 4294967295;
      sh1Array[base + wordStart] |= firstWord;
      if (bitEnd > wordStart * 32 + 32) {
        const secondWord = value >>> 32 - bitOffset & 4294967295;
        sh1Array[base + wordStart + 1] |= secondWord;
      }
    }
  }
  function encodeSh2Rgb(sh2Array, index, sh2Rgb) {
    sh2Array[index * 4 + 0] = packSint8Bytes(
      sh2Rgb[0],
      sh2Rgb[1],
      sh2Rgb[2],
      sh2Rgb[3]
    );
    sh2Array[index * 4 + 1] = packSint8Bytes(
      sh2Rgb[4],
      sh2Rgb[5],
      sh2Rgb[6],
      sh2Rgb[7]
    );
    sh2Array[index * 4 + 2] = packSint8Bytes(
      sh2Rgb[8],
      sh2Rgb[9],
      sh2Rgb[10],
      sh2Rgb[11]
    );
    sh2Array[index * 4 + 3] = packSint8Bytes(
      sh2Rgb[12],
      sh2Rgb[13],
      sh2Rgb[14],
      0
    );
  }
  function encodeSh3Rgb(sh3Array, index, sh3Rgb) {
    const base = index * 4;
    for (let i2 = 0; i2 < 21; ++i2) {
      const value = Math.max(-31, Math.min(31, sh3Rgb[i2] * 31)) & 63;
      const bitStart = i2 * 6;
      const bitEnd = bitStart + 6;
      const wordStart = Math.floor(bitStart / 32);
      const bitOffset = bitStart - wordStart * 32;
      const firstWord = value << bitOffset & 4294967295;
      sh3Array[base + wordStart] |= firstWord;
      if (bitEnd > wordStart * 32 + 32) {
        const secondWord = value >>> 32 - bitOffset & 4294967295;
        sh3Array[base + wordStart + 1] |= secondWord;
      }
    }
  }
  function decompressPartialGzip(fileBytes, numBytes) {
    const chunks = [];
    let totalBytes = 0;
    let result = null;
    const gunzip = new Gunzip((data, final) => {
      chunks.push(data);
      totalBytes += data.length;
      if (final || totalBytes >= numBytes) {
        const allBytes = new Uint8Array(totalBytes);
        let offset2 = 0;
        for (const chunk of chunks) {
          allBytes.set(chunk, offset2);
          offset2 += chunk.length;
        }
        result = allBytes.slice(0, numBytes);
      }
    });
    const CHUNK_SIZE = 1024;
    let offset = 0;
    while (result == null && offset < fileBytes.length) {
      const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);
      gunzip.push(chunk, false);
      offset += CHUNK_SIZE;
    }
    if (result == null) {
      gunzip.push(new Uint8Array(), true);
      if (result == null) {
        throw new Error("Failed to decompress partial gzip");
      }
    }
    return result;
  }
  class GunzipReader {
    constructor({
      fileBytes,
      chunkBytes = 64 * 1024
    }) {
      this.fileBytes = fileBytes;
      this.chunkBytes = chunkBytes;
      this.offset = 0;
      this.chunks = [];
      this.totalBytes = 0;
      this.gunzip = new Gunzip((chunk, _final) => {
        this.chunks.push(chunk);
        this.totalBytes += chunk.length;
      });
    }
    read(numBytes) {
      while (this.totalBytes < numBytes && this.offset < this.fileBytes.length) {
        const end = Math.min(
          this.offset + this.chunkBytes,
          this.fileBytes.length
        );
        this.gunzip.push(this.fileBytes.subarray(this.offset, end), false);
        this.offset = end;
      }
      if (this.totalBytes < numBytes && this.offset >= this.fileBytes.length) {
        this.gunzip.push(new Uint8Array(0), true);
      }
      if (this.totalBytes < numBytes) {
        throw new Error(
          \`Unexpected EOF: needed \${numBytes}, got \${this.totalBytes}\`
        );
      }
      const allBytes = new Uint8Array(this.totalBytes);
      let outOffset = 0;
      for (const chunk of this.chunks) {
        allBytes.set(chunk, outOffset);
        outOffset += chunk.length;
      }
      const result = allBytes.subarray(0, numBytes);
      this.chunks = [allBytes.subarray(numBytes)];
      this.totalBytes -= numBytes;
      return result;
    }
  }
  function decodeAntiSplat(fileBytes, initNumSplats, splatCallback) {
    const numSplats = Math.floor(fileBytes.length / 32);
    if (numSplats * 32 !== fileBytes.length) {
      throw new Error("Invalid .splat file size");
    }
    initNumSplats(numSplats);
    const f32 = new Float32Array(fileBytes.buffer);
    for (let i2 = 0; i2 < numSplats; ++i2) {
      const i322 = i2 * 32;
      const i8 = i2 * 8;
      const x2 = f32[i8 + 0];
      const y = f32[i8 + 1];
      const z = f32[i8 + 2];
      const scaleX = f32[i8 + 3];
      const scaleY = f32[i8 + 4];
      const scaleZ = f32[i8 + 5];
      const r = fileBytes[i322 + 24] / 255;
      const g = fileBytes[i322 + 25] / 255;
      const b = fileBytes[i322 + 26] / 255;
      const opacity = fileBytes[i322 + 27] / 255;
      const quatW = (fileBytes[i322 + 28] - 128) / 128;
      const quatX = (fileBytes[i322 + 29] - 128) / 128;
      const quatY = (fileBytes[i322 + 30] - 128) / 128;
      const quatZ = (fileBytes[i322 + 31] - 128) / 128;
      splatCallback(
        i2,
        x2,
        y,
        z,
        scaleX,
        scaleY,
        scaleZ,
        quatX,
        quatY,
        quatZ,
        quatW,
        opacity,
        r,
        g,
        b
      );
    }
  }
  function unpackAntiSplat(fileBytes) {
    let numSplats = 0;
    let maxSplats = 0;
    let packedArray = new Uint32Array(0);
    decodeAntiSplat(
      fileBytes,
      (cbNumSplats) => {
        numSplats = cbNumSplats;
        maxSplats = computeMaxSplats(numSplats);
        packedArray = new Uint32Array(maxSplats * 4);
      },
      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
        setPackedSplat(
          packedArray,
          index,
          x2,
          y,
          z,
          scaleX,
          scaleY,
          scaleZ,
          quatX,
          quatY,
          quatZ,
          quatW,
          opacity,
          r,
          g,
          b
        );
      }
    );
    return { packedArray, numSplats };
  }
  const KSPLAT_COMPRESSION = {
    0: {
      bytesPerCenter: 12,
      bytesPerScale: 12,
      bytesPerRotation: 16,
      bytesPerColor: 4,
      bytesPerSphericalHarmonicsComponent: 4,
      scaleOffsetBytes: 12,
      rotationOffsetBytes: 24,
      colorOffsetBytes: 40,
      sphericalHarmonicsOffsetBytes: 44,
      scaleRange: 1
    },
    1: {
      bytesPerCenter: 6,
      bytesPerScale: 6,
      bytesPerRotation: 8,
      bytesPerColor: 4,
      bytesPerSphericalHarmonicsComponent: 2,
      scaleOffsetBytes: 6,
      rotationOffsetBytes: 12,
      colorOffsetBytes: 20,
      sphericalHarmonicsOffsetBytes: 24,
      scaleRange: 32767
    },
    2: {
      bytesPerCenter: 6,
      bytesPerScale: 6,
      bytesPerRotation: 8,
      bytesPerColor: 4,
      bytesPerSphericalHarmonicsComponent: 1,
      scaleOffsetBytes: 6,
      rotationOffsetBytes: 12,
      colorOffsetBytes: 20,
      sphericalHarmonicsOffsetBytes: 24,
      scaleRange: 32767
    }
  };
  const KSPLAT_SH_DEGREE_TO_COMPONENTS = {
    0: 0,
    1: 9,
    2: 24,
    3: 45
  };
  function decodeKsplat(fileBytes, initNumSplats, splatCallback, shCallback) {
    var _a2;
    const HEADER_BYTES = 4096;
    const SECTION_BYTES = 1024;
    let headerOffset = 0;
    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);
    headerOffset += HEADER_BYTES;
    const versionMajor = header.getUint8(0);
    const versionMinor = header.getUint8(1);
    if (versionMajor !== 0 || versionMinor < 1) {
      throw new Error(
        \`Unsupported .ksplat version: \${versionMajor}.\${versionMinor}\`
      );
    }
    const maxSectionCount = header.getUint32(4, true);
    header.getUint32(16, true);
    const compressionLevel = header.getUint16(20, true);
    if (compressionLevel < 0 || compressionLevel > 2) {
      throw new Error(\`Invalid .ksplat compression level: \${compressionLevel}\`);
    }
    header.getFloat32(36, true) || -1.5;
    header.getFloat32(40, true) || 1.5;
    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;
    for (let section = 0; section < maxSectionCount; ++section) {
      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);
      headerOffset += SECTION_BYTES;
      const sectionSplatCount = section2.getUint32(0, true);
      const sectionMaxSplatCount = section2.getUint32(4, true);
      const bucketSize = section2.getUint32(8, true);
      const bucketCount = section2.getUint32(12, true);
      const bucketBlockSize = section2.getFloat32(16, true);
      const bucketStorageSizeBytes = section2.getUint16(20, true);
      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;
      const partiallyFilledBucketCount = section2.getUint32(36, true);
      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;
      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;
      const sphericalHarmonicsDegree = section2.getUint16(40, true);
      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];
      const {
        bytesPerCenter,
        bytesPerScale,
        bytesPerRotation,
        bytesPerColor,
        bytesPerSphericalHarmonicsComponent,
        scaleOffsetBytes,
        rotationOffsetBytes,
        colorOffsetBytes,
        sphericalHarmonicsOffsetBytes
      } = KSPLAT_COMPRESSION[compressionLevel];
      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;
      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;
      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;
      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;
      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;
      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;
      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;
      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;
      const dataBase = sectionBase + bucketsStorageSizeBytes;
      const data = new DataView(
        fileBytes.buffer,
        dataBase,
        splatDataStorageSizeBytes
      );
      const bucketArray = new Float32Array(
        fileBytes.buffer,
        bucketsBase,
        bucketCount * 3
      );
      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {
        const splatOffset = i2 * bytesPerSplat;
        const bucketIndex = Math.floor(i2 / bucketSize);
        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];
        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];
        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];
        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));
        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));
        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));
        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)
        );
        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)
        );
        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)
        );
        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)
        );
        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;
        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;
        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;
        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;
        splatCallback(
          i2,
          x2,
          y,
          z,
          scaleX,
          scaleY,
          scaleZ,
          quatX,
          quatY,
          quatZ,
          quatW,
          opacity,
          r,
          g,
          b
        );
        if (sphericalHarmonicsDegree >= 1 && sh1) {
          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);
        }
      }
      sectionBase += storageSizeBytes;
    }
  }
  function unpackKsplat(fileBytes) {
    var _a2;
    const HEADER_BYTES = 4096;
    const SECTION_BYTES = 1024;
    let headerOffset = 0;
    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);
    headerOffset += HEADER_BYTES;
    const versionMajor = header.getUint8(0);
    const versionMinor = header.getUint8(1);
    if (versionMajor !== 0 || versionMinor < 1) {
      throw new Error(
        \`Unsupported .ksplat version: \${versionMajor}.\${versionMinor}\`
      );
    }
    const maxSectionCount = header.getUint32(4, true);
    const splatCount = header.getUint32(16, true);
    const compressionLevel = header.getUint16(20, true);
    if (compressionLevel < 0 || compressionLevel > 2) {
      throw new Error(\`Invalid .ksplat compression level: \${compressionLevel}\`);
    }
    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;
    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;
    const numSplats = splatCount;
    const maxSplats = computeMaxSplats(numSplats);
    const packedArray = new Uint32Array(maxSplats * 4);
    const extra = {};
    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;
    for (let section = 0; section < maxSectionCount; ++section) {
      let getSh = function(splatOffset, component) {
        if (compressionLevel === 0) {
          return data.getFloat32(
            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,
            true
          );
        }
        if (compressionLevel === 1) {
          return fromHalf(
            data.getUint16(
              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,
              true
            )
          );
        }
        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;
        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);
      };
      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);
      headerOffset += SECTION_BYTES;
      const sectionSplatCount = section2.getUint32(0, true);
      const sectionMaxSplatCount = section2.getUint32(4, true);
      const bucketSize = section2.getUint32(8, true);
      const bucketCount = section2.getUint32(12, true);
      const bucketBlockSize = section2.getFloat32(16, true);
      const bucketStorageSizeBytes = section2.getUint16(20, true);
      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;
      const partiallyFilledBucketCount = section2.getUint32(36, true);
      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;
      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;
      const sphericalHarmonicsDegree = section2.getUint16(40, true);
      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];
      const {
        bytesPerCenter,
        bytesPerScale,
        bytesPerRotation,
        bytesPerColor,
        bytesPerSphericalHarmonicsComponent,
        scaleOffsetBytes,
        rotationOffsetBytes,
        colorOffsetBytes,
        sphericalHarmonicsOffsetBytes
      } = KSPLAT_COMPRESSION[compressionLevel];
      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;
      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;
      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;
      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];
      const sh2Index = [
        9,
        14,
        19,
        10,
        15,
        20,
        11,
        16,
        21,
        12,
        17,
        22,
        13,
        18,
        23
      ];
      const sh3Index = [
        24,
        31,
        38,
        25,
        32,
        39,
        26,
        33,
        40,
        27,
        34,
        41,
        28,
        35,
        42,
        29,
        36,
        43,
        30,
        37,
        44
      ];
      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;
      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;
      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;
      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;
      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;
      const dataBase = sectionBase + bucketsStorageSizeBytes;
      const data = new DataView(
        fileBytes.buffer,
        dataBase,
        splatDataStorageSizeBytes
      );
      const bucketArray = new Float32Array(
        fileBytes.buffer,
        bucketsBase,
        bucketCount * 3
      );
      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {
        const splatOffset = i2 * bytesPerSplat;
        const bucketIndex = Math.floor(i2 / bucketSize);
        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];
        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];
        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];
        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));
        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));
        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));
        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)
        );
        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)
        );
        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)
        );
        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)
        );
        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;
        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;
        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;
        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;
        setPackedSplat(
          packedArray,
          i2,
          x2,
          y,
          z,
          scaleX,
          scaleY,
          scaleZ,
          quatX,
          quatY,
          quatZ,
          quatW,
          opacity,
          r,
          g,
          b
        );
        if (sphericalHarmonicsDegree >= 1) {
          if (sh1) {
            if (!extra.sh1) {
              extra.sh1 = new Uint32Array(numSplats * 2);
            }
            for (const [i22, key] of sh1Index.entries()) {
              sh1[i22] = getSh(splatOffset, key);
            }
            encodeSh1Rgb(extra.sh1, i2, sh1);
          }
          if (sh2) {
            if (!extra.sh2) {
              extra.sh2 = new Uint32Array(numSplats * 4);
            }
            for (const [i22, key] of sh2Index.entries()) {
              sh2[i22] = getSh(splatOffset, key);
            }
            encodeSh2Rgb(extra.sh2, i2, sh2);
          }
          if (sh3) {
            if (!extra.sh3) {
              extra.sh3 = new Uint32Array(numSplats * 4);
            }
            for (const [i22, key] of sh3Index.entries()) {
              sh3[i22] = getSh(splatOffset, key);
            }
            encodeSh3Rgb(extra.sh3, i2, sh3);
          }
        }
      }
      sectionBase += storageSizeBytes;
    }
    return { packedArray, numSplats, extra };
  }
  const _PlyReader = class _PlyReader {
    // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet
    constructor({ fileBytes }) {
      this.header = "";
      this.littleEndian = true;
      this.elements = {};
      this.comments = [];
      this.data = null;
      this.numSplats = 0;
      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;
    }
    // Identify and parse the PLY text header (assumed to be <64KB in size).
    // this.elements will contain all the elements in the file, typically
    // "vertex" contains the Gsplat data.
    async parseHeader() {
      const bufferStream = new ReadableStream({
        start: (controller) => {
          controller.enqueue(this.fileBytes.slice(0, 65536));
          controller.close();
        }
      });
      const decoder = bufferStream.pipeThrough(new TextDecoderStream()).getReader();
      this.header = "";
      const headerTerminator = "end_header\\n";
      while (true) {
        const { value, done } = await decoder.read();
        if (done) {
          throw new Error("Failed to read header");
        }
        this.header += value;
        const endHeader = this.header.indexOf(headerTerminator);
        if (endHeader >= 0) {
          this.header = this.header.slice(0, endHeader + headerTerminator.length);
          break;
        }
      }
      const headerLen = new TextEncoder().encode(this.header).length;
      this.data = new DataView(this.fileBytes.buffer, headerLen);
      this.elements = {};
      let curElement = null;
      this.comments = [];
      this.header.trim().split("\\n").forEach((line, lineIndex) => {
        const trimmedLine = line.trim();
        if (lineIndex === 0) {
          if (trimmedLine !== "ply") {
            throw new Error("Invalid PLY header");
          }
          return;
        }
        if (trimmedLine.length === 0) {
          return;
        }
        const fields = trimmedLine.split(" ");
        switch (fields[0]) {
          case "format":
            if (fields[1] === "binary_little_endian") {
              this.littleEndian = true;
            } else if (fields[1] === "binary_big_endian") {
              this.littleEndian = false;
            } else {
              throw new Error(\`Unsupported PLY format: \${fields[1]}\`);
            }
            if (fields[2] !== "1.0") {
              throw new Error(\`Unsupported PLY version: \${fields[2]}\`);
            }
            break;
          case "end_header":
            break;
          case "comment":
            this.comments.push(trimmedLine.slice("comment ".length));
            break;
          case "element": {
            const name = fields[1];
            curElement = {
              name,
              count: Number.parseInt(fields[2]),
              properties: {}
            };
            this.elements[name] = curElement;
            break;
          }
          case "property":
            if (curElement == null) {
              throw new Error("Property must be inside an element");
            }
            if (fields[1] === "list") {
              curElement.properties[fields[4]] = {
                isList: true,
                type: fields[3],
                countType: fields[2]
              };
            } else {
              curElement.properties[fields[2]] = {
                isList: false,
                type: fields[1]
              };
            }
            break;
        }
      });
      if (this.elements.vertex) {
        this.numSplats = this.elements.vertex.count;
      }
    }
    parseData(elementCallback) {
      let offset = 0;
      const data = this.data;
      if (data == null) {
        throw new Error("No data to parse");
      }
      for (const elementName in this.elements) {
        const element = this.elements[elementName];
        const { count, properties } = element;
        const item = {};
        const parsers = [];
        for (const [propertyName, property] of Object.entries(properties)) {
          if (!property.isList) {
            item[propertyName] = 0;
            parsers.push(() => {
              item[propertyName] = PARSE_FIELD[property.type](
                data,
                offset,
                this.littleEndian
              );
              offset += FIELD_BYTES[property.type];
            });
          } else {
            item[propertyName] = [];
            parsers.push(() => {
              const list = item[propertyName];
              list.length = PARSE_FIELD[property.countType](
                data,
                offset,
                this.littleEndian
              );
              offset += FIELD_BYTES[property.countType];
              for (let i2 = 0; i2 < list.length; i2++) {
                list[i2] = PARSE_FIELD[property.type](
                  data,
                  offset,
                  this.littleEndian
                );
                offset += FIELD_BYTES[property.type];
              }
            });
          }
        }
        const callback = elementCallback(element) ?? (() => {
        });
        for (let index = 0; index < count; index++) {
          for (const parser of parsers) {
            parser();
          }
          callback(index, item);
        }
      }
    }
    // Parse all the Gsplat data in the PLY file in go, invoking the given
    // callbacks for each Gsplat.
    parseSplats(splatCallback, shCallback) {
      if (this.elements.vertex == null) {
        throw new Error("No vertex element found");
      }
      let isSuperSplat = false;
      const ssChunks = [];
      let numSh = 0;
      let sh1Props = [];
      let sh2Props = [];
      let sh3Props = [];
      let sh1 = void 0;
      let sh2 = void 0;
      let sh3 = void 0;
      function prepareSh() {
        const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];
        sh1Props = new Array(3).fill(null).flatMap(
          (_, k) => [0, 1, 2].map((_2, d) => \`f_rest_\${k + d * num_f_rest / 3}\`)
        );
        sh2Props = new Array(5).fill(null).flatMap(
          (_, k) => [0, 1, 2].map((_2, d) => \`f_rest_\${3 + k + d * num_f_rest / 3}\`)
        );
        sh3Props = new Array(7).fill(null).flatMap(
          (_, k) => [0, 1, 2].map((_2, d) => \`f_rest_\${8 + k + d * num_f_rest / 3}\`)
        );
        sh1 = numSh >= 1 ? new Float32Array(3 * 3) : void 0;
        sh2 = numSh >= 2 ? new Float32Array(5 * 3) : void 0;
        sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void 0;
      }
      function ssShCallback(index, item) {
        if (!sh1) {
          throw new Error("Missing sh1");
        }
        for (const [i2, key] of sh1Props.entries()) {
          sh1[i2] = item[key] * 8 / 255 - 4;
        }
        if (sh2) {
          for (const [i2, key] of sh2Props.entries()) {
            sh2[i2] = item[key] * 8 / 255 - 4;
          }
        }
        if (sh3) {
          for (const [i2, key] of sh3Props.entries()) {
            sh3[i2] = item[key] * 8 / 255 - 4;
          }
        }
        shCallback == null ? void 0 : shCallback(index, sh1, sh2, sh3);
      }
      function initSuperSplat(element) {
        const {
          min_x,
          min_y,
          min_z,
          max_x,
          max_y,
          max_z,
          min_scale_x,
          min_scale_y,
          min_scale_z,
          max_scale_x,
          max_scale_y,
          max_scale_z,
          min_r,
          min_g,
          min_b,
          max_r,
          max_g,
          max_b
        } = element.properties;
        if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y || !max_scale_z || !min_r || !min_g || !min_b || !max_r || !max_g || !max_b) {
          throw new Error("Missing PLY chunk properties");
        }
        isSuperSplat = true;
        return (index, item) => {
          const {
            min_x: min_x2,
            min_y: min_y2,
            min_z: min_z2,
            max_x: max_x2,
            max_y: max_y2,
            max_z: max_z2,
            min_scale_x: min_scale_x2,
            min_scale_y: min_scale_y2,
            min_scale_z: min_scale_z2,
            max_scale_x: max_scale_x2,
            max_scale_y: max_scale_y2,
            max_scale_z: max_scale_z2,
            min_r: min_r2,
            min_g: min_g2,
            min_b: min_b2,
            max_r: max_r2,
            max_g: max_g2,
            max_b: max_b2
          } = item;
          ssChunks.push({
            min_x: min_x2,
            min_y: min_y2,
            min_z: min_z2,
            max_x: max_x2,
            max_y: max_y2,
            max_z: max_z2,
            min_scale_x: min_scale_x2,
            min_scale_y: min_scale_y2,
            min_scale_z: min_scale_z2,
            max_scale_x: max_scale_x2,
            max_scale_y: max_scale_y2,
            max_scale_z: max_scale_z2,
            min_r: min_r2,
            min_g: min_g2,
            min_b: min_b2,
            max_r: max_r2,
            max_g: max_g2,
            max_b: max_b2
          });
        };
      }
      function decodeSuperSplat(element) {
        if (shCallback && element.name === "sh") {
          numSh = getNumSh(element.properties);
          prepareSh();
          return ssShCallback;
        }
        if (element.name !== "vertex") {
          return null;
        }
        const { packed_position, packed_rotation, packed_scale, packed_color } = element.properties;
        if (!packed_position || !packed_rotation || !packed_scale || !packed_color) {
          throw new Error(
            "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"
          );
        }
        const SQRT2 = Math.sqrt(2);
        return (index, item) => {
          const chunk = ssChunks[index >>> 8];
          if (chunk == null) {
            throw new Error("Missing PLY chunk");
          }
          const {
            min_x,
            min_y,
            min_z,
            max_x,
            max_y,
            max_z,
            min_scale_x,
            min_scale_y,
            min_scale_z,
            max_scale_x,
            max_scale_y,
            max_scale_z,
            min_r,
            min_g,
            min_b,
            max_r,
            max_g,
            max_b
          } = chunk;
          const { packed_position: packed_position2, packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: packed_color2 } = item;
          const x2 = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + min_x;
          const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;
          const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;
          const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;
          const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;
          const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;
          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));
          const rOrder = packed_rotation2 >>> 30;
          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;
          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;
          const quatZ = rOrder <= 2 ? r2 : rr;
          const quatW = rOrder === 0 ? rr : r0;
          const scaleX = Math.exp(
            (packed_scale2 >>> 21 & 2047) / 2047 * (max_scale_x - min_scale_x) + min_scale_x
          );
          const scaleY = Math.exp(
            (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - min_scale_y) + min_scale_y
          );
          const scaleZ = Math.exp(
            (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + min_scale_z
          );
          const r = (packed_color2 >>> 24 & 255) / 255 * (max_r - min_r) + min_r;
          const g = (packed_color2 >>> 16 & 255) / 255 * (max_g - min_g) + min_g;
          const b = (packed_color2 >>> 8 & 255) / 255 * (max_b - min_b) + min_b;
          const opacity = (packed_color2 & 255) / 255;
          splatCallback(
            index,
            x2,
            y,
            z,
            scaleX,
            scaleY,
            scaleZ,
            quatX,
            quatY,
            quatZ,
            quatW,
            opacity,
            r,
            g,
            b
          );
        };
      }
      const elementCallback = (element) => {
        if (element.name === "chunk") {
          return initSuperSplat(element);
        }
        if (isSuperSplat) {
          return decodeSuperSplat(element);
        }
        if (element.name !== "vertex") {
          return null;
        }
        const {
          x: x2,
          y,
          z,
          scale_0,
          scale_1,
          scale_2,
          rot_0,
          rot_1,
          rot_2,
          rot_3,
          opacity,
          f_dc_0,
          f_dc_1,
          f_dc_2,
          red,
          green,
          blue,
          alpha
        } = element.properties;
        if (!x2 || !y || !z) {
          throw new Error("Missing PLY properties: x, y, z");
        }
        const hasScales = scale_0 && scale_1 && scale_2;
        const hasRots = rot_0 && rot_1 && rot_2 && rot_3;
        const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;
        const redDiv = red != null ? FIELD_SCALE[red.type] : 1;
        const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;
        const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;
        numSh = getNumSh(element.properties);
        prepareSh();
        return (index, item) => {
          const scaleX = hasScales ? Math.exp(item.scale_0) : _PlyReader.defaultPointScale;
          const scaleY = hasScales ? Math.exp(item.scale_1) : _PlyReader.defaultPointScale;
          const scaleZ = hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;
          const quatX = hasRots ? item.rot_1 : 0;
          const quatY = hasRots ? item.rot_2 : 0;
          const quatZ = hasRots ? item.rot_3 : 0;
          const quatW = hasRots ? item.rot_0 : 1;
          const op = opacity != null ? 1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;
          const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? item.red / redDiv : 1;
          const g = f_dc_1 != null ? item.f_dc_1 * SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;
          const b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / blueDiv : 1;
          splatCallback(
            index,
            item.x,
            item.y,
            item.z,
            scaleX,
            scaleY,
            scaleZ,
            quatX,
            quatY,
            quatZ,
            quatW,
            op,
            r,
            g,
            b
          );
          if (shCallback && sh1) {
            if (sh1) {
              for (const [i2, key] of sh1Props.entries()) {
                sh1[i2] = item[key];
              }
            }
            if (sh2) {
              for (const [i2, key] of sh2Props.entries()) {
                sh2[i2] = item[key];
              }
            }
            if (sh3) {
              for (const [i2, key] of sh3Props.entries()) {
                sh3[i2] = item[key];
              }
            }
            shCallback(index, sh1, sh2, sh3);
          }
        };
      };
      this.parseData(elementCallback);
    }
    // Inject RGBA values into original PLY file, which can be used to modify
    // the color/opacity of the Gsplats and write out the modified PLY file.
    injectRgba(rgba) {
      let offset = 0;
      const data = this.data;
      if (data == null) {
        throw new Error("No parsed data");
      }
      if (rgba.length !== this.numSplats * 4) {
        throw new Error("Invalid RGBA array length");
      }
      for (const elementName in this.elements) {
        const element = this.elements[elementName];
        const { count, properties } = element;
        const parsers = [];
        let rgbaOffset = 0;
        const isVertex = elementName === "vertex";
        if (isVertex) {
          for (const name of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"]) {
            if (!properties[name] || properties[name].type !== "float") {
              throw new Error(\`Can't injectRgba due to property: \${name}\`);
            }
          }
        }
        for (const [propertyName, property] of Object.entries(properties)) {
          if (!property.isList) {
            if (isVertex) {
              if (propertyName === "f_dc_0" || propertyName === "f_dc_1" || propertyName === "f_dc_2") {
                const component = Number.parseInt(
                  propertyName.slice("f_dc_".length)
                );
                parsers.push(() => {
                  const value = (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;
                  SET_FIELD[property.type](
                    data,
                    offset,
                    this.littleEndian,
                    value
                  );
                });
              } else if (propertyName === "opacity") {
                parsers.push(() => {
                  const value = Math.max(
                    -100,
                    Math.min(
                      100,
                      -Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)
                    )
                  );
                  SET_FIELD[property.type](
                    data,
                    offset,
                    this.littleEndian,
                    value
                  );
                });
              }
            }
            parsers.push(() => {
              offset += FIELD_BYTES[property.type];
            });
          } else {
            parsers.push(() => {
              const length = PARSE_FIELD[property.countType](
                data,
                offset,
                this.littleEndian
              );
              offset += FIELD_BYTES[property.countType];
              offset += length * FIELD_BYTES[property.type];
            });
          }
        }
        for (let index = 0; index < count; index++) {
          for (const parser of parsers) {
            parser();
          }
          if (isVertex) {
            rgbaOffset += 4;
          }
        }
      }
    }
  };
  _PlyReader.defaultPointScale = 1e-3;
  let PlyReader = _PlyReader;
  const SH_C0$1 = 0.28209479177387814;
  const PARSE_FIELD = {
    char: (data, offset, littleEndian) => {
      return data.getInt8(offset);
    },
    uchar: (data, offset, littleEndian) => {
      return data.getUint8(offset);
    },
    short: (data, offset, littleEndian) => {
      return data.getInt16(offset, littleEndian);
    },
    ushort: (data, offset, littleEndian) => {
      return data.getUint16(offset, littleEndian);
    },
    int: (data, offset, littleEndian) => {
      return data.getInt32(offset, littleEndian);
    },
    uint: (data, offset, littleEndian) => {
      return data.getUint32(offset, littleEndian);
    },
    float: (data, offset, littleEndian) => {
      return data.getFloat32(offset, littleEndian);
    },
    double: (data, offset, littleEndian) => {
      return data.getFloat64(offset, littleEndian);
    }
  };
  const SET_FIELD = {
    char: (data, offset, littleEndian, value) => {
      data.setInt8(offset, value);
    },
    uchar: (data, offset, littleEndian, value) => {
      data.setUint8(offset, value);
    },
    short: (data, offset, littleEndian, value) => {
      data.setInt16(offset, value, littleEndian);
    },
    ushort: (data, offset, littleEndian, value) => {
      data.setUint16(offset, value, littleEndian);
    },
    int: (data, offset, littleEndian, value) => {
      data.setInt32(offset, value, littleEndian);
    },
    uint: (data, offset, littleEndian, value) => {
      data.setUint32(offset, value, littleEndian);
    },
    float: (data, offset, littleEndian, value) => {
      data.setFloat32(offset, value, littleEndian);
    },
    double: (data, offset, littleEndian, value) => {
      data.setFloat64(offset, value, littleEndian);
    }
  };
  const FIELD_BYTES = {
    char: 1,
    uchar: 1,
    short: 2,
    ushort: 2,
    int: 4,
    uint: 4,
    float: 4,
    double: 8
  };
  const FIELD_SCALE = {
    char: 127,
    uchar: 255,
    short: 32767,
    ushort: 65535,
    int: 2147483647,
    uint: 4294967295,
    float: 1,
    double: 1
  };
  const NUM_F_REST_TO_NUM_SH = {
    0: 0,
    9: 1,
    24: 2,
    45: 3
  };
  const NUM_SH_TO_NUM_F_REST = {
    0: 0,
    1: 9,
    2: 24,
    3: 45
  };
  function getNumSh(properties) {
    let num_f_rest = 0;
    while (properties[\`f_rest_\${num_f_rest}\`]) {
      num_f_rest += 1;
    }
    const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];
    if (numSh == null) {
      throw new Error(\`Unsupported number of SH coefficients: \${num_f_rest}\`);
    }
    return numSh;
  }
  const Gsplat = { type: "Gsplat" };
  const TPackedSplats = { type: "PackedSplats" };
  const readPackedSplat = (packedSplats, index) => new ReadPackedSplat({ packedSplats, index });
  const readPackedSplatRange = (packedSplats, index, base, count) => new ReadPackedSplatRange({ packedSplats, index, base, count });
  const splitGsplat = (gsplat) => new SplitGsplat({ gsplat });
  const combineGsplat = ({
    gsplat,
    flags,
    index,
    center,
    scales,
    quaternion,
    rgba,
    rgb,
    opacity,
    x: x2,
    y,
    z,
    r,
    g,
    b
  }) => {
    return new CombineGsplat({
      gsplat,
      flags,
      index,
      center,
      scales,
      quaternion,
      rgba,
      rgb,
      opacity,
      x: x2,
      y,
      z,
      r,
      g,
      b
    });
  };
  const transformGsplat = (gsplat, {
    scale,
    rotate,
    translate,
    recolor
  }) => {
    return new TransformGsplat({ gsplat, scale, rotate, translate, recolor });
  };
  const defineGsplat = unindent(\`
  struct Gsplat {
    vec3 center;
    uint flags;
    vec3 scales;
    int index;
    vec4 quaternion;
    vec4 rgba;
  };
  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;

  bool isGsplatActive(uint flags) {
    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;
  }
\`);
  const definePackedSplats = unindent(\`
  struct PackedSplats {
    usampler2DArray texture;
    int numSplats;
  };
\`);
  const defineReadPackedSplat = unindent(\`
  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {
    if ((index >= 0) && (index < numSplats)) {
      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);
      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);
      return true;
    } else {
      return false;
    }
  }
\`);
  class ReadPackedSplat extends Dyno {
    constructor({
      packedSplats,
      index
    }) {
      super({
        inTypes: { packedSplats: TPackedSplats, index: "int" },
        outTypes: { gsplat: Gsplat },
        inputs: { packedSplats, index },
        globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],
        statements: ({ inputs, outputs }) => {
          const { gsplat } = outputs;
          if (!gsplat) {
            return [];
          }
          const { packedSplats: packedSplats2, index: index2 } = inputs;
          let statements;
          if (packedSplats2 && index2) {
            statements = unindentLines(\`
            if (readPackedSplat(\${packedSplats2}.texture, \${packedSplats2}.numSplats, \${index2}, \${gsplat})) {
              bool zeroSize = all(equal(\${gsplat}.scales, vec3(0.0, 0.0, 0.0)));
              \${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
            } else {
              \${gsplat}.flags = 0u;
            }
          \`);
          } else {
            statements = [\`\${gsplat}.flags = 0u;\`];
          }
          statements.push(\`\${gsplat}.index = \${index2 ?? "0"};\`);
          return statements;
        }
      });
    }
    dynoOut() {
      return new DynoOutput(this, "gsplat");
    }
  }
  class ReadPackedSplatRange extends Dyno {
    constructor({
      packedSplats,
      index,
      base,
      count
    }) {
      super({
        inTypes: {
          packedSplats: TPackedSplats,
          index: "int",
          base: "int",
          count: "int"
        },
        outTypes: { gsplat: Gsplat },
        inputs: { packedSplats, index, base, count },
        globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],
        statements: ({ inputs, outputs }) => {
          const { gsplat } = outputs;
          if (!gsplat) {
            return [];
          }
          const { packedSplats: packedSplats2, index: index2, base: base2, count: count2 } = inputs;
          let statements;
          if (packedSplats2 && index2 && base2 && count2) {
            statements = unindentLines(\`
            \${gsplat}.flags = 0u;
            if ((\${index2} >= \${base2}) && (\${index2} < (\${base2} + \${count2}))) {
              if (readPackedSplat(\${packedSplats2}.texture, \${packedSplats2}.numSplats, \${index2}, \${gsplat})) {
                bool zeroSize = all(equal(\${gsplat}.scales, vec3(0.0, 0.0, 0.0)));
                \${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
              }
            }
          \`);
          } else {
            statements = [\`\${gsplat}.flags = 0u;\`];
          }
          statements.push(\`\${gsplat}.index = \${index2 ?? "0"};\`);
          return statements;
        }
      });
    }
    dynoOut() {
      return new DynoOutput(this, "gsplat");
    }
  }
  class SplitGsplat extends Dyno {
    constructor({ gsplat }) {
      super({
        inTypes: { gsplat: Gsplat },
        outTypes: {
          flags: "uint",
          active: "bool",
          index: "int",
          center: "vec3",
          scales: "vec3",
          quaternion: "vec4",
          rgba: "vec4",
          rgb: "vec3",
          opacity: "float",
          x: "float",
          y: "float",
          z: "float",
          r: "float",
          g: "float",
          b: "float"
        },
        inputs: { gsplat },
        globals: () => [defineGsplat],
        statements: ({ inputs, outputs }) => {
          const { gsplat: gsplat2 } = inputs;
          const {
            flags,
            active,
            index,
            center,
            scales,
            quaternion,
            rgba,
            rgb,
            opacity,
            x: x2,
            y,
            z,
            r,
            g,
            b
          } = outputs;
          return [
            !flags ? null : \`\${flags} = \${gsplat2 ? \`\${gsplat2}.flags\` : "0u"};\`,
            !active ? null : \`\${active} = isGsplatActive(\${gsplat2 ? \`\${gsplat2}.flags\` : "0u"});\`,
            !index ? null : \`\${index} = \${gsplat2 ? \`\${gsplat2}.index\` : "0"};\`,
            !center ? null : \`\${center} = \${gsplat2 ? \`\${gsplat2}.center\` : "vec3(0.0, 0.0, 0.0)"};\`,
            !scales ? null : \`\${scales} = \${gsplat2 ? \`\${gsplat2}.scales\` : "vec3(0.0, 0.0, 0.0)"};\`,
            !quaternion ? null : \`\${quaternion} = \${gsplat2 ? \`\${gsplat2}.quaternion\` : "vec4(0.0, 0.0, 0.0, 1.0)"};\`,
            !rgba ? null : \`\${rgba} = \${gsplat2 ? \`\${gsplat2}.rgba\` : "vec4(0.0, 0.0, 0.0, 0.0)"};\`,
            !rgb ? null : \`\${rgb} = \${gsplat2 ? \`\${gsplat2}.rgba.rgb\` : "vec3(0.0, 0.0, 0.0)"};\`,
            !opacity ? null : \`\${opacity} = \${gsplat2 ? \`\${gsplat2}.rgba.a\` : "0.0"};\`,
            !x2 ? null : \`\${x2} = \${gsplat2 ? \`\${gsplat2}.center.x\` : "0.0"};\`,
            !y ? null : \`\${y} = \${gsplat2 ? \`\${gsplat2}.center.y\` : "0.0"};\`,
            !z ? null : \`\${z} = \${gsplat2 ? \`\${gsplat2}.center.z\` : "0.0"};\`,
            !r ? null : \`\${r} = \${gsplat2 ? \`\${gsplat2}.rgba.r\` : "0.0"};\`,
            !g ? null : \`\${g} = \${gsplat2 ? \`\${gsplat2}.rgba.g\` : "0.0"};\`,
            !b ? null : \`\${b} = \${gsplat2 ? \`\${gsplat2}.rgba.b\` : "0.0"};\`
          ].filter(Boolean);
        }
      });
    }
  }
  class CombineGsplat extends Dyno {
    constructor({
      gsplat,
      flags,
      index,
      center,
      scales,
      quaternion,
      rgba,
      rgb,
      opacity,
      x: x2,
      y,
      z,
      r,
      g,
      b
    }) {
      super({
        inTypes: {
          gsplat: Gsplat,
          flags: "uint",
          index: "int",
          center: "vec3",
          scales: "vec3",
          quaternion: "vec4",
          rgba: "vec4",
          rgb: "vec3",
          opacity: "float",
          x: "float",
          y: "float",
          z: "float",
          r: "float",
          g: "float",
          b: "float"
        },
        outTypes: { gsplat: Gsplat },
        inputs: {
          gsplat,
          flags,
          index,
          center,
          scales,
          quaternion,
          rgba,
          rgb,
          opacity,
          x: x2,
          y,
          z,
          r,
          g,
          b
        },
        globals: () => [defineGsplat],
        statements: ({ inputs, outputs }) => {
          const { gsplat: outGsplat } = outputs;
          if (!outGsplat) {
            return [];
          }
          const {
            gsplat: gsplat2,
            flags: flags2,
            index: index2,
            center: center2,
            scales: scales2,
            quaternion: quaternion2,
            rgba: rgba2,
            rgb: rgb2,
            opacity: opacity2,
            x: x22,
            y: y2,
            z: z2,
            r: r2,
            g: g2,
            b: b2
          } = inputs;
          return [
            \`\${outGsplat}.flags = \${flags2 ?? (gsplat2 ? \`\${gsplat2}.flags\` : "0u")};\`,
            \`\${outGsplat}.index = \${index2 ?? (gsplat2 ? \`\${gsplat2}.index\` : "0")};\`,
            \`\${outGsplat}.center = \${center2 ?? (gsplat2 ? \`\${gsplat2}.center\` : "vec3(0.0, 0.0, 0.0)")};\`,
            \`\${outGsplat}.scales = \${scales2 ?? (gsplat2 ? \`\${gsplat2}.scales\` : "vec3(0.0, 0.0, 0.0)")};\`,
            \`\${outGsplat}.quaternion = \${quaternion2 ?? (gsplat2 ? \`\${gsplat2}.quaternion\` : "vec4(0.0, 0.0, 0.0, 1.0)")};\`,
            \`\${outGsplat}.rgba = \${rgba2 ?? (gsplat2 ? \`\${gsplat2}.rgba\` : "vec4(0.0, 0.0, 0.0, 0.0)")};\`,
            !rgb2 ? null : \`\${outGsplat}.rgba.rgb = \${rgb2};\`,
            !opacity2 ? null : \`\${outGsplat}.rgba.a = \${opacity2};\`,
            !x22 ? null : \`\${outGsplat}.center.x = \${x22};\`,
            !y2 ? null : \`\${outGsplat}.center.y = \${y2};\`,
            !z2 ? null : \`\${outGsplat}.center.z = \${z2};\`,
            !r2 ? null : \`\${outGsplat}.rgba.r = \${r2};\`,
            !g2 ? null : \`\${outGsplat}.rgba.g = \${g2};\`,
            !b2 ? null : \`\${outGsplat}.rgba.b = \${b2};\`
          ].filter(Boolean);
        }
      });
    }
    dynoOut() {
      return new DynoOutput(this, "gsplat");
    }
  }
  unindent(\`
  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {
    float minScale = min(scales.x, min(scales.y, scales.z));
    vec3 normal;
    if (scales.z == minScale) {
      normal = vec3(0.0, 0.0, 1.0);
    } else if (scales.y == minScale) {
      normal = vec3(0.0, 1.0, 0.0);
    } else {
      normal = vec3(1.0, 0.0, 0.0);
    }
    return quatVec(quaternion, normal);
  }
\`);
  class TransformGsplat extends Dyno {
    constructor({
      gsplat,
      scale,
      rotate,
      translate,
      recolor
    }) {
      super({
        inTypes: {
          gsplat: Gsplat,
          scale: "float",
          rotate: "vec4",
          translate: "vec3",
          recolor: "vec4"
        },
        outTypes: { gsplat: Gsplat },
        inputs: { gsplat, scale, rotate, translate, recolor },
        globals: () => [defineGsplat],
        statements: ({ inputs, outputs, compile }) => {
          const { gsplat: gsplat2 } = outputs;
          if (!gsplat2 || !inputs.gsplat) {
            return [];
          }
          const { scale: scale2, rotate: rotate2, translate: translate2, recolor: recolor2 } = inputs;
          const indent = compile.indent;
          const statements = [
            \`\${gsplat2} = \${inputs.gsplat};\`,
            \`if (isGsplatActive(\${gsplat2}.flags)) {\`,
            scale2 ? \`\${indent}\${gsplat2}.center *= \${scale2};\` : null,
            rotate2 ? \`\${indent}\${gsplat2}.center = quatVec(\${rotate2}, \${gsplat2}.center);\` : null,
            translate2 ? \`\${indent}\${gsplat2}.center += \${translate2};\` : null,
            scale2 ? \`\${indent}\${gsplat2}.scales *= \${scale2};\` : null,
            rotate2 ? \`\${indent}\${gsplat2}.quaternion = quatQuat(\${rotate2}, \${gsplat2}.quaternion);\` : null,
            recolor2 ? \`\${indent}\${gsplat2}.rgba *= \${recolor2};\` : null,
            "}"
          ].filter(Boolean);
          return statements;
        }
      });
    }
    dynoOut() {
      return new DynoOutput(this, "gsplat");
    }
  }
  const outputPackedSplat = (gsplat) => new OutputPackedSplat({ gsplat });
  class OutputPackedSplat extends Dyno {
    constructor({ gsplat }) {
      super({
        inTypes: { gsplat: Gsplat },
        inputs: { gsplat },
        globals: () => [defineGsplat],
        statements: ({ inputs, outputs }) => {
          const { output } = outputs;
          if (!output) {
            return [];
          }
          const { gsplat: gsplat2 } = inputs;
          if (gsplat2) {
            return unindentLines(\`
            if (isGsplatActive(\${gsplat2}.flags)) {
              \${output} = packSplat(\${gsplat2}.center, \${gsplat2}.scales, \${gsplat2}.quaternion, \${gsplat2}.rgba);
            } else {
              \${output} = uvec4(0u, 0u, 0u, 0u);
            }
          \`);
          }
          return [\`\${output} = uvec4(0u, 0u, 0u, 0u);\`];
        }
      });
    }
    dynoOut() {
      return new DynoOutput(this, "output");
    }
  }
  class OutputRgba8 extends Dyno {
    constructor({ rgba8 }) {
      super({
        inTypes: { rgba8: "vec4" },
        inputs: { rgba8 },
        statements: ({ inputs, outputs }) => [
          \`target = \${inputs.rgba8 ?? "vec4(0.0, 0.0, 0.0, 0.0)"};\`
        ]
      });
    }
    dynoOut() {
      return new DynoOutput(this, "rgba8");
    }
  }
  class DynoUniform extends Dyno {
    constructor({
      key,
      type,
      count,
      value,
      update,
      globals
    }) {
      key = key ?? "value";
      super({
        outTypes: { [key]: type },
        update: () => {
          if (update) {
            const value2 = update(this.value);
            if (value2 !== void 0) {
              this.value = value2;
            }
          }
          this.uniform.value = this.value;
        },
        generate: ({ inputs, outputs }) => {
          const allGlobals = (globals == null ? void 0 : globals({ inputs, outputs })) ?? [];
          const uniforms = {};
          const name = outputs[key];
          if (name) {
            allGlobals.push(\`uniform \${dynoDeclare(name, type, count)};\`);
            uniforms[name] = this.uniform;
          }
          return { globals: allGlobals, uniforms };
        }
      });
      this.type = type;
      this.count = count;
      this.value = value;
      this.uniform = { value };
      this.outKey = key;
    }
    dynoOut() {
      return new DynoOutput(this, this.outKey);
    }
  }
  class DynoInt extends DynoUniform {
    constructor({
      key,
      value,
      update
    }) {
      super({ key, type: "int", value, update });
    }
  }
  class DynoFloat extends DynoUniform {
    constructor({
      key,
      value,
      update
    }) {
      super({ key, type: "float", value, update });
    }
  }
  class DynoVec3 extends DynoUniform {
    constructor({
      key,
      value,
      update
    }) {
      super({ key, type: "vec3", value, update });
    }
  }
  class DynoVec4 extends DynoUniform {
    constructor({
      key,
      value,
      update
    }) {
      super({ key, type: "vec4", value, update });
    }
  }
  class DynoUsampler2DArray extends DynoUniform {
    constructor({
      key,
      value,
      update
    }) {
      super({ key, type: "usampler2DArray", value, update });
    }
  }
  class DynoProgram {
    constructor({
      graph,
      inputs,
      outputs,
      template
    }) {
      this.graph = graph;
      this.template = template;
      this.inputs = inputs ?? {};
      this.outputs = outputs ?? {};
      const compile = new Compilation({ indent: this.template.indent });
      for (const key in this.outputs) {
        if (this.outputs[key]) {
          compile.declares.add(this.outputs[key]);
        }
      }
      const statements = graph.compile({
        inputs: this.inputs,
        outputs: this.outputs,
        compile
      });
      this.shader = template.generate({ globals: compile.globals, statements });
      this.uniforms = compile.uniforms;
      this.updaters = compile.updaters;
    }
    prepareMaterial() {
      return getMaterial(this);
    }
    update() {
      for (const updater of this.updaters) {
        updater();
      }
    }
  }
  class DynoProgramTemplate {
    constructor(template) {
      const globals = template.match(/^([ \\t]*)\\{\\{\\s*GLOBALS\\s*\\}\\}/m);
      const statements = template.match(/^([ \\t]*)\\{\\{\\s*STATEMENTS\\s*\\}\\}/m);
      if (!globals || !statements) {
        throw new Error(
          "Template must contain {{ GLOBALS }} and {{ STATEMENTS }}"
        );
      }
      this.before = template.substring(0, globals.index);
      this.between = template.substring(
        globals.index + globals[0].length,
        statements.index
      );
      this.after = template.substring(
        statements.index + statements[0].length
      );
      this.indent = statements[1];
    }
    generate({
      globals,
      statements
    }) {
      return this.before + Array.from(globals).join("\\n\\n") + this.between + statements.map((s) => this.indent + s).join("\\n") + this.after;
    }
  }
  const programMaterial = /* @__PURE__ */ new Map();
  function getMaterial(program) {
    let material = programMaterial.get(program);
    if (material) {
      return material;
    }
    material = new RawShaderMaterial({
      glslVersion: GLSL3,
      vertexShader: IDENT_VERTEX_SHADER,
      fragmentShader: program.shader,
      uniforms: program.uniforms
    });
    programMaterial.set(program, material);
    return material;
  }
  function addOutputType(a, b, operation = "add") {
    const error = () => {
      throw new Error(\`Invalid \${operation} types: \${a}, \${b}\`);
    };
    if (a === b) return a;
    if (a === "int") {
      if (isIntType(b)) return b;
      error();
    }
    if (b === "int") {
      if (isIntType(a)) return a;
      error();
    }
    if (a === "uint") {
      if (isUintType(b)) return b;
      error();
    }
    if (b === "uint") {
      if (isUintType(a)) return a;
      error();
    }
    if (a === "float") {
      if (isAllFloatType(b)) return b;
      error();
    }
    if (b === "float") {
      if (isAllFloatType(a)) return a;
      error();
    }
    throw new Error(\`Invalid \${operation} types: \${a}, \${b}\`);
  }
  function subOutputType(a, b) {
    return addOutputType(a, b, "sub");
  }
  function mulOutputType(a, b) {
    const error = () => {
      throw new Error(\`Invalid mul types: \${a}, \${b}\`);
    };
    const result = (value) => value;
    if (a === "int") {
      if (isIntType(b)) return result(b);
      error();
    }
    if (b === "int") {
      if (isIntType(a)) return result(a);
      error();
    }
    if (a === "uint") {
      if (isUintType(b)) return result(b);
      error();
    }
    if (b === "uint") {
      if (isUintType(a)) return result(a);
      error();
    }
    if (a === "float") {
      if (isAllFloatType(b)) return result(b);
      error();
    }
    if (b === "float") {
      if (isAllFloatType(a)) return result(a);
      error();
    }
    if (isIntType(a) || isUintType(a) || isIntType(b) || isUintType(b)) {
      if (a === b) return result(a);
      error();
    }
    if (a === "vec2") {
      if (b === "vec2" || isMat2(b)) return result("vec2");
      if (b === "mat3x2") return result("vec3");
      if (b === "mat4x2") return result("vec4");
      error();
    }
    if (a === "vec3") {
      if (b === "mat2x3") return result("vec2");
      if (b === "vec3" || isMat3(b)) return result("vec3");
      if (b === "mat4x3") return result("vec4");
      error();
    }
    if (a === "vec4") {
      if (b === "mat2x4") return result("vec2");
      if (b === "mat3x4") return result("vec3");
      if (b === "vec4" || isMat4(b)) return result("vec4");
      error();
    }
    if (b === "vec2") {
      if (isMat2(a)) return result("vec2");
      if (a === "mat2x3") return result("vec3");
      if (a === "mat2x4") return result("vec4");
      error();
    }
    if (b === "vec3") {
      if (a === "mat3x2") return result("vec2");
      if (isMat3(a)) return result("vec3");
      if (a === "mat3x4") return result("vec4");
      error();
    }
    if (b === "vec4") {
      if (a === "mat4x2") return result("vec2");
      if (a === "mat4x3") return result("vec3");
      if (isMat4(a)) return result("vec4");
      error();
    }
    if (isMat2(a)) {
      if (isMat2(b)) return result("mat2");
      if (b === "mat3x2") return result("mat3x2");
      if (b === "mat4x2") return result("mat4x2");
      error();
    }
    if (a === "mat2x3") {
      if (isMat2(b)) return result("mat2x3");
      if (b === "mat3x2") return result("mat3");
      if (b === "mat4x2") return result("mat4x3");
      error();
    }
    if (a === "mat2x4") {
      if (isMat2(b)) return result("mat2x4");
      if (b === "mat3x2") return result("mat3x4");
      if (b === "mat4x2") return result("mat4");
      error();
    }
    if (a === "mat3x2") {
      if (b === "mat2x3") return result("mat2");
      if (isMat3(b)) return result("mat3x2");
      if (b === "mat4x3") return result("mat4x2");
      error();
    }
    if (isMat3(a)) {
      if (b === "mat2x3") return result("mat2x3");
      if (isMat3(b)) return result("mat3");
      if (b === "mat4x3") return result("mat4x3");
      error();
    }
    if (a === "mat3x4") {
      if (b === "mat2x3") return result("mat2x4");
      if (isMat3(b)) return result("mat3x4");
      if (b === "mat4x3") return result("mat4");
      error();
    }
    if (a === "mat4x2") {
      if (b === "mat2x4") return result("mat2");
      if (b === "mat3x4") return result("mat3x2");
      if (isMat4(b)) return result("mat4x2");
      error();
    }
    if (a === "mat4x3") {
      if (b === "mat2x4") return result("mat2x3");
      if (b === "mat3x4") return result("mat3");
      if (isMat4(b)) return result("mat4x3");
      error();
    }
    if (isMat4(a)) {
      if (b === "mat2x4") return result("mat2x4");
      if (b === "mat3x4") return result("mat3x4");
      if (isMat4(b)) return result("mat4");
      error();
    }
    throw new Error(\`Invalid mul types: \${a}, \${b}\`);
  }
  const add = (a, b) => new Add({ a, b });
  const sub = (a, b) => new Sub({ a, b });
  const mul = (a, b) => new Mul({ a, b });
  class Add extends BinaryOp {
    constructor({ a, b }) {
      super({ a, b, outKey: "sum", outTypeFunc: addOutputType });
      this.statements = ({ inputs, outputs }) => {
        return [\`\${outputs.sum} = \${inputs.a} + \${inputs.b};\`];
      };
    }
  }
  class Sub extends BinaryOp {
    constructor({ a, b }) {
      super({ a, b, outKey: "difference", outTypeFunc: subOutputType });
      this.statements = ({ inputs, outputs }) => {
        return [\`\${outputs.difference} = \${inputs.a} - \${inputs.b};\`];
      };
    }
  }
  class Mul extends BinaryOp {
    constructor({ a, b }) {
      super({ a, b, outKey: "product", outTypeFunc: mulOutputType });
      this.statements = ({ inputs, outputs }) => {
        return [\`\${outputs.product} = \${inputs.a} * \${inputs.b};\`];
      };
    }
  }
  const normalize = (a) => new Normalize({ a });
  const extendVec = (a, b) => new ExtendVec({ a, b });
  class Normalize extends UnaryOp {
    constructor({ a }) {
      super({ a, outTypeFunc: (aType) => aType, outKey: "normalize" });
      this.statements = ({ inputs, outputs }) => [
        \`\${outputs.normalize} = normalize(\${inputs.a});\`
      ];
    }
  }
  function extendVecOutputType(type) {
    if (type === "float") return "vec2";
    if (type === "vec2") return "vec3";
    if (type === "vec3") return "vec4";
    throw new Error("Invalid type");
  }
  class ExtendVec extends BinaryOp {
    constructor({ a, b }) {
      const type = valType(a);
      const outType = extendVecOutputType(type);
      super({ a, b, outKey: "extend", outTypeFunc: () => outType });
      this.statements = ({ inputs, outputs }) => [
        \`\${outputs.extend} = \${outType}(\${inputs.a}, \${inputs.b});\`
      ];
    }
  }
  const transformPos = (position, {
    scale,
    scales,
    rotate,
    translate
  }) => {
    return new TransformPosition({ position, scale, scales, rotate, translate }).outputs.position;
  };
  const transformDir = (dir, {
    scale,
    scales,
    rotate
  }) => {
    return new TransformDir({ dir, scale, scales, rotate }).outputs.dir;
  };
  class TransformPosition extends Dyno {
    constructor({
      position,
      scale,
      scales,
      rotate,
      translate
    }) {
      super({
        inTypes: {
          position: "vec3",
          scale: "float",
          scales: "vec3",
          rotate: "vec4",
          translate: "vec3"
        },
        outTypes: { position: "vec3" },
        inputs: { position, scale, scales, rotate, translate },
        statements: ({ inputs, outputs }) => {
          const { position: position2 } = outputs;
          if (!position2) {
            return [];
          }
          const { scale: scale2, scales: scales2, rotate: rotate2, translate: translate2 } = inputs;
          return [
            \`\${position2} = \${inputs.position ?? "vec3(0.0, 0.0, 0.0)"};\`,
            !scale2 ? null : \`\${position2} *= \${scale2};\`,
            !scales2 ? null : \`\${position2} *= \${scales2};\`,
            !rotate2 ? null : \`\${position2} = quatVec(\${rotate2}, \${position2});\`,
            !translate2 ? null : \`\${position2} += \${translate2};\`
          ].filter(Boolean);
        }
      });
    }
  }
  class TransformDir extends Dyno {
    constructor({
      dir,
      scale,
      scales,
      rotate
    }) {
      super({
        inTypes: { dir: "vec3", scale: "float", scales: "vec3", rotate: "vec4" },
        outTypes: { dir: "vec3" },
        inputs: { dir, scale, scales, rotate },
        statements: ({ inputs, outputs }) => {
          const { dir: dir2 } = outputs;
          if (!dir2) {
            return [];
          }
          const { scale: scale2, scales: scales2, rotate: rotate2 } = inputs;
          return [
            \`\${dir2} = \${inputs.dir ?? "vec3(0.0, 0.0, 0.0)"};\`,
            !scale2 ? null : \`\${dir2} *= \${scale2};\`,
            !scales2 ? null : \`\${dir2} *= \${scales2};\`,
            !rotate2 ? null : \`\${dir2} = quatVec(\${rotate2}, \${dir2});\`
          ].filter(Boolean);
        }
      });
    }
  }
  var computeUvec4_default = "precision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp usampler2D;\\nprecision highp isampler2D;\\nprecision highp sampler2DArray;\\nprecision highp usampler2DArray;\\nprecision highp isampler2DArray;\\nprecision highp sampler3D;\\nprecision highp usampler3D;\\nprecision highp isampler3D;\\n\\n#include <splatDefines>\\n\\nuniform uint targetLayer;\\nuniform int targetBase;\\nuniform int targetCount;\\n\\nout uvec4 target;\\n\\n{{ GLOBALS }}\\n\\nvoid produceSplat(int index) {\\n    {{ STATEMENTS }}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    if ((index >= 0) && (index < targetCount)) {\\n        produceSplat(index);\\n    } else {\\n        target = uvec4(0u, 0u, 0u, 0u);\\n    }\\n}";
  const _PackedSplats = class _PackedSplats {
    constructor(options = {}) {
      this.maxSplats = 0;
      this.numSplats = 0;
      this.packedArray = null;
      this.isInitialized = false;
      this.target = null;
      this.source = null;
      this.needsUpdate = true;
      this.extra = {};
      this.dyno = new DynoPackedSplats({ packedSplats: this });
      this.initialized = Promise.resolve(this);
      this.reinitialize(options);
    }
    reinitialize(options) {
      this.isInitialized = false;
      if (options.url || options.fileBytes || options.construct) {
        this.initialized = this.asyncInitialize(options).then(() => {
          this.isInitialized = true;
          return this;
        });
      } else {
        this.initialize(options);
        this.isInitialized = true;
        this.initialized = Promise.resolve(this);
      }
    }
    initialize(options) {
      if (options.packedArray) {
        this.packedArray = options.packedArray;
        this.maxSplats = Math.floor(this.packedArray.length / 4);
        this.maxSplats = Math.floor(this.maxSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;
        this.numSplats = Math.min(
          this.maxSplats,
          options.numSplats ?? Number.POSITIVE_INFINITY
        );
      } else {
        this.maxSplats = options.maxSplats ?? 0;
        this.numSplats = 0;
      }
      this.extra = options.extra ?? {};
    }
    async asyncInitialize(options) {
      let { url, fileBytes, construct } = options;
      if (url) {
        fileBytes = await fetch(url).then(async (response) => {
          if (!response.ok) {
            throw new Error(
              \`\${response.status} "\${response.statusText}" fetching URL: \${url}\`
            );
          }
          const arrayBuffer = await response.arrayBuffer();
          return arrayBuffer;
        });
      }
      if (fileBytes) {
        const unpacked = await unpackSplats({
          input: fileBytes,
          fileType: options.fileType,
          pathOrUrl: options.fileName ?? url
        });
        this.initialize(unpacked);
      }
      if (construct) {
        const maybePromise = construct(this);
        if (maybePromise instanceof Promise) {
          await maybePromise;
        }
      }
    }
    // Call this when you are finished with the PackedSplats and want to free
    // any buffers it holds.
    dispose() {
      if (this.target) {
        this.target.dispose();
        this.target = null;
      }
      if (this.source) {
        this.source.dispose();
        this.source = null;
      }
    }
    // Ensures that this.packedArray can fit numSplats Gsplats. If it's too small,
    // resize exponentially and copy over the original data.
    //
    // Typically you don't need to call this, because calling this.setSplat(index, ...)
    // and this.pushSplat(...) will automatically call ensureSplats() so we have
    // enough splats.
    ensureSplats(numSplats) {
      const targetSize = numSplats <= this.maxSplats ? this.maxSplats : (
        // Grow exponentially to avoid frequent reallocations
        Math.max(numSplats, 2 * this.maxSplats)
      );
      const currentSize = !this.packedArray ? 0 : this.packedArray.length / 4;
      if (!this.packedArray || targetSize > currentSize) {
        this.maxSplats = getTextureSize(targetSize).maxSplats;
        const newArray = new Uint32Array(this.maxSplats * 4);
        if (this.packedArray) {
          newArray.set(this.packedArray);
        }
        this.packedArray = newArray;
      }
      return this.packedArray;
    }
    // Ensure the extra array for the given level is large enough to hold numSplats
    ensureSplatsSh(level, numSplats) {
      let wordsPerSplat;
      let key;
      if (level === 0) {
        return this.ensureSplats(numSplats);
      }
      if (level === 1) {
        wordsPerSplat = 2;
        key = "sh1";
      } else if (level === 2) {
        wordsPerSplat = 4;
        key = "sh2";
      } else if (level === 3) {
        wordsPerSplat = 4;
        key = "sh3";
      } else {
        throw new Error(\`Invalid level: \${level}\`);
      }
      let maxSplats = !this.extra[key] ? 0 : this.extra[key].length / wordsPerSplat;
      const targetSize = numSplats <= maxSplats ? maxSplats : Math.max(numSplats, 2 * maxSplats);
      if (!this.extra[key] || targetSize > maxSplats) {
        maxSplats = getTextureSize(targetSize).maxSplats;
        const newArray = new Uint32Array(maxSplats * wordsPerSplat);
        if (this.extra[key]) {
          newArray.set(this.extra[key]);
        }
        this.extra[key] = newArray;
      }
      return this.extra[key];
    }
    // Unpack the 16-byte Gsplat data at index into the Three.js components
    // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
    // opacity: number 0..1, color: THREE.Color 0..1.
    getSplat(index) {
      if (!this.packedArray || index >= this.numSplats) {
        throw new Error("Invalid index");
      }
      return unpackSplat(this.packedArray, index);
    }
    // Set all PackedSplat components at index with the provided Gsplat attributes
    // (can be the same objects returned by getSplat). Ensures there is capacity
    // for at least index+1 Gsplats.
    setSplat(index, center, scales, quaternion, opacity, color) {
      const packedSplats = this.ensureSplats(index + 1);
      setPackedSplat(
        packedSplats,
        index,
        center.x,
        center.y,
        center.z,
        scales.x,
        scales.y,
        scales.z,
        quaternion.x,
        quaternion.y,
        quaternion.z,
        quaternion.w,
        opacity,
        color.r,
        color.g,
        color.b
      );
      this.numSplats = Math.max(this.numSplats, index + 1);
    }
    // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on
    // construction where you just want to iterate and create a collection of Gsplats.
    pushSplat(center, scales, quaternion, opacity, color) {
      const packedSplats = this.ensureSplats(this.numSplats + 1);
      setPackedSplat(
        packedSplats,
        this.numSplats,
        center.x,
        center.y,
        center.z,
        scales.x,
        scales.y,
        scales.z,
        quaternion.x,
        quaternion.y,
        quaternion.z,
        quaternion.w,
        opacity,
        color.r,
        color.g,
        color.b
      );
      ++this.numSplats;
    }
    // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat
    // and invoke the callback function with the Gsplat attributes.
    forEachSplat(callback) {
      if (!this.packedArray || !this.numSplats) {
        return;
      }
      for (let i2 = 0; i2 < this.numSplats; ++i2) {
        const unpacked = unpackSplat(this.packedArray, i2);
        callback(
          i2,
          unpacked.center,
          unpacked.scales,
          unpacked.quaternion,
          unpacked.opacity,
          unpacked.color
        );
      }
    }
    // Ensures our PackedSplats.target render target has enough space to generate
    // maxSplats total Gsplats, and reallocate if not large enough.
    ensureGenerate(maxSplats) {
      if (this.target && (maxSplats ?? 1) <= this.maxSplats) {
        return false;
      }
      this.dispose();
      const textureSize = getTextureSize(maxSplats ?? 1);
      const { width, height, depth } = textureSize;
      this.maxSplats = textureSize.maxSplats;
      this.target = new WebGLArrayRenderTarget(width, height, depth, {
        depthBuffer: false,
        stencilBuffer: false,
        generateMipmaps: false,
        magFilter: NearestFilter,
        minFilter: NearestFilter
      });
      this.target.texture.format = RGBAIntegerFormat;
      this.target.texture.type = UnsignedIntType;
      this.target.texture.internalFormat = "RGBA32UI";
      return true;
    }
    // Given an array of splatCounts (.numSplats for each
    // SplatGenerator/SplatMesh in the scene), compute a
    // "mapping layout" in the composite array of generated outputs.
    generateMapping(splatCounts) {
      let maxSplats = 0;
      const mapping = splatCounts.map((numSplats) => {
        const base = maxSplats;
        const rounded = Math.ceil(numSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;
        maxSplats += rounded;
        return { base, count: numSplats };
      });
      return { maxSplats, mapping };
    }
    // Returns a THREE.DataArrayTexture representing the PackedSplats content as
    // a Uint32x4 data array texture (2048 x 2048 x depth in size)
    getTexture() {
      if (this.target) {
        return this.target.texture;
      }
      if (this.source || this.packedArray) {
        const source = this.maybeUpdateSource();
        return source;
      }
      return _PackedSplats.getEmpty();
    }
    // Check if source texture needs to be created/updated
    maybeUpdateSource() {
      if (!this.packedArray) {
        throw new Error("No packed splats");
      }
      if (this.needsUpdate || !this.source) {
        this.needsUpdate = false;
        if (this.source) {
          const { width, height, depth } = this.source.image;
          if (this.maxSplats !== width * height * depth) {
            this.source.dispose();
            this.source = null;
          }
        }
        if (!this.source) {
          const { width, height, depth } = getTextureSize(this.maxSplats);
          this.source = new DataArrayTexture(
            this.packedArray,
            width,
            height,
            depth
          );
          this.source.format = RGBAIntegerFormat;
          this.source.type = UnsignedIntType;
          this.source.internalFormat = "RGBA32UI";
          this.source.needsUpdate = true;
        } else if (this.packedArray.buffer !== this.source.image.data.buffer) {
          this.source.image.data = new Uint8Array(this.packedArray.buffer);
        }
        this.source.needsUpdate = true;
      }
      return this.source;
    }
    // Can be used where you need an uninitialized THREE.DataArrayTexture like
    // a uniform you will update with the result of this.getTexture() later.
    static getEmpty() {
      if (!_PackedSplats.emptySource) {
        const { width, height, depth, maxSplats } = getTextureSize(1);
        const emptyArray = new Uint32Array(maxSplats * 4);
        _PackedSplats.emptySource = new DataArrayTexture(
          emptyArray,
          width,
          height,
          depth
        );
        _PackedSplats.emptySource.format = RGBAIntegerFormat;
        _PackedSplats.emptySource.type = UnsignedIntType;
        _PackedSplats.emptySource.internalFormat = "RGBA32UI";
        _PackedSplats.emptySource.needsUpdate = true;
      }
      return _PackedSplats.emptySource;
    }
    // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,
    // generating it if necessary and caching the result.
    prepareProgramMaterial(generator) {
      let program = _PackedSplats.generatorProgram.get(generator);
      if (!program) {
        const graph = dynoBlock(
          { index: "int" },
          { output: "uvec4" },
          ({ index }) => {
            generator.inputs.index = index;
            const gsplat = generator.outputs.gsplat;
            const output = outputPackedSplat(gsplat);
            return { output };
          }
        );
        if (!_PackedSplats.programTemplate) {
          _PackedSplats.programTemplate = new DynoProgramTemplate(
            computeUvec4_default
          );
        }
        program = new DynoProgram({
          graph,
          inputs: { index: "index" },
          outputs: { output: "target" },
          template: _PackedSplats.programTemplate
        });
        Object.assign(program.uniforms, {
          targetLayer: { value: 0 },
          targetBase: { value: 0 },
          targetCount: { value: 0 }
        });
        _PackedSplats.generatorProgram.set(generator, program);
      }
      const material = program.prepareMaterial();
      _PackedSplats.mesh.material = material;
      return { program, material };
    }
    saveRenderState(renderer) {
      return {
        xrPresenting: renderer.xr.isPresenting,
        autoClear: renderer.autoClear,
        scissorTest: renderer.getScissorTest(),
        pixelRatio: renderer.getPixelRatio()
      };
    }
    resetRenderState(renderer, state) {
      renderer.setRenderTarget(null);
      renderer.setPixelRatio(state.pixelRatio);
      renderer.xr.isPresenting = state.xrPresenting;
      renderer.autoClear = state.autoClear;
      renderer.setScissorTest(state.scissorTest);
    }
    // Executes a dyno program specified by generator which is any DynoBlock that
    // maps { index: "int" } to { gsplat: Gsplat }. This is called in
    // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for
    // SplatGenerator instances whose version is newer than what was generated
    // for it last time.
    generate({
      generator,
      base,
      count,
      renderer
    }) {
      if (!this.target) {
        throw new Error("Target must be initialized with ensureSplats");
      }
      if (base + count > this.maxSplats) {
        throw new Error("Base + count exceeds maxSplats");
      }
      const { program, material } = this.prepareProgramMaterial(generator);
      program.update();
      const renderState = this.saveRenderState(renderer);
      const nextBase = Math.ceil((base + count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;
      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;
      material.uniforms.targetBase.value = base;
      material.uniforms.targetCount.value = count;
      while (base < nextBase) {
        const layer = Math.floor(base / layerSize);
        material.uniforms.targetLayer.value = layer;
        const layerBase = layer * layerSize;
        const layerYStart = Math.floor((base - layerBase) / SPLAT_TEX_WIDTH);
        const layerYEnd = Math.min(
          SPLAT_TEX_HEIGHT,
          Math.ceil((nextBase - layerBase) / SPLAT_TEX_WIDTH)
        );
        renderer.setPixelRatio(1);
        renderer.setRenderTarget(this.target, layer);
        renderer.xr.isPresenting = false;
        renderer.autoClear = false;
        renderer.setScissorTest(true);
        renderer.setScissor(
          0,
          layerYStart,
          SPLAT_TEX_WIDTH,
          layerYEnd - layerYStart
        );
        renderer.render(_PackedSplats.scene, _PackedSplats.camera);
        base += SPLAT_TEX_WIDTH * (layerYEnd - layerYStart);
      }
      this.resetRenderState(renderer, renderState);
      return { nextBase };
    }
  };
  _PackedSplats.emptySource = null;
  _PackedSplats.programTemplate = null;
  _PackedSplats.generatorProgram = /* @__PURE__ */ new Map();
  _PackedSplats.geometry = new PlaneGeometry(2, 2);
  _PackedSplats.mesh = new Mesh(
    _PackedSplats.geometry,
    new RawShaderMaterial({ visible: false })
  );
  _PackedSplats.scene = new Scene().add(_PackedSplats.mesh);
  _PackedSplats.camera = new Camera();
  let PackedSplats = _PackedSplats;
  class DynoPackedSplats extends DynoUniform {
    constructor({ packedSplats } = {}) {
      super({
        key: "packedSplats",
        type: TPackedSplats,
        globals: () => [definePackedSplats],
        value: {
          texture: PackedSplats.getEmpty(),
          numSplats: 0
        },
        update: (value) => {
          var _a2, _b2;
          value.texture = ((_a2 = this.packedSplats) == null ? void 0 : _a2.getTexture()) ?? PackedSplats.getEmpty();
          value.numSplats = ((_b2 = this.packedSplats) == null ? void 0 : _b2.numSplats) ?? 0;
          return value;
        }
      });
      this.packedSplats = packedSplats;
    }
  }
  var computeVec4_default = "precision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp usampler2D;\\nprecision highp isampler2D;\\nprecision highp sampler2DArray;\\nprecision highp usampler2DArray;\\nprecision highp isampler2DArray;\\nprecision highp sampler3D;\\nprecision highp usampler3D;\\nprecision highp isampler3D;\\n\\n#include <splatDefines>\\n\\nuniform uint targetLayer;\\nuniform int targetBase;\\nuniform int targetCount;\\n\\nout vec4 target;\\n\\n{{ GLOBALS }}\\n\\nvoid computeReadback(int index) {\\n    {{ STATEMENTS }}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    if ((index >= 0) && (index < targetCount)) {\\n        computeReadback(index);\\n    } else {\\n        target = vec4(0.0, 0.0, 0.0, 0.0);\\n    }\\n}";
  const _Readback = class _Readback {
    constructor({ renderer } = {}) {
      this.renderer = renderer;
      this.capacity = 0;
      this.count = 0;
    }
    dispose() {
      if (this.target) {
        this.target.dispose();
        this.target = void 0;
      }
    }
    // Ensure we have a buffer large enough for the readback of count indices.
    // Pass in previous bufer of the desired type.
    ensureBuffer(count, buffer) {
      const roundedCount = Math.ceil(Math.max(1, count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;
      const bytes = roundedCount * 4;
      if (buffer.byteLength >= bytes) {
        return buffer;
      }
      const newBuffer = new ArrayBuffer(bytes);
      if (buffer instanceof ArrayBuffer) {
        return newBuffer;
      }
      const ctor = buffer.constructor;
      return new ctor(newBuffer);
    }
    // Ensure our render target is large enough for the readback of capacity indices.
    ensureCapacity(capacity) {
      const { width, height, depth, maxSplats } = getTextureSize(capacity);
      if (!this.target || maxSplats > this.capacity) {
        this.dispose();
        this.capacity = maxSplats;
        this.target = new WebGLArrayRenderTarget(width, height, depth, {
          depthBuffer: false,
          stencilBuffer: false,
          generateMipmaps: false,
          magFilter: NearestFilter,
          minFilter: NearestFilter
        });
        this.target.texture.format = RGBAFormat;
        this.target.texture.type = UnsignedByteType;
        this.target.texture.internalFormat = "RGBA8";
      }
    }
    // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,
    // generating it if necessary and caching the result.
    prepareProgramMaterial(reader) {
      let program = _Readback.readbackProgram.get(reader);
      if (!program) {
        const graph = dynoBlock(
          { index: "int" },
          { rgba8: "vec4" },
          ({ index }) => {
            reader.inputs.index = index;
            const rgba8 = new OutputRgba8({ rgba8: reader.outputs.rgba8 });
            return { rgba8 };
          }
        );
        if (!_Readback.programTemplate) {
          _Readback.programTemplate = new DynoProgramTemplate(computeVec4_default);
        }
        program = new DynoProgram({
          graph,
          inputs: { index: "index" },
          outputs: { rgba8: "target" },
          template: _Readback.programTemplate
        });
        Object.assign(program.uniforms, {
          targetLayer: { value: 0 },
          targetBase: { value: 0 },
          targetCount: { value: 0 }
        });
        _Readback.readbackProgram.set(reader, program);
      }
      const material = program.prepareMaterial();
      _Readback.mesh.material = material;
      return { program, material };
    }
    saveRenderState(renderer) {
      return {
        xrPresenting: renderer.xr.isPresenting,
        autoClear: renderer.autoClear,
        scissorTest: renderer.getScissorTest(),
        pixelRatio: renderer.getPixelRatio()
      };
    }
    resetRenderState(renderer, state) {
      renderer.setRenderTarget(null);
      renderer.setPixelRatio(state.pixelRatio);
      renderer.xr.isPresenting = state.xrPresenting;
      renderer.autoClear = state.autoClear;
      renderer.setScissorTest(state.scissorTest);
    }
    process({
      count,
      material
    }) {
      const renderer = this.renderer;
      if (!renderer) {
        throw new Error("No renderer");
      }
      if (!this.target) {
        throw new Error("No target");
      }
      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;
      material.uniforms.targetBase.value = 0;
      material.uniforms.targetCount.value = count;
      let baseIndex = 0;
      while (baseIndex < count) {
        const layer = Math.floor(baseIndex / layerSize);
        const layerBase = layer * layerSize;
        const layerYEnd = Math.min(
          SPLAT_TEX_HEIGHT,
          Math.ceil((count - layerBase) / SPLAT_TEX_WIDTH)
        );
        material.uniforms.targetLayer.value = layer;
        renderer.setPixelRatio(1);
        renderer.setRenderTarget(this.target, layer);
        renderer.xr.isPresenting = false;
        renderer.autoClear = false;
        renderer.setScissorTest(true);
        renderer.setScissor(0, 0, SPLAT_TEX_WIDTH, layerYEnd);
        renderer.render(_Readback.scene, _Readback.camera);
        baseIndex += SPLAT_TEX_WIDTH * layerYEnd;
      }
      this.count = count;
    }
    async read({
      readback
    }) {
      const renderer = this.renderer;
      if (!renderer) {
        throw new Error("No renderer");
      }
      if (!this.target) {
        throw new Error("No target");
      }
      const roundedCount = Math.ceil(this.count / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;
      if (readback.byteLength < roundedCount * 4) {
        throw new Error(
          \`Readback buffer too small: \${readback.byteLength} < \${roundedCount * 4}\`
        );
      }
      const readbackUint8 = new Uint8Array(
        readback instanceof ArrayBuffer ? readback : readback.buffer
      );
      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;
      let baseIndex = 0;
      const promises = [];
      while (baseIndex < this.count) {
        const layer = Math.floor(baseIndex / layerSize);
        const layerBase = layer * layerSize;
        const layerYEnd = Math.min(
          SPLAT_TEX_HEIGHT,
          Math.ceil((this.count - layerBase) / SPLAT_TEX_WIDTH)
        );
        renderer.setPixelRatio(1);
        renderer.setRenderTarget(this.target, layer);
        const readbackSize = SPLAT_TEX_WIDTH * layerYEnd * 4;
        const subReadback = readbackUint8.subarray(
          layerBase * 4,
          layerBase * 4 + readbackSize
        );
        const promise = renderer == null ? void 0 : renderer.readRenderTargetPixelsAsync(
          this.target,
          0,
          0,
          SPLAT_TEX_WIDTH,
          layerYEnd,
          subReadback
        );
        promises.push(promise);
        baseIndex += SPLAT_TEX_WIDTH * layerYEnd;
      }
      return Promise.all(promises).then(() => readback);
    }
    // Perform render operation to run the Rgba8Readback program
    // but don't perform the readback yet.
    render({
      reader,
      count,
      renderer
    }) {
      this.renderer = renderer || this.renderer;
      if (!this.renderer) {
        throw new Error("No renderer");
      }
      this.ensureCapacity(count);
      const { program, material } = this.prepareProgramMaterial(reader);
      program.update();
      const renderState = this.saveRenderState(this.renderer);
      this.process({ count, material });
      this.resetRenderState(this.renderer, renderState);
    }
    // Perform a readback of the render target, returning a buffer of the
    // given type.
    async readback({
      readback
    }) {
      if (!this.renderer) {
        throw new Error("No renderer");
      }
      const renderState = this.saveRenderState(this.renderer);
      const promise = this.read({ readback });
      this.resetRenderState(this.renderer, renderState);
      return promise;
    }
    // Perform a render and readback operation for the given Rgba8Readback,
    // and readback buffer (call ensureBuffer first).
    async renderReadback({
      reader,
      count,
      renderer,
      readback
    }) {
      this.renderer = renderer || this.renderer;
      if (!this.renderer) {
        throw new Error("No renderer");
      }
      this.ensureCapacity(count);
      const { program, material } = this.prepareProgramMaterial(reader);
      program.update();
      const renderState = this.saveRenderState(this.renderer);
      this.process({ count, material });
      const promise = this.read({ readback });
      this.resetRenderState(this.renderer, renderState);
      return promise;
    }
    getTexture() {
      var _a2;
      return (_a2 = this.target) == null ? void 0 : _a2.texture;
    }
  };
  _Readback.programTemplate = null;
  _Readback.readbackProgram = /* @__PURE__ */ new Map();
  _Readback.geometry = new PlaneGeometry(2, 2);
  _Readback.mesh = new Mesh(
    _Readback.geometry,
    new RawShaderMaterial({ visible: false })
  );
  _Readback.scene = new Scene().add(_Readback.mesh);
  _Readback.camera = new Camera();
  let Readback = _Readback;
  const _RgbaArray = class _RgbaArray {
    constructor(options = {}) {
      this.capacity = 0;
      this.count = 0;
      this.array = null;
      this.readback = null;
      this.source = null;
      this.needsUpdate = true;
      this.dyno = new DynoUniform({
        key: "rgbaArray",
        type: TRgbaArray,
        globals: () => [defineRgbaArray],
        value: {
          texture: _RgbaArray.getEmpty(),
          count: 0
        },
        update: (value) => {
          var _a2;
          value.texture = ((_a2 = this.readback) == null ? void 0 : _a2.getTexture()) ?? this.source ?? _RgbaArray.getEmpty();
          value.count = this.count;
          return value;
        }
      });
      if (options.array) {
        this.array = options.array;
        this.capacity = Math.floor(this.array.length / 4);
        this.capacity = Math.floor(this.capacity / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;
        this.count = Math.min(
          this.capacity,
          options.count ?? Number.POSITIVE_INFINITY
        );
      } else {
        this.capacity = options.capacity ?? 0;
        this.count = 0;
      }
    }
    // Free up resources
    dispose() {
      if (this.readback) {
        this.readback.dispose();
        this.readback = null;
      }
      if (this.source) {
        this.source.dispose();
        this.source = null;
      }
    }
    // Ensure that our array is large enough to hold capacity RGBA8 values.
    ensureCapacity(capacity) {
      var _a2;
      if (!this.array || capacity > (((_a2 = this.array) == null ? void 0 : _a2.length) ?? 0) / 4) {
        this.capacity = getTextureSize(capacity).maxSplats;
        const newArray = new Uint8Array(this.capacity * 4);
        if (this.array) {
          newArray.set(this.array);
        }
        this.array = newArray;
      }
      return this.array;
    }
    // Get the THREE.DataArrayTexture from either the readback or the source.
    getTexture() {
      var _a2;
      let texture = (_a2 = this.readback) == null ? void 0 : _a2.getTexture();
      if (this.source || this.array) {
        texture = this.maybeUpdateSource();
      }
      return texture ?? _RgbaArray.getEmpty();
    }
    // Create or get a THREE.DataArrayTexture from the data array.
    maybeUpdateSource() {
      if (!this.array) {
        throw new Error("No array");
      }
      if (this.needsUpdate || !this.source) {
        this.needsUpdate = false;
        if (this.source) {
          const { width, height, depth } = this.source.image;
          if (this.capacity !== width * height * depth) {
            this.source.dispose();
            this.source = null;
          }
        }
        if (!this.source) {
          const { width, height, depth } = getTextureSize(this.capacity);
          this.source = new DataArrayTexture(
            this.array,
            width,
            height,
            depth
          );
          this.source.format = RGBAFormat;
          this.source.type = UnsignedByteType;
          this.source.internalFormat = "RGBA8";
          this.source.needsUpdate = true;
        } else if (this.array.buffer !== this.source.image.data.buffer) {
          this.source.image.data = new Uint8Array(this.array.buffer);
        }
        this.source.needsUpdate = true;
      }
      return this.source;
    }
    // Generate the RGBA8 values from a Rgba8Readback dyno program.
    render({
      reader,
      count,
      renderer
    }) {
      if (!this.readback) {
        this.readback = new Readback({ renderer });
      }
      this.readback.render({ reader, count, renderer });
      this.capacity = this.readback.capacity;
      this.count = this.readback.count;
    }
    // Extract the RGBA8 values from a PackedSplats collection.
    fromPackedSplats({
      packedSplats,
      base,
      count,
      renderer
    }) {
      const { dynoSplats, dynoBase, dynoCount, reader } = _RgbaArray.makeDynos();
      dynoSplats.packedSplats = packedSplats;
      dynoBase.value = base;
      dynoCount.value = count;
      this.render({ reader, count, renderer });
      return this;
    }
    // Read back the RGBA8 values from the readback buffer.
    async read() {
      if (!this.readback) {
        throw new Error("No readback");
      }
      if (!this.array || this.array.length < this.count * 4) {
        this.array = new Uint8Array(this.capacity * 4);
      }
      const result = await this.readback.readback({ readback: this.array });
      return result.subarray(0, this.count * 4);
    }
    // Can be used where you need an uninitialized THREE.DataArrayTexture like
    // a uniform you will update with the result of this.getTexture() later.
    static getEmpty() {
      if (!_RgbaArray.emptySource) {
        const emptyArray = new Uint8Array(1 * 4);
        _RgbaArray.emptySource = new DataArrayTexture(emptyArray, 1, 1, 1);
        _RgbaArray.emptySource.format = RGBAFormat;
        _RgbaArray.emptySource.type = UnsignedByteType;
        _RgbaArray.emptySource.internalFormat = "RGBA8";
        _RgbaArray.emptySource.needsUpdate = true;
      }
      return _RgbaArray.emptySource;
    }
    // Create a dyno program that can extract RGBA8 values from a PackedSplats
    static makeDynos() {
      if (!_RgbaArray.dynos) {
        const dynoSplats = new DynoPackedSplats();
        const dynoBase = new DynoInt({ value: 0 });
        const dynoCount = new DynoInt({ value: 0 });
        const reader = dynoBlock(
          { index: "int" },
          { rgba8: "vec4" },
          ({ index }) => {
            if (!index) {
              throw new Error("index is undefined");
            }
            index = add(index, dynoBase);
            const gsplat = readPackedSplatRange(
              dynoSplats,
              index,
              dynoBase,
              dynoCount
            );
            return { rgba8: splitGsplat(gsplat).outputs.rgba };
          }
        );
        _RgbaArray.dynos = { dynoSplats, dynoBase, dynoCount, reader };
      }
      return _RgbaArray.dynos;
    }
  };
  _RgbaArray.emptySource = null;
  _RgbaArray.dynos = null;
  let RgbaArray = _RgbaArray;
  const TRgbaArray = { type: "RgbaArray" };
  const defineRgbaArray = unindent(\`
  struct RgbaArray {
    sampler2DArray texture;
    int count;
  };
\`);
  function readRgbaArray(rgba, index) {
    const dyno2 = new Dyno({
      inTypes: { rgba: TRgbaArray, index: "int" },
      outTypes: { rgba: "vec4" },
      inputs: { rgba, index },
      globals: () => [defineRgbaArray],
      statements: ({ inputs, outputs }) => unindentLines(\`
        if ((index >= 0) && (index < \${inputs.rgba}.count)) {
          \${outputs.rgba} = texelFetch(\${inputs.rgba}.texture, splatTexCoord(index), 0);
        } else {
          \${outputs.rgba} = vec4(0.0, 0.0, 0.0, 0.0);
        }
      \`)
    });
    return dyno2.outputs.rgba;
  }
  function sdfTypeToNumber(type) {
    switch (type) {
      case "all":
        return 0;
      case "plane":
        return 1;
      case "sphere":
        return 2;
      case "box":
        return 3;
      case "ellipsoid":
        return 4;
      case "cylinder":
        return 5;
      case "capsule":
        return 6;
      case "infinite_cone":
        return 7;
      default:
        throw new Error(\`Unknown SDF type: \${type}\`);
    }
  }
  function rgbaBlendModeToNumber(mode) {
    switch (mode) {
      case "multiply":
        return 0;
      case "set_rgb":
        return 1;
      case "add_rgba":
        return 2;
      default:
        throw new Error(\`Unknown blend mode: \${mode}\`);
    }
  }
  class SplatEditSdf extends Object3D {
    constructor(options = {}) {
      super();
      const { type, invert, opacity, color, displace, radius } = options;
      this.type = type ?? "sphere";
      this.invert = invert ?? false;
      this.opacity = opacity ?? 1;
      this.color = color ?? new Color(1, 1, 1);
      this.displace = displace ?? new Vector3(0, 0, 0);
      this.radius = radius ?? 0;
    }
  }
  const _SplatEdit = class _SplatEdit extends Object3D {
    constructor(options = {}) {
      const {
        name,
        rgbaBlendMode = "multiply",
        sdfSmooth = 0,
        softEdge = 0,
        invert = false,
        sdfs = null
      } = options;
      super();
      this.rgbaBlendMode = rgbaBlendMode;
      this.sdfSmooth = sdfSmooth;
      this.softEdge = softEdge;
      this.invert = invert;
      this.sdfs = sdfs;
      this.ordering = _SplatEdit.nextOrdering++;
      this.name = name ?? \`Edit \${this.ordering}\`;
    }
    addSdf(sdf) {
      if (this.sdfs == null) {
        this.sdfs = [];
      }
      this.sdfs.push(sdf);
    }
    removeSdf(sdf) {
      if (this.sdfs == null) {
        return;
      }
      this.sdfs = this.sdfs.filter((s) => s !== sdf);
    }
  };
  _SplatEdit.nextOrdering = 1;
  let SplatEdit = _SplatEdit;
  class SplatEdits {
    constructor({ maxSdfs, maxEdits }) {
      this.maxSdfs = Math.max(16, maxSdfs ?? 0);
      this.numSdfs = 0;
      this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);
      this.sdfFloatData = new Float32Array(this.sdfData.buffer);
      this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);
      this.dynoSdfArray = new DynoUniform({
        key: "sdfArray",
        type: SdfArray,
        globals: () => [defineSdfArray],
        value: {
          numSdfs: 0,
          sdfTexture: this.sdfTexture
        },
        update: (uniform) => {
          uniform.numSdfs = this.numSdfs;
          uniform.sdfTexture = this.sdfTexture;
          return uniform;
        }
      });
      this.maxEdits = Math.max(16, maxEdits ?? 0);
      this.numEdits = 0;
      this.editData = new Uint32Array(this.maxEdits * 4);
      this.editFloatData = new Float32Array(this.editData.buffer);
      this.dynoNumEdits = new DynoInt({ value: 0 });
      this.dynoEdits = this.newEdits(this.editData, this.maxEdits);
    }
    newSdfTexture(data, maxSdfs) {
      const texture = new DataTexture(
        data,
        8,
        maxSdfs,
        RGBAIntegerFormat,
        UnsignedIntType
      );
      texture.internalFormat = "RGBA32UI";
      texture.needsUpdate = true;
      return texture;
    }
    newEdits(data, maxEdits) {
      return new DynoUniform({
        key: "edits",
        type: "uvec4",
        count: maxEdits,
        globals: () => [defineEdit],
        value: data
      });
    }
    // Ensure our SDF texture and edits uniform array have enough capacity.
    // Reallocate if not.
    ensureCapacity({
      maxSdfs,
      maxEdits
    }) {
      let dynoUpdated = false;
      if (maxSdfs > this.sdfTexture.image.height) {
        this.sdfTexture.dispose();
        this.maxSdfs = Math.max(this.maxSdfs * 2, maxSdfs);
        this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);
        this.sdfFloatData = new Float32Array(this.sdfData.buffer);
        this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);
      }
      if (maxEdits > (this.dynoEdits.count ?? 0)) {
        this.maxEdits = Math.max(this.maxEdits * 2, maxEdits);
        this.editData = new Uint32Array(this.maxEdits * 4);
        this.editFloatData = new Float32Array(this.editData.buffer);
        this.dynoEdits = this.newEdits(this.editData, this.maxEdits);
        dynoUpdated = true;
      }
      return dynoUpdated;
    }
    updateEditData(offset, value) {
      const updated = this.editData[offset] !== value;
      this.editData[offset] = value;
      return updated;
    }
    updateEditFloatData(offset, value) {
      tempFloat32[0] = value;
      const updated = this.editFloatData[offset] !== tempFloat32[0];
      if (updated) {
        this.editFloatData[offset] = tempFloat32[0];
      }
      return updated;
    }
    encodeEdit(editIndex, {
      sdfFirst,
      sdfCount,
      invert,
      rgbaBlendMode,
      softEdge,
      sdfSmooth
    }) {
      const base = editIndex * 4;
      let updated = false;
      updated = this.updateEditData(base + 0, rgbaBlendMode | (invert ? 1 << 8 : 0)) || updated;
      updated = this.updateEditData(base + 1, sdfFirst | sdfCount << 16) || updated;
      updated = this.updateEditFloatData(base + 2, softEdge) || updated;
      updated = this.updateEditFloatData(base + 3, sdfSmooth) || updated;
      return updated;
    }
    updateSdfData(offset, value) {
      const updated = this.sdfData[offset] !== value;
      this.sdfData[offset] = value;
      return updated;
    }
    updateSdfFloatData(offset, value) {
      tempFloat32[0] = value;
      const updated = this.sdfFloatData[offset] !== tempFloat32[0];
      if (updated) {
        this.sdfFloatData[offset] = tempFloat32[0];
      }
      return updated;
    }
    encodeSdf(sdfIndex, {
      sdfType,
      invert,
      center,
      quaternion,
      scale,
      sizes
    }, values) {
      const base = sdfIndex * (8 * 4);
      const flags = sdfType | (invert ? 1 << 8 : 0);
      let updated = false;
      updated = this.updateSdfFloatData(base + 0, (center == null ? void 0 : center.x) ?? 0) || updated;
      updated = this.updateSdfFloatData(base + 1, (center == null ? void 0 : center.y) ?? 0) || updated;
      updated = this.updateSdfFloatData(base + 2, (center == null ? void 0 : center.z) ?? 0) || updated;
      updated = this.updateSdfData(base + 3, flags) || updated;
      updated = this.updateSdfFloatData(base + 4, (quaternion == null ? void 0 : quaternion.x) ?? 0) || updated;
      updated = this.updateSdfFloatData(base + 5, (quaternion == null ? void 0 : quaternion.y) ?? 0) || updated;
      updated = this.updateSdfFloatData(base + 6, (quaternion == null ? void 0 : quaternion.z) ?? 0) || updated;
      updated = this.updateSdfFloatData(base + 7, (quaternion == null ? void 0 : quaternion.w) ?? 0) || updated;
      updated = this.updateSdfFloatData(base + 8, (scale == null ? void 0 : scale.x) ?? 0) || updated;
      updated = this.updateSdfFloatData(base + 9, (scale == null ? void 0 : scale.y) ?? 0) || updated;
      updated = this.updateSdfFloatData(base + 10, (scale == null ? void 0 : scale.z) ?? 0) || updated;
      updated = this.updateSdfData(base + 11, 0) || updated;
      updated = this.updateSdfFloatData(base + 12, (sizes == null ? void 0 : sizes.x) ?? 0) || updated;
      updated = this.updateSdfFloatData(base + 13, (sizes == null ? void 0 : sizes.y) ?? 0) || updated;
      updated = this.updateSdfFloatData(base + 14, (sizes == null ? void 0 : sizes.z) ?? 0) || updated;
      updated = this.updateSdfFloatData(base + 15, (sizes == null ? void 0 : sizes.w) ?? 0) || updated;
      const nValues = Math.min(4, values.length);
      for (let i2 = 0; i2 < nValues; ++i2) {
        const vBase = base + 16 + i2 * 4;
        updated = this.updateSdfFloatData(vBase + 0, values[i2].x) || updated;
        updated = this.updateSdfFloatData(vBase + 1, values[i2].y) || updated;
        updated = this.updateSdfFloatData(vBase + 2, values[i2].z) || updated;
        updated = this.updateSdfFloatData(vBase + 3, values[i2].w) || updated;
      }
      return updated;
    }
    // Update the SDFs and edits from an array of SplatEdits and their
    // associated SplatEditSdfs, updating it for the dyno shader program.
    update(edits) {
      const sdfCount = edits.reduce((total, { sdfs }) => total + sdfs.length, 0);
      const dynoUpdated = this.ensureCapacity({
        maxEdits: edits.length,
        maxSdfs: sdfCount
      });
      const values = [new Vector4(), new Vector4()];
      const center = new Vector3();
      const quaternion = new Quaternion();
      const scale = new Vector3();
      const sizes = new Vector4();
      let sdfIndex = 0;
      let updated = dynoUpdated;
      if (edits.length !== this.dynoNumEdits.value) {
        this.dynoNumEdits.value = edits.length;
        this.numEdits = edits.length;
        updated = true;
      }
      for (const [editIndex, { edit, sdfs }] of edits.entries()) {
        updated = this.encodeEdit(editIndex, {
          sdfFirst: sdfIndex,
          sdfCount: sdfs.length,
          invert: edit.invert,
          rgbaBlendMode: rgbaBlendModeToNumber(edit.rgbaBlendMode),
          softEdge: edit.softEdge,
          sdfSmooth: edit.sdfSmooth
        }) || updated;
        let sdfUpdated = false;
        for (const sdf of sdfs) {
          sizes.set(sdf.scale.x, sdf.scale.y, sdf.scale.z, sdf.radius);
          sdf.scale.setScalar(1);
          sdf.updateMatrixWorld();
          const worldToSdf = sdf.matrixWorld.clone().invert();
          worldToSdf.decompose(center, quaternion, scale);
          sdf.scale.set(sizes.x, sizes.y, sizes.z);
          sdf.updateMatrixWorld();
          values[0].set(sdf.color.r, sdf.color.g, sdf.color.b, sdf.opacity);
          values[1].set(sdf.displace.x, sdf.displace.y, sdf.displace.z, 1);
          sdfUpdated = this.encodeSdf(
            sdfIndex,
            {
              sdfType: sdfTypeToNumber(sdf.type),
              invert: sdf.invert,
              center,
              quaternion,
              scale,
              sizes
            },
            values
          ) || sdfUpdated;
          sdfIndex += 1;
        }
        this.numSdfs = sdfIndex;
        if (sdfUpdated) {
          this.sdfTexture.needsUpdate = true;
        }
        updated || (updated = sdfUpdated);
      }
      return { updated, dynoUpdated };
    }
    // Modify a Gsplat in a dyno shader program using the current edits and SDFs.
    modify(gsplat) {
      return applyGsplatRgbaDisplaceEdits(
        gsplat,
        this.dynoSdfArray,
        this.dynoNumEdits,
        this.dynoEdits
      );
    }
  }
  const SdfArray = { type: "SdfArray" };
  const defineSdfArray = unindent(\`
  struct SdfArray {
    int numSdfs;
    usampler2D sdfTexture;
  };

  void unpackSdfArray(
    usampler2D sdfTexture, int sdfIndex, out uint flags,
    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,
    int numValues, out vec4 values[4]
  ) {
    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);
    flags = temp.w;
    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);
    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);
    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);
    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    for (int i = 0; i < numValues; ++i) {
      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);
      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));
    }
  }

  const uint SDF_FLAG_TYPE = 0xFFu;
  const uint SDF_FLAG_INVERT = 1u << 8u;

  const uint SDF_TYPE_ALL = 0u;
  const uint SDF_TYPE_PLANE = 1u;
  const uint SDF_TYPE_SPHERE = 2u;
  const uint SDF_TYPE_BOX = 3u;
  const uint SDF_TYPE_ELLIPSOID = 4u;
  const uint SDF_TYPE_CYLINDER = 5u;
  const uint SDF_TYPE_CAPSULE = 6u;
  const uint SDF_TYPE_INFINITE_CONE = 7u;

  float evaluateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 outValues[4]
  ) {
    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;
    float maxExp = -1.0 / 0.0;
    for (int i = 0; i < numValues; ++i) {
        outValues[i] = vec4(0.0);
    }

    uint flags;
    vec3 center, scale;
    vec4 quaternion, sizes;
    vec4 values[4];

    int sdfLast = min(sdfFirst + sdfCount, numSdfs);
    for (int index = sdfFirst; index < sdfLast; ++index) {
      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);
      uint sdfType = flags & SDF_FLAG_TYPE;
      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;

      float distance;
      switch (sdfType) {
        case SDF_TYPE_ALL:
          distance = -1.0 / 0.0;
          break;
        case SDF_TYPE_PLANE: {
          distance = sdfPos.z;
          break;
        }
        case SDF_TYPE_SPHERE: {
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_BOX: {
          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;
          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;
          break;
        }
        case SDF_TYPE_ELLIPSOID: {
          vec3 sizes = sizes.xyz;
          float k0 = length(sdfPos / sizes);
          float k1 = length(sdfPos / dot(sizes, sizes));
          distance = k0 * (k0 - 1.0) / k1;
          break;
        }
        case SDF_TYPE_CYLINDER: {
          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;
          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
          break;
        }
        case SDF_TYPE_CAPSULE: {
          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_INFINITE_CONE: {
          float angle = 0.25 * PI * sizes.w;
          vec2 c = vec2(sin(angle), cos(angle));
          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);
          float d = length(q - c * max(dot(q, c), 0.0));
          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);
          break;
        }
      }

      if ((flags & SDF_FLAG_INVERT) != 0u) {
        distance = -distance;
      }

      if (smoothK == 0.0) {
        if (distance < distanceAccum) {
          distanceAccum = distance;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] = values[i];
          }
        }
      } else {
        float scaledDistance = -distance / smoothK;
        if (scaledDistance > maxExp) {
          float scale = exp(maxExp - scaledDistance);
          distanceAccum *= scale;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] *= scale;
          }
          maxExp = scaledDistance;
        }

        float weight = exp(scaledDistance - maxExp);
        distanceAccum += weight;
        for (int i = 0; i < numValues; ++i) {
          outValues[i] += weight * values[i];
        }
      }
    }

    if (smoothK == 0.0) {
      return distanceAccum;
    } else {
      // Very distant SDFs may result in 0 accumulation
      if (distanceAccum == 0.0) {
        return 1.0 / 0.0;
      }
      for (int i = 0; i < numValues; ++i) {
        outValues[i] /= distanceAccum;
      }
      return (-log(distanceAccum) - maxExp) * smoothK;
    }
  }

  float modulateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 values[4],
    float softEdge, bool invert
  ) {
    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);
    if (invert) {
      distance = -distance;
    }

    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)
      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);
  }
\`);
  const defineEdit = unindent(\`
  const uint EDIT_FLAG_BLEND = 0xFFu;
  const uint EDIT_BLEND_MULTIPLY = 0u;
  const uint EDIT_BLEND_SET_RGB = 1u;
  const uint EDIT_BLEND_ADD_RGBA = 2u;
  const uint EDIT_FLAG_INVERT = 0x100u;

  void decodeEdit(
    uvec4 packedEdit, out int sdfFirst, out int sdfCount,
    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth
  ) {
    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;
    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;

    sdfFirst = int(packedEdit.y & 0xFFFFu);
    sdfCount = int(packedEdit.y >> 16u);

    softEdge = uintBitsToFloat(packedEdit.z);
    sdfSmooth = uintBitsToFloat(packedEdit.w);
  }

  void applyRgbaDisplaceEdit(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,
    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba
  ) {
    vec4 values[4];
    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);
    // On Android, moving values[0] is necessary to work around a compiler bug.
    vec4 sdfRgba = values[0];
    vec4 sdfDisplaceScale = values[1];

    vec4 target;
    switch (rgbaBlendMode) {
      case EDIT_BLEND_MULTIPLY:
        target = rgba * sdfRgba;
        break;
      case EDIT_BLEND_SET_RGB:
        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);
        break;
      case EDIT_BLEND_ADD_RGBA:
        target = rgba + sdfRgba;
        break;
      default:
        // Debug output if blend mode not set
        target = vec4(fract(pos), 1.0);
    }
    rgba = mix(rgba, target, modulate);
    pos += sdfDisplaceScale.xyz * modulate;
  }

  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {
    int sdfFirst, sdfCount;
    bool invert;
    uint rgbaBlendMode;
    float softEdge, sdfSmooth;
    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);
    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);
  }
\`);
  function applyGsplatRgbaDisplaceEdits(gsplat, sdfArray, numEdits, rgbaDisplaceEdits) {
    const dyno2 = new Dyno({
      inTypes: {
        gsplat: Gsplat,
        sdfArray: SdfArray,
        numEdits: "int",
        rgbaDisplaceEdits: "uvec4"
      },
      outTypes: { gsplat: Gsplat },
      globals: () => [defineSdfArray, defineEdit],
      inputs: { gsplat, sdfArray, numEdits, rgbaDisplaceEdits },
      statements: ({ inputs, outputs }) => {
        const { sdfArray: sdfArray2, numEdits: numEdits2, rgbaDisplaceEdits: rgbaDisplaceEdits2 } = inputs;
        const { gsplat: gsplat2 } = outputs;
        return unindentLines(\`
        \${gsplat2} = \${inputs.gsplat};
        if (isGsplatActive(\${gsplat2}.flags)) {
          for (int editIndex = 0; editIndex < \${numEdits2}; ++editIndex) {
            applyPackedRgbaDisplaceEdit(
              \${rgbaDisplaceEdits2}[editIndex], \${sdfArray2}.sdfTexture, \${sdfArray2}.numSdfs,
              \${gsplat2}.center, \${gsplat2}.rgba
            );
          }
        }
      \`);
      }
    });
    return dyno2.outputs.gsplat;
  }
  const tempFloat32 = new Float32Array(1);
  class SplatTransformer {
    // Create the dyno uniforms that parameterize the transform, setting them
    // to initial values that are different from any valid transform.
    constructor() {
      this.scale = new DynoFloat({ value: Number.NEGATIVE_INFINITY });
      this.rotate = new DynoVec4({
        value: new Quaternion(
          Number.POSITIVE_INFINITY,
          Number.POSITIVE_INFINITY,
          Number.POSITIVE_INFINITY,
          Number.POSITIVE_INFINITY
        )
      });
      this.translate = new DynoVec3({
        value: new Vector3(
          Number.POSITIVE_INFINITY,
          Number.POSITIVE_INFINITY,
          Number.POSITIVE_INFINITY
        )
      });
    }
    // Apply the transform to a Vec3 position in a dyno program.
    apply(position) {
      return transformPos(position, {
        scale: this.scale,
        rotate: this.rotate,
        translate: this.translate
      });
    }
    applyDir(dir) {
      return transformDir(dir, {
        rotate: this.rotate
      });
    }
    // Apply the transform to a Gsplat in a dyno program.
    applyGsplat(gsplat) {
      return transformGsplat(gsplat, {
        scale: this.scale,
        rotate: this.rotate,
        translate: this.translate
      });
    }
    // Update the uniforms to match the given transform matrix.
    updateFromMatrix(transform) {
      const scale = new Vector3();
      const quaternion = new Quaternion();
      const position = new Vector3();
      transform.decompose(position, quaternion, scale);
      const newScale = (scale.x + scale.y + scale.z) / 3;
      let updated = false;
      if (newScale !== this.scale.value) {
        this.scale.value = newScale;
        updated = true;
      }
      if (!position.equals(this.translate.value)) {
        this.translate.value.copy(position);
        updated = true;
      }
      if (!quaternion.equals(this.rotate.value)) {
        this.rotate.value.copy(quaternion);
        updated = true;
      }
      return updated;
    }
    // Update this transform to match the object's to-world transform.
    update(object) {
      object.updateMatrixWorld();
      return this.updateFromMatrix(object.matrixWorld);
    }
  }
  class SplatGenerator extends Object3D {
    constructor({
      numSplats,
      generator,
      construct,
      update
    }) {
      super();
      this.numSplats = numSplats ?? 0;
      this.generator = generator;
      this.frameUpdate = update;
      this.version = 0;
      if (construct) {
        const constructed = construct(this);
        Object.assign(this, constructed);
      }
    }
    updateVersion() {
      this.version += 1;
    }
    set needsUpdate(value) {
      if (value) {
        this.updateVersion();
      }
    }
  }
  const _SplatMesh = class _SplatMesh extends SplatGenerator {
    constructor(options = {}) {
      const transform = new SplatTransformer();
      const viewToWorld = new SplatTransformer();
      const worldToView = new SplatTransformer();
      const viewToObject = new SplatTransformer();
      const recolor = new DynoVec4({
        value: new Vector4(
          Number.NEGATIVE_INFINITY,
          Number.NEGATIVE_INFINITY,
          Number.NEGATIVE_INFINITY,
          Number.NEGATIVE_INFINITY
        )
      });
      const time = new DynoFloat({ value: 0 });
      const deltaTime = new DynoFloat({ value: 0 });
      const context = {
        transform,
        viewToWorld,
        worldToView,
        viewToObject,
        recolor,
        time,
        deltaTime
      };
      super({
        update: ({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits }) => this.update({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits })
      });
      this.isInitialized = false;
      this.recolor = new Color(1, 1, 1);
      this.opacity = 1;
      this.enableViewToObject = false;
      this.enableViewToWorld = false;
      this.enableWorldToView = false;
      this.skinning = null;
      this.edits = null;
      this.rgbaDisplaceEdits = null;
      this.splatRgba = null;
      this.maxSh = 3;
      this.packedSplats = options.packedSplats ?? new PackedSplats();
      this.numSplats = this.packedSplats.numSplats;
      this.editable = options.editable ?? true;
      this.onFrame = options.onFrame;
      this.context = context;
      this.objectModifier = options.objectModifier;
      this.worldModifier = options.worldModifier;
      this.updateGenerator();
      if (options.url || options.fileBytes || options.constructSplats || options.packedSplats && !options.packedSplats.isInitialized) {
        this.initialized = this.asyncInitialize(options).then(async () => {
          this.updateGenerator();
          this.isInitialized = true;
          if (options.onLoad) {
            const maybePromise = options.onLoad(this);
            if (maybePromise instanceof Promise) {
              await maybePromise;
            }
          }
          return this;
        });
      } else {
        this.isInitialized = true;
        this.initialized = Promise.resolve(this);
        if (options.onLoad) {
          const maybePromise = options.onLoad(this);
          if (maybePromise instanceof Promise) {
            this.initialized = maybePromise.then(() => this);
          }
        }
      }
    }
    async asyncInitialize(options) {
      const { url, fileBytes, fileType, fileName, maxSplats, constructSplats } = options;
      if (url || fileBytes || constructSplats) {
        const packedSplatsOptions = {
          url,
          fileBytes,
          fileType,
          fileName,
          maxSplats,
          construct: constructSplats
        };
        this.packedSplats.reinitialize(packedSplatsOptions);
      }
      if (this.packedSplats) {
        await this.packedSplats.initialized;
        this.numSplats = this.packedSplats.numSplats;
        this.updateGenerator();
      }
    }
    static async staticInitialize() {
      await __wbg_init();
      _SplatMesh.isStaticInitialized = true;
    }
    // Creates a new Gsplat with the provided parameters (all values in "float" space,
    // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,
    // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential
    // doubling strategy to fit the new data, so it's fairly efficient to just
    // pushSplat(...) each Gsplat you want to create in a loop.
    pushSplat(center, scales, quaternion, opacity, color) {
      this.packedSplats.pushSplat(center, scales, quaternion, opacity, color);
    }
    // This method iterates over all Gsplats in this instance's packedSplats,
    // invoking the provided callback with index: number in 0..=(this.numSplats-1) and
    // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
    // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).
    // Note that the objects passed in as center etc. are the same for every callback
    // invocation: these objects are reused for efficiency. Changing these values has
    // no effect as they are decoded/unpacked copies of the underlying data. To update
    // the packedSplats, call .packedSplats.setSplat(index, center, scales,
    // quaternion, opacity, color).
    forEachSplat(callback) {
      this.packedSplats.forEachSplat(callback);
    }
    // Call this when you are finished with the SplatMesh and want to free
    // any buffers it holds (via packedSplats).
    dispose() {
      this.packedSplats.dispose();
    }
    constructGenerator(context) {
      const { transform, viewToObject, recolor } = context;
      const generator = dynoBlock(
        { index: "int" },
        { gsplat: Gsplat },
        ({ index }) => {
          if (!index) {
            throw new Error("index is undefined");
          }
          let gsplat = readPackedSplat(this.packedSplats.dyno, index);
          if (this.maxSh >= 1) {
            const { sh1Texture, sh2Texture, sh3Texture } = this.ensureShTextures();
            if (sh1Texture) {
              const viewCenterInObject = viewToObject.translate;
              const { center } = splitGsplat(gsplat).outputs;
              const viewDir = normalize(sub(center, viewCenterInObject));
              let rgb = evaluateSH1(gsplat, sh1Texture, viewDir);
              if (this.maxSh >= 2 && sh2Texture) {
                rgb = add(rgb, evaluateSH2(gsplat, sh2Texture, viewDir));
              }
              if (this.maxSh >= 3 && sh3Texture) {
                rgb = add(rgb, evaluateSH3(gsplat, sh3Texture, viewDir));
              }
              let { rgba } = splitGsplat(gsplat).outputs;
              rgba = add(rgba, extendVec(rgb, dynoConst("float", 0)));
              gsplat = combineGsplat({ gsplat, rgba });
            }
          }
          if (this.splatRgba) {
            const rgba = readRgbaArray(this.splatRgba.dyno, index);
            gsplat = combineGsplat({ gsplat, rgba });
          }
          if (this.skinning) {
            gsplat = this.skinning.modify(gsplat);
          }
          if (this.objectModifier) {
            gsplat = this.objectModifier.apply({ gsplat }).gsplat;
          }
          gsplat = transform.applyGsplat(gsplat);
          const recolorRgba = mul(recolor, splitGsplat(gsplat).outputs.rgba);
          gsplat = combineGsplat({ gsplat, rgba: recolorRgba });
          if (this.rgbaDisplaceEdits) {
            gsplat = this.rgbaDisplaceEdits.modify(gsplat);
          }
          if (this.worldModifier) {
            gsplat = this.worldModifier.apply({ gsplat }).gsplat;
          }
          return { gsplat };
        }
      );
      this.generator = generator;
    }
    // Call this whenever something changes in the Gsplat processing pipeline,
    // for example changing maxSh or updating objectModifier or worldModifier.
    // Compiled generators are cached for efficiency and re-use when the same
    // pipeline structure emerges after successive changes.
    updateGenerator() {
      this.constructGenerator(this.context);
    }
    // This is called automatically by SparkRenderer and you should not have to
    // call it. It updates parameters for the generated pipeline and calls
    // updateGenerator() if the pipeline needs to change.
    update({
      time,
      viewToWorld,
      deltaTime,
      globalEdits
    }) {
      var _a2;
      this.numSplats = this.packedSplats.numSplats;
      this.context.time.value = time;
      this.context.deltaTime.value = deltaTime;
      _SplatMesh.dynoTime.value = time;
      const { transform, viewToObject, recolor } = this.context;
      let updated = transform.update(this);
      if (this.context.viewToWorld.updateFromMatrix(viewToWorld) && this.enableViewToWorld) {
        updated = true;
      }
      const worldToView = viewToWorld.clone().invert();
      if (this.context.worldToView.updateFromMatrix(worldToView) && this.enableWorldToView) {
        updated = true;
      }
      const objectToWorld = new Matrix4().compose(
        transform.translate.value,
        transform.rotate.value,
        new Vector3().setScalar(transform.scale.value)
      );
      const worldToObject = objectToWorld.invert();
      const viewToObjectMatrix = worldToObject.multiply(viewToWorld);
      if (viewToObject.updateFromMatrix(viewToObjectMatrix) && (this.enableViewToObject || this.packedSplats.extra.sh1)) {
        updated = true;
      }
      const newRecolor = new Vector4(
        this.recolor.r,
        this.recolor.g,
        this.recolor.b,
        this.opacity
      );
      if (!newRecolor.equals(recolor.value)) {
        recolor.value.copy(newRecolor);
        updated = true;
      }
      const edits = this.editable ? (this.edits ?? []).concat(globalEdits) : [];
      if (this.editable && !this.edits) {
        this.traverseVisible((node) => {
          if (node instanceof SplatEdit) {
            edits.push(node);
          }
        });
      }
      edits.sort((a, b) => a.ordering - b.ordering);
      const editsSdfs = edits.map((edit) => {
        if (edit.sdfs != null) {
          return { edit, sdfs: edit.sdfs };
        }
        const sdfs = [];
        edit.traverseVisible((node) => {
          if (node instanceof SplatEditSdf) {
            sdfs.push(node);
          }
        });
        return { edit, sdfs };
      });
      if (editsSdfs.length > 0 && !this.rgbaDisplaceEdits) {
        const edits2 = editsSdfs.length;
        const sdfs = editsSdfs.reduce(
          (total, edit) => total + edit.sdfs.length,
          0
        );
        this.rgbaDisplaceEdits = new SplatEdits({
          maxEdits: edits2,
          maxSdfs: sdfs
        });
        this.updateGenerator();
      }
      if (this.rgbaDisplaceEdits) {
        const editResult = this.rgbaDisplaceEdits.update(editsSdfs);
        updated || (updated = editResult.updated);
        if (editResult.dynoUpdated) {
          this.updateGenerator();
        }
      }
      if (updated) {
        this.updateVersion();
      }
      (_a2 = this.onFrame) == null ? void 0 : _a2.call(this, { mesh: this, time, deltaTime });
    }
    // This method conforms to the standard THREE.Raycaster API, performing object-ray
    // intersections using this method to populate the provided intersects[] array
    // with each intersection point.
    raycast(raycaster, intersects) {
      if (!this.packedSplats.packedArray || !this.packedSplats.numSplats) {
        return;
      }
      const { near, far, ray } = raycaster;
      const worldToMesh = this.matrixWorld.clone().invert();
      const worldToMeshRot = new Matrix3().setFromMatrix4(worldToMesh);
      const origin = ray.origin.clone().applyMatrix4(worldToMesh);
      const direction = ray.direction.clone().applyMatrix3(worldToMeshRot);
      const scales = new Vector3();
      worldToMesh.decompose(new Vector3(), new Quaternion(), scales);
      (scales.x * scales.y * scales.z) ** (1 / 3);
      const RAYCAST_ELLIPSOID = true;
      const distances = raycast_splats(
        origin.x,
        origin.y,
        origin.z,
        direction.x,
        direction.y,
        direction.z,
        near,
        far,
        this.packedSplats.numSplats,
        this.packedSplats.packedArray,
        RAYCAST_ELLIPSOID
      );
      for (const distance of distances) {
        const point = ray.direction.clone().multiplyScalar(distance).add(ray.origin);
        intersects.push({
          distance,
          point,
          object: this
        });
      }
    }
    ensureShTextures() {
      if (!this.packedSplats.extra.sh1) {
        return {};
      }
      let sh1Texture = this.packedSplats.extra.sh1Texture;
      if (!sh1Texture) {
        let sh1 = this.packedSplats.extra.sh1;
        const { width, height, depth, maxSplats } = getTextureSize(
          sh1.length / 2
        );
        if (sh1.length < maxSplats * 2) {
          const newSh1 = new Uint32Array(maxSplats * 2);
          newSh1.set(sh1);
          this.packedSplats.extra.sh1 = newSh1;
          sh1 = newSh1;
        }
        const texture = new DataArrayTexture(sh1, width, height, depth);
        texture.format = RGIntegerFormat;
        texture.type = UnsignedIntType;
        texture.internalFormat = "RG32UI";
        texture.needsUpdate = true;
        sh1Texture = new DynoUsampler2DArray({
          value: texture,
          key: "sh1"
        });
        this.packedSplats.extra.sh1Texture = sh1Texture;
      }
      if (!this.packedSplats.extra.sh2) {
        return { sh1Texture };
      }
      let sh2Texture = this.packedSplats.extra.sh2Texture;
      if (!sh2Texture) {
        let sh2 = this.packedSplats.extra.sh2;
        const { width, height, depth, maxSplats } = getTextureSize(
          sh2.length / 4
        );
        if (sh2.length < maxSplats * 4) {
          const newSh2 = new Uint32Array(maxSplats * 4);
          newSh2.set(sh2);
          this.packedSplats.extra.sh2 = newSh2;
          sh2 = newSh2;
        }
        const texture = new DataArrayTexture(sh2, width, height, depth);
        texture.format = RGBAIntegerFormat;
        texture.type = UnsignedIntType;
        texture.internalFormat = "RGBA32UI";
        texture.needsUpdate = true;
        sh2Texture = new DynoUsampler2DArray({
          value: texture,
          key: "sh2"
        });
        this.packedSplats.extra.sh2Texture = sh2Texture;
      }
      if (!this.packedSplats.extra.sh3) {
        return { sh1Texture, sh2Texture };
      }
      let sh3Texture = this.packedSplats.extra.sh3Texture;
      if (!sh3Texture) {
        let sh3 = this.packedSplats.extra.sh3;
        const { width, height, depth, maxSplats } = getTextureSize(
          sh3.length / 4
        );
        if (sh3.length < maxSplats * 4) {
          const newSh3 = new Uint32Array(maxSplats * 4);
          newSh3.set(sh3);
          this.packedSplats.extra.sh3 = newSh3;
          sh3 = newSh3;
        }
        const texture = new DataArrayTexture(sh3, width, height, depth);
        texture.format = RGBAIntegerFormat;
        texture.type = UnsignedIntType;
        texture.internalFormat = "RGBA32UI";
        texture.needsUpdate = true;
        sh3Texture = new DynoUsampler2DArray({
          value: texture,
          key: "sh3"
        });
        this.packedSplats.extra.sh3Texture = sh3Texture;
      }
      return { sh1Texture, sh2Texture, sh3Texture };
    }
  };
  _SplatMesh.staticInitialized = _SplatMesh.staticInitialize();
  _SplatMesh.isStaticInitialized = false;
  _SplatMesh.dynoTime = new DynoFloat({ value: 0 });
  let SplatMesh = _SplatMesh;
  const defineEvaluateSH1 = unindent(\`
  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {
    // Extract sint7 values packed into 2 x uint32
    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;
    vec3 sh1_0 = vec3(ivec3(
      int(packed.x << 25u) >> 25,
      int(packed.x << 18u) >> 25,
      int(packed.x << 11u) >> 25
    )) / 63.0;
    vec3 sh1_1 = vec3(ivec3(
      int(packed.x << 4u) >> 25,
      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,
      int(packed.y << 22u) >> 25
    )) / 63.0;
    vec3 sh1_2 = vec3(ivec3(
      int(packed.y << 15u) >> 25,
      int(packed.y << 8u) >> 25,
      int(packed.y << 1u) >> 25
    )) / 63.0;

    return sh1_0 * (-0.4886025 * viewDir.y)
      + sh1_1 * (0.4886025 * viewDir.z)
      + sh1_2 * (-0.4886025 * viewDir.x);
  }
\`);
  const defineEvaluateSH2 = unindent(\`
  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {
    // Extract sint8 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);
    vec3 sh2_0 = vec3(ivec3(
      int(packed.x << 24u) >> 24,
      int(packed.x << 16u) >> 24,
      int(packed.x << 8u) >> 24
    )) / 127.0;
    vec3 sh2_1 = vec3(ivec3(
      int(packed.x) >> 24,
      int(packed.y << 24u) >> 24,
      int(packed.y << 16u) >> 24
    )) / 127.0;
    vec3 sh2_2 = vec3(ivec3(
      int(packed.y << 8u) >> 24,
      int(packed.y) >> 24,
      int(packed.z << 24u) >> 24
    )) / 127.0;
    vec3 sh2_3 = vec3(ivec3(
      int(packed.z << 16u) >> 24,
      int(packed.z << 8u) >> 24,
      int(packed.z) >> 24
    )) / 127.0;
    vec3 sh2_4 = vec3(ivec3(
      int(packed.w << 24u) >> 24,
      int(packed.w << 16u) >> 24,
      int(packed.w << 8u) >> 24
    )) / 127.0;

    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)
      + sh2_1 * (1.0925484 * viewDir.y * viewDir.z)
      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))
      + sh2_3 * (1.0925484 * viewDir.x * viewDir.z)
      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));
  }
\`);
  const defineEvaluateSH3 = unindent(\`
  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {
    // Extract sint6 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);
    vec3 sh3_0 = vec3(ivec3(
      int(packed.x << 26u) >> 26,
      int(packed.x << 20u) >> 26,
      int(packed.x << 14u) >> 26
    )) / 31.0;
    vec3 sh3_1 = vec3(ivec3(
      int(packed.x << 8u) >> 26,
      int(packed.x << 2u) >> 26,
      int((packed.x >> 4u) | (packed.y << 28u)) >> 26
    )) / 31.0;
    vec3 sh3_2 = vec3(ivec3(
      int(packed.y << 22u) >> 26,
      int(packed.y << 16u) >> 26,
      int(packed.y << 10u) >> 26
    )) / 31.0;
    vec3 sh3_3 = vec3(ivec3(
      int(packed.y << 4u) >> 26,
      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,
      int(packed.z << 24u) >> 26
    )) / 31.0;
    vec3 sh3_4 = vec3(ivec3(
      int(packed.z << 18u) >> 26,
      int(packed.z << 12u) >> 26,
      int(packed.z << 6u) >> 26
    )) / 31.0;
    vec3 sh3_5 = vec3(ivec3(
      int(packed.z) >> 26,
      int(packed.w << 26u) >> 26,
      int(packed.w << 20u) >> 26
    )) / 31.0;
    vec3 sh3_6 = vec3(ivec3(
      int(packed.w << 14u) >> 26,
      int(packed.w << 8u) >> 26,
      int(packed.w << 2u) >> 26
    )) / 31.0;

    float xx = viewDir.x * viewDir.x;
    float yy = viewDir.y * viewDir.y;
    float zz = viewDir.z * viewDir.z;
    float xy = viewDir.x * viewDir.y;
    float yz = viewDir.y * viewDir.z;
    float zx = viewDir.z * viewDir.x;

    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))
      + sh3_1 * (2.8906114 * xy * viewDir.z) +
      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))
      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))
      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))
      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))
      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));
  }
\`);
  function evaluateSH1(gsplat, sh1, viewDir) {
    return dyno({
      inTypes: { gsplat: Gsplat, sh1: "usampler2DArray", viewDir: "vec3" },
      outTypes: { rgb: "vec3" },
      inputs: { gsplat, sh1, viewDir },
      globals: () => [defineGsplat, defineEvaluateSH1],
      statements: ({ inputs, outputs }) => {
        const statements = unindentLines(\`
        if (isGsplatActive(\${inputs.gsplat}.flags)) {
          \${outputs.rgb} = evaluateSH1(\${inputs.gsplat}, \${inputs.sh1}, \${inputs.viewDir});
        } else {
          \${outputs.rgb} = vec3(0.0);
        }
      \`);
        return statements;
      }
    }).outputs.rgb;
  }
  function evaluateSH2(gsplat, sh2, viewDir) {
    return dyno({
      inTypes: { gsplat: Gsplat, sh2: "usampler2DArray", viewDir: "vec3" },
      outTypes: { rgb: "vec3" },
      inputs: { gsplat, sh2, viewDir },
      globals: () => [defineGsplat, defineEvaluateSH2],
      statements: ({ inputs, outputs }) => unindentLines(\`
        if (isGsplatActive(\${inputs.gsplat}.flags)) {
          \${outputs.rgb} = evaluateSH2(\${inputs.gsplat}, \${inputs.sh2}, \${inputs.viewDir});
        } else {
          \${outputs.rgb} = vec3(0.0);
        }
      \`)
    }).outputs.rgb;
  }
  function evaluateSH3(gsplat, sh3, viewDir) {
    return dyno({
      inTypes: { gsplat: Gsplat, sh3: "usampler2DArray", viewDir: "vec3" },
      outTypes: { rgb: "vec3" },
      inputs: { gsplat, sh3, viewDir },
      globals: () => [defineGsplat, defineEvaluateSH3],
      statements: ({ inputs, outputs }) => unindentLines(\`
        if (isGsplatActive(\${inputs.gsplat}.flags)) {
          \${outputs.rgb} = evaluateSH3(\${inputs.gsplat}, \${inputs.sh3}, \${inputs.viewDir});
        } else {
          \${outputs.rgb} = vec3(0.0);
        }
      \`)
    }).outputs.rgb;
  }
  function WorkerWrapper(options) {
    return new Worker(
      self.location.href,
      {
        name: options == null ? void 0 : options.name
      }
    );
  }
  class SplatWorker {
    constructor() {
      this.messages = {};
      this.messageIdNext = 0;
      this.worker = new WorkerWrapper();
      this.worker.onmessage = (event) => this.onMessage(event);
    }
    makeMessageId() {
      return ++this.messageIdNext;
    }
    makeMessagePromiseId() {
      const id = this.makeMessageId();
      const promise = new Promise((resolve, reject) => {
        this.messages[id] = { resolve, reject };
      });
      return { id, promise };
    }
    onMessage(event) {
      const { id, result, error } = event.data;
      const handler = this.messages[id];
      if (handler) {
        delete this.messages[id];
        if (error) {
          handler.reject(error);
        } else {
          handler.resolve(result);
        }
      }
    }
    // Invoke an RPC on the worker with the given name and arguments.
    // The normal usage of a worker is to run one activity at a time,
    // but this function allows for concurrent calls, tagging each request
    // with a unique message Id and awaiting a response to that same Id.
    // The method will automatically transfer any ArrayBuffers in the
    // arguments to the worker. If you'd like to transfer a copy of a
    // buffer then you must clone it before passing to this function.
    async call(name, args) {
      const { id, promise } = this.makeMessagePromiseId();
      this.worker.postMessage(
        { name, args, id },
        { transfer: getArrayBuffers(args) }
      );
      return promise;
    }
  }
  let maxWorkers = 4;
  let numWorkers = 0;
  const freeWorkers = [];
  const workerQueue = [];
  async function allocWorker() {
    const worker = freeWorkers.shift();
    if (worker) {
      return worker;
    }
    if (numWorkers < maxWorkers) {
      const worker2 = new SplatWorker();
      numWorkers += 1;
      return worker2;
    }
    return new Promise((resolve) => {
      workerQueue.push(resolve);
    });
  }
  function freeWorker(worker) {
    if (numWorkers > maxWorkers) {
      numWorkers -= 1;
      return;
    }
    const waiter = workerQueue.shift();
    if (waiter) {
      waiter(worker);
      return;
    }
    freeWorkers.push(worker);
  }
  async function withWorker(callback) {
    const worker = await allocWorker();
    try {
      return await callback(worker);
    } finally {
      freeWorker(worker);
    }
  }
  var SplatFileType = /* @__PURE__ */ ((SplatFileType2) => {
    SplatFileType2["PLY"] = "ply";
    SplatFileType2["SPZ"] = "spz";
    SplatFileType2["SPLAT"] = "splat";
    SplatFileType2["KSPLAT"] = "ksplat";
    return SplatFileType2;
  })(SplatFileType || {});
  function getSplatFileType(fileBytes) {
    const view = new DataView(fileBytes.buffer);
    if ((view.getUint32(0, true) & 16777215) === 7957616) {
      return "ply";
    }
    if ((view.getUint32(0, true) & 16777215) === 559903) {
      const header = decompressPartialGzip(fileBytes, 4);
      const gView = new DataView(header.buffer);
      if (gView.getUint32(0, true) === 1347635022) {
        return "spz";
      }
      return void 0;
    }
    return void 0;
  }
  function getFileExtension(pathOrUrl) {
    const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];
    const lastSlash = Math.max(
      noTrailing.lastIndexOf("/"),
      noTrailing.lastIndexOf("\\\\")
    );
    const filename = noTrailing.slice(lastSlash + 1);
    const lastDot = filename.lastIndexOf(".");
    if (lastDot <= 0 || lastDot === filename.length - 1) {
      return "";
    }
    return filename.slice(lastDot + 1).toLowerCase();
  }
  function getSplatFileTypeFromPath(pathOrUrl) {
    const extension = getFileExtension(pathOrUrl);
    if (extension === "ply") {
      return "ply";
    }
    if (extension === "spz") {
      return "spz";
    }
    if (extension === "splat") {
      return "splat";
    }
    if (extension === "ksplat") {
      return "ksplat";
    }
    return void 0;
  }
  async function unpackSplats({
    input,
    fileType,
    pathOrUrl
  }) {
    const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;
    let splatFileType = fileType;
    if (!fileType) {
      splatFileType = getSplatFileType(fileBytes);
      if (!splatFileType && pathOrUrl) {
        splatFileType = getSplatFileTypeFromPath(pathOrUrl);
      }
    }
    switch (splatFileType) {
      case "ply": {
        const ply = new PlyReader({ fileBytes });
        await ply.parseHeader();
        const numSplats = ply.numSplats;
        const maxSplats = getTextureSize(numSplats).maxSplats;
        const args = { fileBytes, packedArray: new Uint32Array(maxSplats * 4) };
        return await withWorker(async (worker) => {
          const { packedArray, numSplats: numSplats2, extra } = await worker.call(
            "unpackPly",
            args
          );
          return { packedArray, numSplats: numSplats2, extra };
        });
      }
      case "spz": {
        return await withWorker(async (worker) => {
          const { packedArray, numSplats, extra } = await worker.call(
            "decodeSpz",
            {
              fileBytes
            }
          );
          return { packedArray, numSplats, extra };
        });
      }
      case "splat": {
        return await withWorker(async (worker) => {
          const { packedArray, numSplats } = await worker.call(
            "decodeAntiSplat",
            {
              fileBytes
            }
          );
          return { packedArray, numSplats };
        });
      }
      case "ksplat":
        return await withWorker(async (worker) => {
          const { packedArray, numSplats, extra } = await worker.call(
            "decodeKsplat",
            { fileBytes }
          );
          return { packedArray, numSplats, extra };
        });
      default: {
        throw new Error(\`Unknown splat file type: \${splatFileType}\`);
      }
    }
  }
  class SplatData {
    constructor({ maxSplats = 1 } = {}) {
      this.numSplats = 0;
      this.maxSplats = getTextureSize(maxSplats).maxSplats;
      this.centers = new Float32Array(this.maxSplats * 3);
      this.scales = new Float32Array(this.maxSplats * 3);
      this.quaternions = new Float32Array(this.maxSplats * 4);
      this.opacities = new Float32Array(this.maxSplats);
      this.colors = new Float32Array(this.maxSplats * 3);
    }
    pushSplat() {
      const index = this.numSplats;
      this.ensureIndex(index);
      this.numSplats += 1;
      return index;
    }
    unpushSplat(index) {
      if (index === this.numSplats - 1) {
        this.numSplats -= 1;
      } else {
        throw new Error("Cannot unpush splat from non-last position");
      }
    }
    ensureCapacity(numSplats) {
      if (numSplats > this.maxSplats) {
        const targetSplats = Math.max(numSplats, this.maxSplats * 2);
        const newCenters = new Float32Array(targetSplats * 3);
        const newScales = new Float32Array(targetSplats * 3);
        const newQuaternions = new Float32Array(targetSplats * 4);
        const newOpacities = new Float32Array(targetSplats);
        const newColors = new Float32Array(targetSplats * 3);
        newCenters.set(this.centers);
        newScales.set(this.scales);
        newQuaternions.set(this.quaternions);
        newOpacities.set(this.opacities);
        newColors.set(this.colors);
        this.centers = newCenters;
        this.scales = newScales;
        this.quaternions = newQuaternions;
        this.opacities = newOpacities;
        this.colors = newColors;
        if (this.sh1) {
          const newSh1 = new Float32Array(targetSplats * 9);
          newSh1.set(this.sh1);
          this.sh1 = newSh1;
        }
        if (this.sh2) {
          const newSh2 = new Float32Array(targetSplats * 15);
          newSh2.set(this.sh2);
          this.sh2 = newSh2;
        }
        if (this.sh3) {
          const newSh3 = new Float32Array(targetSplats * 21);
          newSh3.set(this.sh3);
          this.sh3 = newSh3;
        }
        this.maxSplats = targetSplats;
      }
    }
    ensureIndex(index) {
      this.ensureCapacity(index + 1);
    }
    setCenter(index, x2, y, z) {
      this.centers[index * 3] = x2;
      this.centers[index * 3 + 1] = y;
      this.centers[index * 3 + 2] = z;
    }
    setScale(index, scaleX, scaleY, scaleZ) {
      this.scales[index * 3] = scaleX;
      this.scales[index * 3 + 1] = scaleY;
      this.scales[index * 3 + 2] = scaleZ;
    }
    setQuaternion(index, x2, y, z, w) {
      this.quaternions[index * 4] = x2;
      this.quaternions[index * 4 + 1] = y;
      this.quaternions[index * 4 + 2] = z;
      this.quaternions[index * 4 + 3] = w;
    }
    setOpacity(index, opacity) {
      this.opacities[index] = opacity;
    }
    setColor(index, r, g, b) {
      this.colors[index * 3] = r;
      this.colors[index * 3 + 1] = g;
      this.colors[index * 3 + 2] = b;
    }
    setSh1(index, sh1) {
      if (!this.sh1) {
        this.sh1 = new Float32Array(this.maxSplats * 9);
      }
      for (let j = 0; j < 9; ++j) {
        this.sh1[index * 9 + j] = sh1[j];
      }
    }
    setSh2(index, sh2) {
      if (!this.sh2) {
        this.sh2 = new Float32Array(this.maxSplats * 15);
      }
      for (let j = 0; j < 15; ++j) {
        this.sh2[index * 15 + j] = sh2[j];
      }
    }
    setSh3(index, sh3) {
      if (!this.sh3) {
        this.sh3 = new Float32Array(this.maxSplats * 21);
      }
      for (let j = 0; j < 21; ++j) {
        this.sh3[index * 21 + j] = sh3[j];
      }
    }
  }
  class SpzReader {
    constructor({ fileBytes }) {
      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;
      this.reader = new GunzipReader({ fileBytes: this.fileBytes });
      const header = new DataView(this.reader.read(16).buffer);
      if (header.getUint32(0, true) !== 1347635022) {
        throw new Error("Invalid SPZ file");
      }
      this.version = header.getUint32(4, true);
      if (this.version < 1 || this.version > 2) {
        throw new Error(\`Unsupported SPZ version: \${this.version}\`);
      }
      this.numSplats = header.getUint32(8, true);
      this.shDegree = header.getUint8(12);
      this.fractionalBits = header.getUint8(13);
      this.flags = header.getUint8(14);
      this.flagAntiAlias = (this.flags & 1) !== 0;
      this.reserved = header.getUint8(15);
      this.parsed = false;
    }
    parseSplats(centerCallback, alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback) {
      if (this.parsed) {
        throw new Error("SPZ file already parsed");
      }
      this.parsed = true;
      if (this.version === 1) {
        const centerBytes = this.reader.read(this.numSplats * 3 * 2);
        const centerUint16 = new Uint16Array(centerBytes.buffer);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i3 = i2 * 3;
          const x2 = fromHalf(centerUint16[i3]);
          const y = fromHalf(centerUint16[i3 + 1]);
          const z = fromHalf(centerUint16[i3 + 2]);
          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);
        }
      } else if (this.version === 2) {
        const fixed = 1 << this.fractionalBits;
        const centerBytes = this.reader.read(this.numSplats * 3 * 3);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i9 = i2 * 9;
          const x2 = ((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << 8) >> 8) / fixed;
          const y = ((centerBytes[i9 + 5] << 24 | centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;
          const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | centerBytes[i9 + 6] << 8) >> 8) / fixed;
          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);
        }
      } else {
        throw new Error("Unreachable");
      }
      {
        const bytes = this.reader.read(this.numSplats);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          alphaCallback == null ? void 0 : alphaCallback(i2, bytes[i2] / 255);
        }
      }
      {
        const rgbBytes = this.reader.read(this.numSplats * 3);
        const scale = SH_C0 / 0.15;
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i3 = i2 * 3;
          const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;
          const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;
          const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;
          rgbCallback == null ? void 0 : rgbCallback(i2, r, g, b);
        }
      }
      {
        const scalesBytes = this.reader.read(this.numSplats * 3);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i3 = i2 * 3;
          const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);
          const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);
          const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);
          scalesCallback == null ? void 0 : scalesCallback(i2, scaleX, scaleY, scaleZ);
        }
      }
      {
        const quatBytes = this.reader.read(this.numSplats * 3);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i3 = i2 * 3;
          const quatX = quatBytes[i3] / 127.5 - 1;
          const quatY = quatBytes[i3 + 1] / 127.5 - 1;
          const quatZ = quatBytes[i3 + 2] / 127.5 - 1;
          const quatW = Math.sqrt(
            Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)
          );
          quatCallback == null ? void 0 : quatCallback(i2, quatX, quatY, quatZ, quatW);
        }
      }
      if (shCallback && this.shDegree >= 1) {
        const sh1 = new Float32Array(3 * 3);
        const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;
        const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;
        const shBytes = this.reader.read(
          this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3
        );
        let offset = 0;
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          for (let j = 0; j < 9; ++j) {
            sh1[j] = (shBytes[offset + j] - 128) / 128;
          }
          offset += 9;
          if (sh2) {
            for (let j = 0; j < 15; ++j) {
              sh2[j] = (shBytes[offset + j] - 128) / 128;
            }
            offset += 15;
          }
          if (sh3) {
            for (let j = 0; j < 21; ++j) {
              sh3[j] = (shBytes[offset + j] - 128) / 128;
            }
            offset += 21;
          }
          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);
        }
      }
    }
  }
  const SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };
  const SH_C0 = 0.28209479177387814;
  const SPZ_MAGIC = 1347635022;
  const SPZ_VERSION = 2;
  const FLAG_ANTIALIASED = 1;
  class SpzWriter {
    constructor({
      numSplats,
      shDegree,
      fractionalBits = 12,
      flagAntiAlias = true
    }) {
      this.clippedCount = 0;
      const splatSize = 9 + 1 + 3 + 3 + 3 + (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);
      const bufferSize = 16 + numSplats * splatSize;
      this.buffer = new ArrayBuffer(bufferSize);
      this.view = new DataView(this.buffer);
      this.view.setUint32(0, SPZ_MAGIC, true);
      this.view.setUint32(4, SPZ_VERSION, true);
      this.view.setUint32(8, numSplats, true);
      this.view.setUint8(12, shDegree);
      this.view.setUint8(13, fractionalBits);
      this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);
      this.view.setUint8(15, 0);
      this.numSplats = numSplats;
      this.shDegree = shDegree;
      this.fractionalBits = fractionalBits;
      this.fraction = 1 << fractionalBits;
      this.flagAntiAlias = flagAntiAlias;
    }
    setCenter(index, x2, y, z) {
      const xRounded = Math.round(x2 * this.fraction);
      const xInt = Math.max(-8388607, Math.min(8388607, xRounded));
      const yRounded = Math.round(y * this.fraction);
      const yInt = Math.max(-8388607, Math.min(8388607, yRounded));
      const zRounded = Math.round(z * this.fraction);
      const zInt = Math.max(-8388607, Math.min(8388607, zRounded));
      const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;
      if (clipped) {
        this.clippedCount += 1;
      }
      const i9 = index * 9;
      const base = 16 + i9;
      this.view.setUint8(base, xInt & 255);
      this.view.setUint8(base + 1, xInt >> 8 & 255);
      this.view.setUint8(base + 2, xInt >> 16 & 255);
      this.view.setUint8(base + 3, yInt & 255);
      this.view.setUint8(base + 4, yInt >> 8 & 255);
      this.view.setUint8(base + 5, yInt >> 16 & 255);
      this.view.setUint8(base + 6, zInt & 255);
      this.view.setUint8(base + 7, zInt >> 8 & 255);
      this.view.setUint8(base + 8, zInt >> 16 & 255);
    }
    setAlpha(index, alpha) {
      const base = 16 + this.numSplats * 9 + index;
      this.view.setUint8(
        base,
        Math.max(0, Math.min(255, Math.round(alpha * 255)))
      );
    }
    static scaleRgb(r) {
      const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;
      return Math.max(0, Math.min(255, Math.round(v)));
    }
    setRgb(index, r, g, b) {
      const base = 16 + this.numSplats * 10 + index * 3;
      this.view.setUint8(base, SpzWriter.scaleRgb(r));
      this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));
      this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));
    }
    setScale(index, scaleX, scaleY, scaleZ) {
      const base = 16 + this.numSplats * 13 + index * 3;
      this.view.setUint8(
        base,
        Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16)))
      );
      this.view.setUint8(
        base + 1,
        Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))
      );
      this.view.setUint8(
        base + 2,
        Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))
      );
    }
    setQuat(index, quatX, quatY, quatZ, quatW) {
      const base = 16 + this.numSplats * 16 + index * 3;
      const quatNeg = quatW < 0;
      this.view.setUint8(
        base,
        Math.max(
          0,
          Math.min(255, Math.round(((quatNeg ? -quatX : quatX) + 1) * 127.5))
        )
      );
      this.view.setUint8(
        base + 1,
        Math.max(
          0,
          Math.min(255, Math.round(((quatNeg ? -quatY : quatY) + 1) * 127.5))
        )
      );
      this.view.setUint8(
        base + 2,
        Math.max(
          0,
          Math.min(255, Math.round(((quatNeg ? -quatZ : quatZ) + 1) * 127.5))
        )
      );
    }
    static quantizeSh(sh, bits2) {
      const value = Math.round(sh * 128) + 128;
      const bucketSize = 1 << 8 - bits2;
      const quantized = Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;
      return Math.max(0, Math.min(255, quantized));
    }
    setSh(index, sh1, sh2, sh3) {
      const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;
      const base1 = 16 + this.numSplats * 19 + index * shVecs * 3;
      for (let j = 0; j < 9; ++j) {
        this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));
      }
      if (sh2) {
        const base2 = base1 + 9;
        for (let j = 0; j < 15; ++j) {
          this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));
        }
        if (sh3) {
          const base3 = base2 + 15;
          for (let j = 0; j < 21; ++j) {
            this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));
          }
        }
      }
    }
    async finalize() {
      const input = new Uint8Array(this.buffer);
      const stream = new ReadableStream({
        async start(controller) {
          controller.enqueue(input);
          controller.close();
        }
      });
      const compressed = stream.pipeThrough(new CompressionStream("gzip"));
      const response = new Response(compressed);
      const buffer = await response.arrayBuffer();
      console.log(
        "Compressed",
        input.length,
        "bytes to",
        buffer.byteLength,
        "bytes"
      );
      return new Uint8Array(buffer);
    }
  }
  async function transcodeSpz(input) {
    var _a2, _b2, _c;
    const splats = new SplatData();
    const {
      inputs,
      clipXyz,
      maxSh,
      fractionalBits = 12,
      opacityThreshold
    } = input;
    for (const input2 of inputs) {
      let transformPos2 = function(pos) {
        pos.multiplyScalar(scale);
        pos.applyQuaternion(quaternion);
        pos.add(translate);
        return pos;
      }, transformScales = function(scales) {
        scales.multiplyScalar(scale);
        return scales;
      }, transformQuaternion = function(quat) {
        quat.premultiply(quaternion);
        return quat;
      }, withinClip = function(p) {
        return !clip || clip.containsPoint(p);
      }, withinOpacity = function(opacity) {
        return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;
      };
      const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;
      const quaternion = new Quaternion().fromArray(
        ((_b2 = input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]
      );
      const translate = new Vector3().fromArray(
        ((_c = input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]
      );
      const clip = clipXyz ? new Box3(
        new Vector3().fromArray(clipXyz.min),
        new Vector3().fromArray(clipXyz.max)
      ) : void 0;
      let fileType = input2.fileType;
      if (!fileType) {
        fileType = getSplatFileType(input2.fileBytes);
        if (!fileType && input2.pathOrUrl) {
          fileType = getSplatFileTypeFromPath(input2.pathOrUrl);
        }
      }
      switch (fileType) {
        case SplatFileType.PLY: {
          const ply = new PlyReader({ fileBytes: input2.fileBytes });
          await ply.parseHeader();
          let lastIndex = null;
          ply.parseSplats(
            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
              const center = transformPos2(new Vector3(x2, y, z));
              if (withinClip(center) && withinOpacity(opacity)) {
                lastIndex = splats.pushSplat();
                splats.setCenter(lastIndex, center.x, center.y, center.z);
                const scales = transformScales(
                  new Vector3(scaleX, scaleY, scaleZ)
                );
                splats.setScale(lastIndex, scales.x, scales.y, scales.z);
                const quaternion2 = transformQuaternion(
                  new Quaternion(quatX, quatY, quatZ, quatW)
                );
                splats.setQuaternion(
                  lastIndex,
                  quaternion2.x,
                  quaternion2.y,
                  quaternion2.z,
                  quaternion2.w
                );
                splats.setOpacity(lastIndex, opacity);
                splats.setColor(lastIndex, r, g, b);
              } else {
                lastIndex = null;
              }
            },
            (index, sh1, sh2, sh3) => {
              if (sh1 && lastIndex !== null) {
                splats.setSh1(lastIndex, sh1);
              }
              if (sh2 && lastIndex !== null) {
                splats.setSh2(lastIndex, sh2);
              }
              if (sh3 && lastIndex !== null) {
                splats.setSh3(lastIndex, sh3);
              }
            }
          );
          break;
        }
        case SplatFileType.SPZ: {
          const spz2 = new SpzReader({ fileBytes: input2.fileBytes });
          const mapping = new Int32Array(spz2.numSplats);
          mapping.fill(-1);
          const centers = new Float32Array(spz2.numSplats * 3);
          const center = new Vector3();
          spz2.parseSplats(
            (index, x2, y, z) => {
              const center2 = transformPos2(new Vector3(x2, y, z));
              centers[index * 3] = center2.x;
              centers[index * 3 + 1] = center2.y;
              centers[index * 3 + 2] = center2.z;
            },
            (index, alpha) => {
              center.fromArray(centers, index * 3);
              if (withinClip(center) && withinOpacity(alpha)) {
                mapping[index] = splats.pushSplat();
                splats.setCenter(mapping[index], center.x, center.y, center.z);
                splats.setOpacity(mapping[index], alpha);
              }
            },
            (index, r, g, b) => {
              if (mapping[index] >= 0) {
                splats.setColor(mapping[index], r, g, b);
              }
            },
            (index, scaleX, scaleY, scaleZ) => {
              if (mapping[index] >= 0) {
                const scales = transformScales(
                  new Vector3(scaleX, scaleY, scaleZ)
                );
                splats.setScale(mapping[index], scales.x, scales.y, scales.z);
              }
            },
            (index, quatX, quatY, quatZ, quatW) => {
              if (mapping[index] >= 0) {
                const quaternion2 = transformQuaternion(
                  new Quaternion(quatX, quatY, quatZ, quatW)
                );
                splats.setQuaternion(
                  mapping[index],
                  quaternion2.x,
                  quaternion2.y,
                  quaternion2.z,
                  quaternion2.w
                );
              }
            },
            (index, sh1, sh2, sh3) => {
              if (mapping[index] >= 0) {
                splats.setSh1(mapping[index], sh1);
                if (sh2) {
                  splats.setSh2(mapping[index], sh2);
                }
                if (sh3) {
                  splats.setSh3(mapping[index], sh3);
                }
              }
            }
          );
          break;
        }
        case SplatFileType.SPLAT:
          decodeAntiSplat(
            input2.fileBytes,
            (numSplats) => {
            },
            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
              const center = transformPos2(new Vector3(x2, y, z));
              if (withinClip(center) && withinOpacity(opacity)) {
                const index2 = splats.pushSplat();
                splats.setCenter(index2, center.x, center.y, center.z);
                const scales = transformScales(
                  new Vector3(scaleX, scaleY, scaleZ)
                );
                splats.setScale(index2, scales.x, scales.y, scales.z);
                const quaternion2 = transformQuaternion(
                  new Quaternion(quatX, quatY, quatZ, quatW)
                );
                splats.setQuaternion(
                  index2,
                  quaternion2.x,
                  quaternion2.y,
                  quaternion2.z,
                  quaternion2.w
                );
                splats.setOpacity(index2, opacity);
                splats.setColor(index2, r, g, b);
              }
            }
          );
          break;
        case SplatFileType.KSPLAT: {
          let lastIndex = null;
          decodeKsplat(
            input2.fileBytes,
            (numSplats) => {
            },
            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
              const center = transformPos2(new Vector3(x2, y, z));
              if (withinClip(center) && withinOpacity(opacity)) {
                lastIndex = splats.pushSplat();
                splats.setCenter(lastIndex, center.x, center.y, center.z);
                const scales = transformScales(
                  new Vector3(scaleX, scaleY, scaleZ)
                );
                splats.setScale(lastIndex, scales.x, scales.y, scales.z);
                const quaternion2 = transformQuaternion(
                  new Quaternion(quatX, quatY, quatZ, quatW)
                );
                splats.setQuaternion(
                  lastIndex,
                  quaternion2.x,
                  quaternion2.y,
                  quaternion2.z,
                  quaternion2.w
                );
                splats.setOpacity(lastIndex, opacity);
                splats.setColor(lastIndex, r, g, b);
              } else {
                lastIndex = null;
              }
            },
            (index, sh1, sh2, sh3) => {
              if (lastIndex !== null) {
                splats.setSh1(lastIndex, sh1);
                if (sh2) {
                  splats.setSh2(lastIndex, sh2);
                }
                if (sh3) {
                  splats.setSh3(lastIndex, sh3);
                }
              }
            }
          );
          break;
        }
        default:
          throw new Error(\`transcodeSpz not implemented for \${fileType}\`);
      }
    }
    const shDegree = Math.min(
      maxSh ?? 3,
      splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0
    );
    const spz = new SpzWriter({
      numSplats: splats.numSplats,
      shDegree,
      fractionalBits,
      flagAntiAlias: true
    });
    for (let i2 = 0; i2 < splats.numSplats; ++i2) {
      const i3 = i2 * 3;
      const i4 = i2 * 4;
      spz.setCenter(
        i2,
        splats.centers[i3],
        splats.centers[i3 + 1],
        splats.centers[i3 + 2]
      );
      spz.setScale(
        i2,
        splats.scales[i3],
        splats.scales[i3 + 1],
        splats.scales[i3 + 2]
      );
      spz.setQuat(
        i2,
        splats.quaternions[i4],
        splats.quaternions[i4 + 1],
        splats.quaternions[i4 + 2],
        splats.quaternions[i4 + 3]
      );
      spz.setAlpha(i2, splats.opacities[i2]);
      spz.setRgb(
        i2,
        splats.colors[i3],
        splats.colors[i3 + 1],
        splats.colors[i3 + 2]
      );
      if (splats.sh1 && shDegree >= 1) {
        spz.setSh(
          i2,
          splats.sh1.slice(i2 * 9, (i2 + 1) * 9),
          shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i2 * 15, (i2 + 1) * 15) : void 0,
          shDegree >= 3 && splats.sh3 ? splats.sh3.slice(i2 * 21, (i2 + 1) * 21) : void 0
        );
      }
    }
    const spzBytes = await spz.finalize();
    return { fileBytes: spzBytes, clippedCount: spz.clippedCount };
  }
  async function onMessage(event) {
    const { name, args, id } = event.data;
    let result = void 0;
    let error = void 0;
    try {
      switch (name) {
        case "unpackPly": {
          const { packedArray, fileBytes } = args;
          const decoded = await unpackPly({ packedArray, fileBytes });
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray,
            extra: decoded.extra
          };
          break;
        }
        case "decodeSpz": {
          const { fileBytes } = args;
          const decoded = unpackSpz(fileBytes);
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray,
            extra: decoded.extra
          };
          break;
        }
        case "decodeAntiSplat": {
          const { fileBytes } = args;
          const decoded = unpackAntiSplat(fileBytes);
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray
          };
          break;
        }
        case "decodeKsplat": {
          const { fileBytes } = args;
          const decoded = unpackKsplat(fileBytes);
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray,
            extra: decoded.extra
          };
          break;
        }
        case "sortSplats": {
          const { maxSplats, totalSplats, readback, ordering } = args;
          result = {
            id,
            readback,
            ...sortSplats({ totalSplats, readback, ordering })
          };
          break;
        }
        case "sortDoubleSplats": {
          const { numSplats, readback, ordering } = args;
          result = {
            id,
            readback,
            ordering
          };
          if (WASM_SPLAT_SORT) {
            result = {
              id,
              readback,
              ordering,
              activeSplats: sort_splats(numSplats, readback, ordering)
            };
          }
          break;
        }
        case "transcodeSpz": {
          const input = args;
          const spzBytes = await transcodeSpz(input);
          result = {
            id,
            fileBytes: spzBytes,
            input
          };
          break;
        }
        default: {
          throw new Error(\`Unknown name: \${name}\`);
        }
      }
    } catch (e) {
      error = e;
    }
    self.postMessage(
      { id, result, error },
      { transfer: getArrayBuffers(result) }
    );
  }
  async function unpackPly({
    packedArray,
    fileBytes
  }) {
    const ply = new PlyReader({ fileBytes });
    await ply.parseHeader();
    const numSplats = ply.numSplats;
    const extra = {};
    const ZERO_CUTOFF = Math.exp(-20);
    ply.parseSplats(
      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
        setPackedSplat(
          packedArray,
          index,
          x2,
          y,
          z,
          scaleX < ZERO_CUTOFF ? 0 : Math.max(SCALE_MIN, scaleX),
          scaleY < ZERO_CUTOFF ? 0 : Math.max(SCALE_MIN, scaleY),
          scaleZ < ZERO_CUTOFF ? 0 : Math.max(SCALE_MIN, scaleZ),
          quatX,
          quatY,
          quatZ,
          quatW,
          opacity,
          r,
          g,
          b
        );
      },
      (index, sh1, sh2, sh3) => {
        if (sh1) {
          if (!extra.sh1) {
            extra.sh1 = new Uint32Array(numSplats * 2);
          }
          encodeSh1Rgb(extra.sh1, index, sh1);
        }
        if (sh2) {
          if (!extra.sh2) {
            extra.sh2 = new Uint32Array(numSplats * 4);
          }
          encodeSh2Rgb(extra.sh2, index, sh2);
        }
        if (sh3) {
          if (!extra.sh3) {
            extra.sh3 = new Uint32Array(numSplats * 4);
          }
          encodeSh3Rgb(extra.sh3, index, sh3);
        }
      }
    );
    return { packedArray, numSplats, extra };
  }
  function unpackSpz(fileBytes) {
    const spz = new SpzReader({ fileBytes });
    const numSplats = spz.numSplats;
    const maxSplats = computeMaxSplats(numSplats);
    const packedArray = new Uint32Array(maxSplats * 4);
    const extra = {};
    spz.parseSplats(
      (index, x2, y, z) => {
        setPackedSplatCenter(packedArray, index, x2, y, z);
      },
      (index, alpha) => {
        setPackedSplatOpacity(packedArray, index, alpha);
      },
      (index, r, g, b) => {
        setPackedSplatRgb(packedArray, index, r, g, b);
      },
      (index, scaleX, scaleY, scaleZ) => {
        setPackedSplatScales(packedArray, index, scaleX, scaleY, scaleZ);
      },
      (index, quatX, quatY, quatZ, quatW) => {
        setPackedSplatQuat(packedArray, index, quatX, quatY, quatZ, quatW);
      },
      (index, sh1, sh2, sh3) => {
        if (sh1) {
          if (!extra.sh1) {
            extra.sh1 = new Uint32Array(numSplats * 2);
          }
          encodeSh1Rgb(extra.sh1, index, sh1);
        }
        if (sh2) {
          if (!extra.sh2) {
            extra.sh2 = new Uint32Array(numSplats * 4);
          }
          encodeSh2Rgb(extra.sh2, index, sh2);
        }
        if (sh3) {
          if (!extra.sh3) {
            extra.sh3 = new Uint32Array(numSplats * 4);
          }
          encodeSh3Rgb(extra.sh3, index, sh3);
        }
      }
    );
    return { packedArray, numSplats, extra };
  }
  const DEPTH_INFINITY = 31744;
  const DEPTH_SIZE = DEPTH_INFINITY + 1;
  let depthArray = null;
  function sortSplats({
    totalSplats,
    readback,
    ordering
  }) {
    if (!depthArray) {
      depthArray = new Uint32Array(DEPTH_SIZE);
    }
    depthArray.fill(0);
    const readbackUint32 = readback.map((layer) => new Uint32Array(layer.buffer));
    const layerSize = readbackUint32[0].length;
    const numLayers = Math.ceil(totalSplats / layerSize);
    let layerBase = 0;
    for (let layer = 0; layer < numLayers; ++layer) {
      const readbackLayer = readbackUint32[layer];
      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);
      for (let i2 = 0; i2 < layerSplats; ++i2) {
        const pri = readbackLayer[i2] & 32767;
        if (pri < DEPTH_INFINITY) {
          depthArray[pri] += 1;
        }
      }
      layerBase += layerSplats;
    }
    let activeSplats = 0;
    for (let j = 0; j < DEPTH_SIZE; ++j) {
      const nextIndex = activeSplats + depthArray[j];
      depthArray[j] = activeSplats;
      activeSplats = nextIndex;
    }
    layerBase = 0;
    for (let layer = 0; layer < numLayers; ++layer) {
      const readbackLayer = readbackUint32[layer];
      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);
      for (let i2 = 0; i2 < layerSplats; ++i2) {
        const pri = readbackLayer[i2] & 32767;
        if (pri < DEPTH_INFINITY) {
          ordering[depthArray[pri]] = layerBase + i2;
          depthArray[pri] += 1;
        }
      }
      layerBase += layerSplats;
    }
    if (depthArray[DEPTH_SIZE - 1] !== activeSplats) {
      throw new Error(
        \`Expected \${activeSplats} active splats but got \${depthArray[DEPTH_SIZE - 1]}\`
      );
    }
    return { activeSplats, ordering };
  }
  function sortDoubleSplats({
    numSplats,
    readback,
    ordering
  }) {
    if (!depthArray) {
      depthArray = new Uint32Array(DEPTH_SIZE);
    }
    depthArray.fill(0);
    for (let i2 = 0; i2 < numSplats; ++i2) {
      const pri = readback[i2];
      if (pri < DEPTH_INFINITY) {
        depthArray[pri] += 1;
      }
    }
    let activeSplats = 0;
    for (let j = DEPTH_INFINITY - 1; j >= 0; --j) {
      const nextIndex = activeSplats + depthArray[j];
      depthArray[j] = activeSplats;
      activeSplats = nextIndex;
    }
    for (let i2 = 0; i2 < numSplats; ++i2) {
      const pri = readback[i2];
      if (pri < DEPTH_INFINITY) {
        ordering[depthArray[pri]] = i2;
        depthArray[pri] += 1;
      }
    }
    if (depthArray[0] !== activeSplats) {
      throw new Error(
        \`Expected \${activeSplats} active splats but got \${depthArray[0]}\`
      );
    }
    return { activeSplats, ordering };
  }
  const messageBuffer = [];
  function bufferMessage(event) {
    messageBuffer.push(event);
  }
  async function initialize() {
    self.addEventListener("message", bufferMessage);
    await __wbg_init();
    self.removeEventListener("message", bufferMessage);
    self.addEventListener("message", onMessage);
    for (const event of messageBuffer) {
      onMessage(event);
    }
    messageBuffer.length = 0;
  }
  initialize().catch(console.error);
})();
//# sourceMappingURL=worker-Do1mGyaZ.js.map
`,ne=typeof self<"u"&&self.Blob&&new Blob([ss],{type:"text/javascript;charset=utf-8"});function ir(s){let A;try{if(A=ne&&(self.URL||self.webkitURL).createObjectURL(ne),!A)throw"";const n=new Worker(A,{name:s?.name});return n.addEventListener("error",()=>{(self.URL||self.webkitURL).revokeObjectURL(A)}),n}catch{return new Worker("data:text/javascript;charset=utf-8,"+encodeURIComponent(ss),{name:s?.name})}finally{A&&(self.URL||self.webkitURL).revokeObjectURL(A)}}class ar{constructor(){this.messages={},this.messageIdNext=0,this.worker=new ir,this.worker.onmessage=A=>this.onMessage(A)}makeMessageId(){return++this.messageIdNext}makeMessagePromiseId(){const A=this.makeMessageId(),n=new Promise((t,e)=>{this.messages[A]={resolve:t,reject:e}});return{id:A,promise:n}}onMessage(A){const{id:n,result:t,error:e}=A.data,i=this.messages[n];i&&(delete this.messages[n],e?i.reject(e):i.resolve(t))}async call(A,n){const{id:t,promise:e}=this.makeMessagePromiseId();return this.worker.postMessage({name:A,args:n,id:t},{transfer:sa(n)}),e}}let is=4,Vn=0;const as=[],rs=[];async function rr(){const s=as.shift();if(s)return s;if(Vn<is){const A=new ar;return Vn+=1,A}return new Promise(A=>{rs.push(A)})}function or(s){if(Vn>is){Vn-=1;return}const A=rs.shift();if(A){A(s);return}as.push(s)}async function fn(s){const A=await rr();try{return await s(A)}finally{or(A)}}function gr(s){const A=new DataView(s.buffer);if((A.getUint32(0,!0)&16777215)===7957616)return"ply";if((A.getUint32(0,!0)&16777215)===559903){const n=ua(s,4);return new DataView(n.buffer).getUint32(0,!0)===1347635022?"spz":void 0}}function Ir(s){const A=s.split(/[?#]/,1)[0],n=Math.max(A.lastIndexOf("/"),A.lastIndexOf("\\")),t=A.slice(n+1),e=t.lastIndexOf(".");return e<=0||e===t.length-1?"":t.slice(e+1).toLowerCase()}function cr(s){const A=Ir(s);if(A==="ply")return"ply";if(A==="spz")return"spz";if(A==="splat")return"splat";if(A==="ksplat")return"ksplat"}async function Br({input:s,fileType:A,pathOrUrl:n}){const t=s instanceof ArrayBuffer?new Uint8Array(s):s;let e=A;switch(A||(e=gr(t),!e&&n&&(e=cr(n))),e){case"ply":{const i=new tr({fileBytes:t});await i.parseHeader();const a=i.numSplats,r=pA(a).maxSplats,o={fileBytes:t,packedArray:new Uint32Array(r*4)};return await fn(async g=>{const{packedArray:c,numSplats:I,extra:B}=await g.call("unpackPly",o);return{packedArray:c,numSplats:I,extra:B}})}case"spz":return await fn(async i=>{const{packedArray:a,numSplats:r,extra:o}=await i.call("decodeSpz",{fileBytes:t});return{packedArray:a,numSplats:r,extra:o}});case"splat":return await fn(async i=>{const{packedArray:a,numSplats:r}=await i.call("decodeAntiSplat",{fileBytes:t});return{packedArray:a,numSplats:r}});case"ksplat":return await fn(async i=>{const{packedArray:a,numSplats:r,extra:o}=await i.call("decodeKsplat",{fileBytes:t});return{packedArray:a,numSplats:r,extra:o}});default:throw new Error(`Unknown splat file type: ${e}`)}}var Qr=`precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out uvec4 target;

{{ GLOBALS }}

void produceSplat(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        produceSplat(index);
    } else {
        target = uvec4(0u, 0u, 0u, 0u);
    }
}`;const SA=class AA{constructor(A={}){this.maxSplats=0,this.numSplats=0,this.packedArray=null,this.isInitialized=!1,this.target=null,this.source=null,this.needsUpdate=!0,this.extra={},this.dyno=new Lt({packedSplats:this}),this.initialized=Promise.resolve(this),this.reinitialize(A)}reinitialize(A){this.isInitialized=!1,A.url||A.fileBytes||A.construct?this.initialized=this.asyncInitialize(A).then(()=>(this.isInitialized=!0,this)):(this.initialize(A),this.isInitialized=!0,this.initialized=Promise.resolve(this))}initialize(A){A.packedArray?(this.packedArray=A.packedArray,this.maxSplats=Math.floor(this.packedArray.length/4),this.maxSplats=Math.floor(this.maxSplats/T)*T,this.numSplats=Math.min(this.maxSplats,A.numSplats??Number.POSITIVE_INFINITY)):(this.maxSplats=A.maxSplats??0,this.numSplats=0),this.extra=A.extra??{}}async asyncInitialize(A){let{url:n,fileBytes:t,construct:e}=A;if(n&&(t=await fetch(n).then(async i=>{if(!i.ok)throw new Error(`${i.status} "${i.statusText}" fetching URL: ${n}`);return await i.arrayBuffer()})),t){const i=await Br({input:t,fileType:A.fileType,pathOrUrl:A.fileName??n});this.initialize(i)}if(e){const i=e(this);i instanceof Promise&&await i}}dispose(){this.target&&(this.target.dispose(),this.target=null),this.source&&(this.source.dispose(),this.source=null)}ensureSplats(A){const n=A<=this.maxSplats?this.maxSplats:Math.max(A,2*this.maxSplats),t=this.packedArray?this.packedArray.length/4:0;if(!this.packedArray||n>t){this.maxSplats=pA(n).maxSplats;const e=new Uint32Array(this.maxSplats*4);this.packedArray&&e.set(this.packedArray),this.packedArray=e}return this.packedArray}ensureSplatsSh(A,n){let t,e;if(A===0)return this.ensureSplats(n);if(A===1)t=2,e="sh1";else if(A===2)t=4,e="sh2";else if(A===3)t=4,e="sh3";else throw new Error(`Invalid level: ${A}`);let i=this.extra[e]?this.extra[e].length/t:0;const a=n<=i?i:Math.max(n,2*i);if(!this.extra[e]||a>i){i=pA(a).maxSplats;const r=new Uint32Array(i*t);this.extra[e]&&r.set(this.extra[e]),this.extra[e]=r}return this.extra[e]}getSplat(A){if(!this.packedArray||A>=this.numSplats)throw new Error("Invalid index");return Zt(this.packedArray,A)}setSplat(A,n,t,e,i,a){const r=this.ensureSplats(A+1);Xt(r,A,n.x,n.y,n.z,t.x,t.y,t.z,e.x,e.y,e.z,e.w,i,a.r,a.g,a.b),this.numSplats=Math.max(this.numSplats,A+1)}pushSplat(A,n,t,e,i){const a=this.ensureSplats(this.numSplats+1);Xt(a,this.numSplats,A.x,A.y,A.z,n.x,n.y,n.z,t.x,t.y,t.z,t.w,e,i.r,i.g,i.b),++this.numSplats}forEachSplat(A){if(!(!this.packedArray||!this.numSplats))for(let n=0;n<this.numSplats;++n){const t=Zt(this.packedArray,n);A(n,t.center,t.scales,t.quaternion,t.opacity,t.color)}}ensureGenerate(A){if(this.target&&(A??1)<=this.maxSplats)return!1;this.dispose();const n=pA(A??1),{width:t,height:e,depth:i}=n;return this.maxSplats=n.maxSplats,this.target=new Ee(t,e,i,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:ln,minFilter:ln}),this.target.texture.format=In,this.target.texture.type=ZA,this.target.texture.internalFormat="RGBA32UI",!0}generateMapping(A){let n=0;const t=A.map(e=>{const i=n,a=Math.ceil(e/T)*T;return n+=a,{base:i,count:e}});return{maxSplats:n,mapping:t}}getTexture(){return this.target?this.target.texture:this.source||this.packedArray?this.maybeUpdateSource():AA.getEmpty()}maybeUpdateSource(){if(!this.packedArray)throw new Error("No packed splats");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:A,height:n,depth:t}=this.source.image;this.maxSplats!==A*n*t&&(this.source.dispose(),this.source=null)}if(this.source)this.packedArray.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.packedArray.buffer));else{const{width:A,height:n,depth:t}=pA(this.maxSplats);this.source=new XA(this.packedArray,A,n,t),this.source.format=In,this.source.type=ZA,this.source.internalFormat="RGBA32UI",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}static getEmpty(){if(!AA.emptySource){const{width:A,height:n,depth:t,maxSplats:e}=pA(1),i=new Uint32Array(e*4);AA.emptySource=new XA(i,A,n,t),AA.emptySource.format=In,AA.emptySource.type=ZA,AA.emptySource.internalFormat="RGBA32UI",AA.emptySource.needsUpdate=!0}return AA.emptySource}prepareProgramMaterial(A){let n=AA.generatorProgram.get(A);if(!n){const e=zA({index:"int"},{output:"uvec4"},({index:i})=>{A.inputs.index=i;const a=A.outputs.gsplat;return{output:Ji(a)}});AA.programTemplate||(AA.programTemplate=new ze(Qr)),n=new qe({graph:e,inputs:{index:"index"},outputs:{output:"target"},template:AA.programTemplate}),Object.assign(n.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),AA.generatorProgram.set(A,n)}const t=n.prepareMaterial();return AA.mesh.material=t,{program:n,material:t}}saveRenderState(A){return{xrPresenting:A.xr.isPresenting,autoClear:A.autoClear,scissorTest:A.getScissorTest(),pixelRatio:A.getPixelRatio()}}resetRenderState(A,n){A.setRenderTarget(null),A.setPixelRatio(n.pixelRatio),A.xr.isPresenting=n.xrPresenting,A.autoClear=n.autoClear,A.setScissorTest(n.scissorTest)}generate({generator:A,base:n,count:t,renderer:e}){if(!this.target)throw new Error("Target must be initialized with ensureSplats");if(n+t>this.maxSplats)throw new Error("Base + count exceeds maxSplats");const{program:i,material:a}=this.prepareProgramMaterial(A);i.update();const r=this.saveRenderState(e),o=Math.ceil((n+t)/T)*T,g=T*PA;for(a.uniforms.targetBase.value=n,a.uniforms.targetCount.value=t;n<o;){const c=Math.floor(n/g);a.uniforms.targetLayer.value=c;const I=c*g,B=Math.floor((n-I)/T),Q=Math.min(PA,Math.ceil((o-I)/T));e.setPixelRatio(1),e.setRenderTarget(this.target,c),e.xr.isPresenting=!1,e.autoClear=!1,e.setScissorTest(!0),e.setScissor(0,B,T,Q-B),e.render(AA.scene,AA.camera),n+=T*(Q-B)}return this.resetRenderState(e,r),{nextBase:o}}};SA.emptySource=null;SA.programTemplate=null;SA.generatorProgram=new Map;SA.geometry=new Kn(2,2);SA.mesh=new $A(SA.geometry,new bt({visible:!1}));SA.scene=new NA().add(SA.mesh);SA.camera=new le;let hn=SA;class Lt extends xA{constructor({packedSplats:A}={}){super({key:"packedSplats",type:Wn,globals:()=>[Rt],value:{texture:hn.getEmpty(),numSplats:0},update:n=>{var t,e;return n.texture=((t=this.packedSplats)==null?void 0:t.getTexture())??hn.getEmpty(),n.numSplats=((e=this.packedSplats)==null?void 0:e.numSplats)??0,n}}),this.packedSplats=A}}class mt extends ws{constructor(A,n){super(),this.ordering=A,this.setAttribute("position",new mn(lr,3)),this.setIndex(new mn(Er,1)),this._maxInstanceCount=A.length,this.instanceCount=n,this.attribute=new he(A,1,!1,1),this.attribute.setUsage(Ds),this.setAttribute("splatIndex",this.attribute)}update(A,n){this.ordering=A,this.attribute.array=A,this.instanceCount=n,this.attribute.addUpdateRange(0,n),this.attribute.needsUpdate=!0}}const lr=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0]),Er=new Uint16Array([0,1,2,0,2,3]),Ut=class yn{constructor(A){if(this.lastTime=null,this.encodeLinear=!1,this.superXY=1,this.display=null,this.sorting=null,this.pending=null,this.sortingCheck=!1,this.readback=new Uint16Array(0),this.spark=A.spark,this.camera=A.camera,this.viewToWorld=A.viewToWorld??new fA,A.target){const{width:n,height:t,doubleBuffer:e}=A.target,i=Math.max(1,Math.min(4,A.target.superXY??1));if(this.superXY=i,n*i>8192||t*i>8192)throw new Error("Target size too large");this.target=new qt(n*i,t*i,{format:En,type:Sn,colorSpace:qA}),e&&(this.back=new qt(n*i,t*i,{format:En,type:Sn,colorSpace:qA})),this.encodeLinear=!0}this.onTextureUpdated=A.onTextureUpdated,this.sortRadial=A.sortRadial??!0,this.sortDistance=A.sortDistance,this.sortCoorient=A.sortCoorient,this.depthBias=A.depthBias,this.sort360=A.sort360,this.orderingFreelist=new ia({allocate:n=>new Uint32Array(n),valid:(n,t)=>n.length===t}),this.autoUpdate=!1,this.setAutoUpdate(A.autoUpdate??!1)}dispose(){var A;this.setAutoUpdate(!1),this.target&&(this.target.dispose(),this.target=void 0),this.back&&(this.back.dispose(),this.back=void 0),this.display&&(this.spark.releaseAccumulator(this.display.accumulator),this.display.geometry.dispose(),this.display=null),(A=this.pending)!=null&&A.accumulator&&(this.spark.releaseAccumulator(this.pending.accumulator),this.pending=null)}setAutoUpdate(A){!this.autoUpdate&&A?this.spark.autoViewpoints.push(this):this.autoUpdate&&!A&&(this.spark.autoViewpoints=this.spark.autoViewpoints.filter(n=>n!==this)),this.autoUpdate=A}async prepare({scene:A,camera:n,viewToWorld:t,update:e,forceOrigin:i}){var a;for(t?this.viewToWorld=t:(this.camera=n??this.camera,this.camera&&(this.camera.updateMatrixWorld(),this.viewToWorld=this.camera.matrixWorld.clone()));e??!0;){const o=i?this.viewToWorld:void 0;if(this.spark.updateInternal({scene:A,originToWorld:o}))break;await new Promise(c=>setTimeout(c,10))}const r=this.spark.active;r!==((a=this.display)==null?void 0:a.accumulator)&&(this.spark.active.refCount+=1),await this.sortUpdate({accumulator:r,viewToWorld:this.viewToWorld})}renderTarget({scene:A,camera:n}){var t;const e=this.back??this.target;if(!e)throw new Error("Must initialize SparkViewpoint with target");if(n=n??this.camera,!n)throw new Error("Must provide camera");if(n instanceof Pn){const i=new Pn().copy(n,!1);i.aspect=e.width/e.height,i.updateProjectionMatrix(),n=i}this.viewToWorld=n.matrixWorld.clone();try{this.spark.renderer.setRenderTarget(e),this.spark.prepareViewpoint(this),this.spark.renderer.render(A,n)}finally{this.spark.prepareViewpoint(this.spark.defaultView),this.spark.renderer.setRenderTarget(null)}e!==this.target&&([this.target,this.back]=[this.back,this.target]),(t=this.onTextureUpdated)==null||t.call(this,e.texture)}async readTarget(){if(!this.target)throw new Error("Must initialize SparkViewpoint with target");const{width:A,height:n}=this.target,t=A*n*4;(!this.superPixels||this.superPixels.length<t)&&(this.superPixels=new Uint8Array(t)),await this.spark.renderer.readRenderTargetPixelsAsync(this.target,0,0,A,n,this.superPixels);const{superXY:e}=this;if(e===1)return this.superPixels;const i=A/e,a=n/e,r=i*a*4;(!this.pixels||this.pixels.length<r)&&(this.pixels=new Uint8Array(r));const{superPixels:o,pixels:g}=this,c=e*e;for(let I=0;I<a;I++){const B=I*i;for(let Q=0;Q<i;Q++){const l=Q*e;let C=0,E=0,h=0,f=0;for(let y=0;y<e;y++){const w=(I*e+y)*this.target.width;for(let S=0;S<e;S++){const M=(w+l+S)*4;C+=o[M],E+=o[M+1],h+=o[M+2],f+=o[M+3]}}const u=(B+Q)*4;g[u]=C/c,g[u+1]=E/c,g[u+2]=h/c,g[u+3]=f/c}}return g}async prepareRenderPixels({scene:A,camera:n,viewToWorld:t,update:e,forceOrigin:i}){return await this.prepare({scene:A,camera:n,viewToWorld:t,update:e,forceOrigin:i}),this.renderTarget({scene:A,camera:n}),this.readTarget()}autoPoll({accumulator:A}){var n,t,e,i;this.camera&&(this.camera.updateMatrixWorld(),this.viewToWorld=this.camera.matrixWorld.clone());let a=!1,r=!1;if(!this.display)a=!0;else if(A){a=!0;const{mappingVersion:g}=this.display.accumulator;A.mappingVersion===g&&(this.spark.releaseAccumulator(this.display.accumulator),this.display.accumulator=A,r=!0)}const o=((n=this.sorting)==null?void 0:n.viewToWorld)??((t=this.display)==null?void 0:t.viewToWorld);o&&!ft({matrix1:this.viewToWorld,matrix2:o,maxDistance:this.sortDistance??.01,minCoorient:this.sortCoorient??this.sortRadial?.99:.999})&&(a=!0),a&&(A&&(A.refCount+=1),A&&((e=this.pending)!=null&&e.accumulator)&&this.pending.accumulator!==((i=this.display)==null?void 0:i.accumulator)&&this.spark.releaseAccumulator(this.pending.accumulator),this.pending={accumulator:A,viewToWorld:this.viewToWorld,displayed:r},this.driveSort())}async driveSort(){for(var A;;){if(this.sorting||!this.pending)return;const{viewToWorld:n,displayed:t}=this.pending;let e=this.pending.accumulator??((A=this.display)==null?void 0:A.accumulator);if(e||(e=this.spark.active,e.refCount+=1),this.pending=null,!e)throw new Error("No accumulator to sort");this.sorting={viewToWorld:n},await this.sortUpdate({accumulator:e,viewToWorld:n,displayed:t}),this.sorting=null}}async sortUpdate({accumulator:A,viewToWorld:n,displayed:t=!1}){if(this.sortingCheck)throw new Error("Only one sort at a time");this.sortingCheck=!0,A=A??this.spark.active;const{numSplats:e,maxSplats:i}=A.splats;let a=0,r=this.orderingFreelist.alloc(i);if(e>0){const{reader:o,doubleSortReader:g,dynoSortRadial:c,dynoOrigin:I,dynoDirection:B,dynoDepthBias:Q,dynoSort360:l,dynoSplats:C}=yn.makeSorter(),E=Math.ceil(i/2);this.readback=o.ensureBuffer(E,this.readback);const h=A.toWorld.clone().invert(),f=n.clone().premultiply(h);c.value=this.sort360?!0:this.sortRadial,I.value.set(0,0,0).applyMatrix4(f),B.value.set(0,0,-1).applyMatrix4(f).sub(I.value).normalize(),Q.value=this.depthBias??1,l.value=this.sort360??!1,C.packedSplats=A.splats,await o.renderReadback({renderer:this.spark.renderer,reader:g,count:Math.ceil(e/2),readback:this.readback});const u=await fn(async y=>y.call("sortDoubleSplats",{numSplats:e,readback:this.readback,ordering:r}));this.readback=u.readback,r=u.ordering,a=u.activeSplats}this.updateDisplay({accumulator:A,viewToWorld:n,ordering:r,activeSplats:a,displayed:t}),this.sortingCheck=!1}updateDisplay({accumulator:A,viewToWorld:n,ordering:t,activeSplats:e,displayed:i=!1}){if(!this.display)this.display={accumulator:A,viewToWorld:n,geometry:new mt(t,e)};else{!i&&A!==this.display.accumulator&&(this.spark.releaseAccumulator(this.display.accumulator),this.display.accumulator=A),this.display.viewToWorld=n;const a=this.display.geometry.ordering;a.length===t.length?this.display.geometry.update(t,e):(this.display.geometry.dispose(),this.display.geometry=new mt(t,e)),this.orderingFreelist.free(a)}this.spark.viewpoint===this&&this.spark.prepareViewpoint(this)}static makeSorter(){if(!yn.dynos){const A=new Vt({value:!0}),n=new jn({value:new m}),t=new jn({value:new m}),e=new bn({value:1}),i=new Vt({value:!1}),a=new Lt,r=new Oe,o=zA({index:"int"},{rgba8:"vec4"},({index:g})=>{if(!g)throw new Error("No index");const c={sortRadial:A,sortOrigin:n,sortDirection:t,sortDepthBias:e,sort360:i},I=Pe(g,ut("int",2)),B=On(a,I),Q=ee({gsplat:B,...c}),l=On(a,xn(I,ut("int",1))),C=ee({gsplat:l,...c}),E=Fa({vectorType:"vec2",x:Q,y:C});return{rgba8:Sa(xa(E))}});yn.dynos={dynoSortRadial:A,dynoOrigin:n,dynoDirection:t,dynoDepthBias:e,dynoSort360:i,dynoSplats:a,reader:r,doubleSortReader:o}}return yn.dynos}};Ut.EMPTY_TEXTURE=new lt;Ut.dynos=null;let te=Ut;const Cr=lA(`
  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {
    if (!isGsplatActive(gsplat.flags)) {
      return INFINITY;
    }

    vec3 center = gsplat.center - sortOrigin;
    float biasedDepth = dot(center, sortDirection) + sortDepthBias;
    if (!sort360 && (biasedDepth <= 0.0)) {
      return INFINITY;
    }

    return sortRadial ? length(center) : biasedDepth;
  }
`);function ee({gsplat:s,sortRadial:A,sortOrigin:n,sortDirection:t,sortDepthBias:e,sort360:i}){return Xn({inTypes:{gsplat:W,sortRadial:"bool",sortOrigin:"vec3",sortDirection:"vec3",sortDepthBias:"float",sort360:"bool"},outTypes:{metric:"float"},globals:()=>[kA,Cr],inputs:{gsplat:s,sortRadial:A,sortOrigin:n,sortDirection:t,sortDepthBias:e,sort360:i},statements:({inputs:a,outputs:r})=>{const{gsplat:o,sortRadial:g,sortOrigin:c,sortDirection:I,sortDepthBias:B,sort360:Q}=a;return bA(`
        ${r.metric} = computeSort(${o}, ${g}, ${c}, ${I}, ${B}, ${Q});
      `)}}).outputs.metric}class ot{constructor(){this.splats=new hn,this.toWorld=new fA,this.mapping=[],this.refCount=0,this.splatsVersion=-1,this.mappingVersion=-1}ensureGenerate(A){this.splats.ensureGenerate(A)&&(this.mapping=[])}generateSplats({renderer:A,modifier:n,generators:t,forceUpdate:e,originToWorld:i}){const a=this.mapping.reduce((g,c)=>(g.set(c.node,c),g),new Map);let r=0,o=0;for(const{node:g,generator:c,version:I,base:B,count:Q}of t){const l=a.get(g);if((e||c!==l?.generator||I!==l?.version||B!==l?.base||Q!==l?.count)&&c&&Q>0){const C=n.apply(c);try{this.splats.generate({generator:C,base:B,count:Q,renderer:A})}catch(E){g.generator=void 0,g.generatorError=E}r+=1}o=Math.max(o,B+Q)}return this.splats.numSplats=o,this.toWorld=i,this.mapping=t,r!==0}hasCorrespondence(A){return this.mapping.length!==A.mapping.length?!1:this.mapping.every(({node:n,base:t,count:e},i)=>{const{node:a,base:r,count:o}=A.mapping[i];return n===a&&t===r&&e===o})}}var hr=`const float LN_SCALE_MIN = -9.0;
const float LN_SCALE_MAX = 9.0;
const float LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254.0; 

const uint SPLAT_TEX_WIDTH_BITS = 11u;
const uint SPLAT_TEX_HEIGHT_BITS = 11u;
const uint SPLAT_TEX_DEPTH_BITS = 11u;
const uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;

const uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;
const uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;
const uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;

const uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;
const uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;
const uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;

const uint F16_INF = 0x7c00u;
const float PI = 3.1415926535897932384626433832795;

const float INFINITY = 1.0 / 0.0;
const float NEG_INFINITY = -INFINITY;

const float MAX_PIXEL_RADIUS = 512.0;
const float MIN_ALPHA = 0.5 * (1.0 / 255.0); 
const float MAX_STDDEV = sqrt(8.0);

float sqr(float x) {
    return x * x;
}

float pow4(float x) {
    float x2 = x * x;
    return x2 * x2;
}

float pow8(float x) {
    float x4 = pow4(x);
    return x4 * x4;
}

vec3 srgbToLinear(vec3 rgb) {
    return pow(rgb, vec3(2.2));
}

vec3 linearToSrgb(vec3 rgb) {
    return pow(rgb, vec3(1.0 / 2.2));
}

uint encodeQuatOctXy88R8(vec4 q) {
    
    if (q.w < 0.0) {
        q = -q;
    }
    
    float theta = 2.0 * acos(q.w);
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    
    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;
    
    
    
    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);
    vec2 p = vec2(axis.x, axis.y) / sum;
    
    if (axis.z < 0.0) {
        float oldPx = p.x;
        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);
        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);
    }
    
    float u_f = p.x * 0.5 + 0.5;
    float v_f = p.y * 0.5 + 0.5;
    
    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));
    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));
    
    
    
    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));
    
    
    return (angleInt << 16u) | (quantV << 8u) | quantU;
}

vec4 decodeQuatOctXy88R8(uint encoded) {
    
    uint quantU = encoded & uint(0xFFu);               
    uint quantV = (encoded >> 8u) & uint(0xFFu);         
    uint angleInt = encoded >> 16u;                      

    
    float u_f = float(quantU) / 255.0;
    float v_f = float(quantV) / 255.0;
    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);

    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));
    float t = max(-axis.z, 0.0);
    axis.x += (axis.x >= 0.0) ? -t : t;
    axis.y += (axis.y >= 0.0) ? -t : t;
    axis = normalize(axis);
    
    
    float theta = (float(angleInt) / 255.0) * 3.14159265359;
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    float w = cos(halfTheta);
    
    return vec4(axis * s, w);
}

    

    

    

    

    

    

    

    

    

    

uvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {
    uvec4 uRgba = uvec4(round(clamp(rgba * 255.0, 0.0, 255.0)));

    uint uQuat = encodeQuatOctXy88R8(quaternion);
    
    
    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);

    
    uvec3 uScales = uvec3(
        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,
        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,
        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u
    );

    
    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);
    uint word1 = packHalf2x16(center.xy);
    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);
    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);
    return uvec4(word0, word1, word2, word3);
}

void unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {
    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;

    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);
    rgba = vec4(uRgba) / 255.0;

    center = vec4(
        unpackHalf2x16(word1),
        unpackHalf2x16(word2 & 0xffffu)
    ).xyz;

    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);
    scales = vec3(
        (uScales.x == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.x - 1u) * LN_RESCALE),
        (uScales.y == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.y - 1u) * LN_RESCALE),
        (uScales.z == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.z - 1u) * LN_RESCALE)
    );

    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);
    quaternion = decodeQuatOctXy88R8(uQuat);
    
    
}

vec3 quatVec(vec4 q, vec3 v) {
    
    vec3 t = 2.0 * cross(q.xyz, v);
    return v + q.w * t + cross(q.xyz, t);
}

vec4 quatQuat(vec4 q1, vec4 q2) {
    return vec4(
        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,
        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z
    );
}

mat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {
    
    return mat3(
        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),
        s.x * (2.0 * (q.x * q.y + q.w * q.z)),
        s.x * (2.0 * (q.x * q.z - q.w * q.y)),
        s.y * (2.0 * (q.x * q.y - q.w * q.z)),
        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),
        s.y * (2.0 * (q.y * q.z + q.w * q.x)),
        s.z * (2.0 * (q.x * q.z + q.w * q.y)),
        s.z * (2.0 * (q.y * q.z - q.w * q.x)),
        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))
    );
}

vec4 slerp(vec4 q1, vec4 q2, float t) {
    
    float cosHalfTheta = dot(q1, q2);

    
    if (abs(cosHalfTheta) >= 0.999) {
        return q1;
    }
    
    
    
    if (cosHalfTheta < 0.0) {
        q2 = -q2;
        cosHalfTheta = -cosHalfTheta;
    }

    
    float halfTheta = acos(cosHalfTheta);
    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);

    
    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;
    float ratioB = sin(t * halfTheta) / sinHalfTheta;

    
    return q1 * ratioA + q2 * ratioB;
}

ivec3 splatTexCoord(int index) {
    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;
    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;
    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;
    return ivec3(x, y, z);
}`,ur=`precision highp float;
precision highp int;

#include <splatDefines>

uniform bool encodeLinear;
uniform float maxStdDev;
uniform bool disableFalloff;
uniform float falloff;

out vec4 fragColor;

in vec4 vRgba;
in vec2 vSplatUv;
in vec3 vNdc;

void main() {
    float z = dot(vSplatUv, vSplatUv);
    if (z > (maxStdDev * maxStdDev)) {
        discard;
    }

    float alpha = vRgba.a;
    alpha *= mix(1.0, exp(-0.5 * z), falloff);
    if (alpha < MIN_ALPHA) {
        discard;
    }

    vec3 rgb = vRgba.rgb;
    if (encodeLinear) {
        rgb = srgbToLinear(rgb);
    }
    fragColor = vec4(rgb, alpha);
}`,dr=`precision highp float;
precision highp int;
precision highp usampler2DArray;

#include <splatDefines>

attribute uint splatIndex;

out vec4 vRgba;
out vec2 vSplatUv;
out vec3 vNdc;

uniform vec2 renderSize;
uniform uint numSplats;
uniform vec4 renderToViewQuat;
uniform vec3 renderToViewPos;
uniform float maxStdDev;
uniform float time;
uniform float deltaTime;
uniform bool debugFlag;
uniform bool enable2DGS;
uniform float blurAmount;
uniform float preBlurAmount;
uniform float clipXY;

uniform usampler2DArray packedSplats;

void main() {
    
    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);

    if (uint(gl_InstanceID) >= numSplats) {
        return;
    }
    if (splatIndex == 0xffffffffu) {
        
        return;
    }

    ivec3 texCoord = ivec3(
        splatIndex & SPLAT_TEX_WIDTH_MASK,
        (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,
        splatIndex >> SPLAT_TEX_LAYER_BITS
    );
    uvec4 packed = texelFetch(packedSplats, texCoord, 0);

    vec3 center, scales;
    vec4 quaternion, rgba;
    unpackSplat(packed, center, scales, quaternion, rgba);

    if (rgba.a < MIN_ALPHA) {
        return;
    }
    bvec3 zeroScales = equal(scales, vec3(0.0));
    if (all(zeroScales)) {
        return;
    }

    
    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;

    
    if (viewCenter.z >= 0.0) {
        return;
    }

    
    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);

    
    if (abs(clipCenter.z) >= clipCenter.w) {
        return;
    }

    
    float clip = clipXY * clipCenter.w;
    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {
        return;
    }

    
    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);

    if (enable2DGS && any(zeroScales)) {
        vRgba = rgba;
        vSplatUv = position.xy * maxStdDev;

        vec3 offset;
        if (zeroScales.z) {
            offset = vec3(vSplatUv.xy * scales.xy, 0.0);
        } else if (zeroScales.y) {
            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);
        } else {
            offset = vec3(0.0, vSplatUv.xy * scales.yz);
        }

        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);
        gl_Position = projectionMatrix * vec4(viewPos, 1.0);
        vNdc = gl_Position.xyz / gl_Position.w;
        return;
    }

    
    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

    
    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);
    mat3 cov3D = RS * transpose(RS);

    
    vec2 focal = 0.5 * renderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);
    float invZ = 1.0 / viewCenter.z;
    vec2 J1 = focal * invZ;
    vec2 J2 = -(J1 * viewCenter.xy) * invZ;
    mat3 J = mat3(
        J1.x, 0.0, J2.x,
        0.0, J1.y, J2.y,
        0.0, 0.0, 0.0
    );

    
    
    
    
    
    
    
    mat3 cov2D = transpose(J) * cov3D * J;
    float a = cov2D[0][0];
    float d = cov2D[1][1];
    float b = cov2D[0][1];

    
    a += preBlurAmount;
    d += preBlurAmount;

    
    float detOrig = a * d - b * b;
    a += blurAmount;
    d += blurAmount;
    float det = a * d - b * b;

    
    float blurAdjust = sqrt(max(0.0, detOrig / det));
    rgba.a *= blurAdjust;
    if (rgba.a < MIN_ALPHA) {
        return;
    }

    
    float eigenAvg = 0.5 * (a + d);
    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));
    float eigen1 = eigenAvg + eigenDelta;
    float eigen2 = eigenAvg - eigenDelta;

    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));
    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);

    float scale1 = position.x * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen1));
    float scale2 = position.y * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen2));

    
    vec2 pixelOffset = eigenVec1 * scale1 + eigenVec2 * scale2;
    vec2 ndcOffset = (2.0 / renderSize) * pixelOffset;
    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);

    vRgba = rgba;
    vSplatUv = position.xy * maxStdDev;
    vNdc = ndc;
    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);
}`;let gt=null;function pr(){return gt||(vs.splatDefines=hr,gt={splatVertex:dr,splatFragment:ur}),gt}const se=5;let wt=!1,Dt=!1,os;function fr(s){let A=!1;return s instanceof Fn?!0:(s.traverse(n=>{A=A||n instanceof Fn}),A)}const gs=NA.prototype.add;NA.prototype.add=function(s){return wt=wt||fr(s),Dt=Dt||s instanceof Tt,gs.call(this,s),this};const yr=NA.prototype.onBeforeRender;NA.prototype.onBeforeRender=function(s){if(wt){if(!Dt){const A=os||new Tt({renderer:s});this.add(A)}NA.prototype.onBeforeRender=yr,NA.prototype.add=gs}};const _t=class EA extends $A{constructor(A){const n=EA.makeUniforms(),t=pr(),e=new xs({glslVersion:ue,vertexShader:t.splatVertex,fragmentShader:t.splatFragment,uniforms:n,transparent:!0,blending:Ss,depthTest:!0,depthWrite:!1,side:de});super(ie,e),this.autoViewpoints=[],this.rotateToAccumulator=new Nt({value:new IA}),this.translateToAccumulator=new jn({value:new m}),this.lastFrame=-1,this.lastUpdateTime=null,this.defaultCameras=[],this.pendingUpdate=null,this.envViewpoint=null,this.frustumCulled=!1,this.renderer=A.renderer,this.material=e,this.uniforms=n;const i=zA({gsplat:W},{gsplat:W},({gsplat:a})=>{if(!a)throw new Error("gsplat not defined");return a=Ne(a,{rotate:this.rotateToAccumulator,translate:this.translateToAccumulator}),{gsplat:a}});this.modifier=new Va(i),this.autoUpdate=A.autoUpdate??!0,this.preUpdate=A.preUpdate??!1,this.originDistance=A.originDistance??1,this.maxStdDev=A.maxStdDev??Math.sqrt(8),this.enable2DGS=A.enable2DGS??!0,this.preBlurAmount=A.preBlurAmount??0,this.blurAmount=A.blurAmount??.3,this.falloff=A.falloff??1,this.clipXY=A.clipXY??1.4,this.active=new ot,this.accumulatorCount=1,this.freeAccumulators=[];for(let a=0;a<1;++a)this.freeAccumulators.push(new ot),this.accumulatorCount+=1;this.defaultView=new te({...A.view,autoUpdate:!0,spark:this}),this.viewpoint=this.defaultView,this.prepareViewpoint(this.viewpoint),this.clock=A.clock?ca(A.clock):new pe,os=this}static makeUniforms(){return{renderSize:{value:new cn},numSplats:{value:0},renderToViewQuat:{value:new IA},renderToViewPos:{value:new m},maxStdDev:{value:1},enable2DGS:{value:!1},preBlurAmount:{value:0},blurAmount:{value:.3},falloff:{value:1},clipXY:{value:1.4},packedSplats:{type:"t",value:hn.getEmpty()},time:{value:0},deltaTime:{value:0},encodeLinear:{value:!1},debugFlag:{value:!1}}}canAllocAccumulator(){return this.freeAccumulators.length>0||this.accumulatorCount<se}maybeAllocAccumulator(){let A=this.freeAccumulators.pop();if(A===void 0){if(this.accumulatorCount>=se)return null;A=new ot,this.accumulatorCount+=1}return A.refCount=1,A}releaseAccumulator(A){A.refCount-=1,A.refCount===0&&this.freeAccumulators.push(A)}newViewpoint(A){return new te({...A,spark:this})}onBeforeRender(A,n,t){var e,i;const a=this.time??this.clock.getElapsedTime(),r=a-(this.viewpoint.lastTime??a);this.viewpoint.lastTime=a;const o=A.info.render.frame,g=o!==this.lastFrame;this.lastFrame=o;const c=this.viewpoint;if(c===this.defaultView){if(g)if(!A.xr.isPresenting)this.defaultView.viewToWorld=t.matrixWorld.clone(),this.defaultCameras=[this.defaultView.viewToWorld];else{const l=A.xr.getCamera().cameras;this.defaultCameras=[l[0].matrixWorld,l[1].matrixWorld],this.defaultView.viewToWorld=mr(this.defaultCameras)??new fA}this.autoUpdate&&this.update({scene:n,viewToWorld:this.defaultView.viewToWorld})}if(g&&(this.uniforms.time.value=a,this.uniforms.deltaTime.value=r,this.uniforms.debugFlag.value=performance.now()/1e3%2<1),c.target)this.uniforms.renderSize.value.set(c.target.width,c.target.height);else{const l=A.getSize(this.uniforms.renderSize.value);if(l.x===1&&l.y===1){const C=(e=A.xr.getSession())==null?void 0:e.renderState.baseLayer;C&&(l.x=C.framebufferWidth,l.y=C.framebufferHeight)}}this.uniforms.encodeLinear.value=c.encodeLinear,this.uniforms.maxStdDev.value=this.maxStdDev,this.uniforms.enable2DGS.value=this.enable2DGS,this.uniforms.preBlurAmount.value=this.preBlurAmount,this.uniforms.blurAmount.value=this.blurAmount,this.uniforms.falloff.value=this.falloff,this.uniforms.clipXY.value=this.clipXY;const I=((i=c.display)==null?void 0:i.accumulator.toWorld)??new fA,B=t.matrixWorld.clone().invert();I.clone().premultiply(B).decompose(this.uniforms.renderToViewPos.value,this.uniforms.renderToViewQuat.value,new m)}prepareViewpoint(A){if(this.viewpoint=A??this.viewpoint,this.viewpoint.display){const{accumulator:n,geometry:t}=this.viewpoint.display;this.uniforms.numSplats.value=n.splats.numSplats,this.uniforms.packedSplats.value=n.splats.getTexture(),this.geometry=t}else this.uniforms.numSplats.value=0,this.uniforms.packedSplats.value=hn.getEmpty(),this.geometry=ie}update({scene:A,viewToWorld:n}){const t=this.matrixWorld.clone();this.preUpdate?this.updateInternal({scene:A,originToWorld:t,viewToWorld:n}):(this.pendingUpdate={scene:A,originToWorld:t},setTimeout(()=>{if(this.pendingUpdate){const{scene:e,originToWorld:i}=this.pendingUpdate;this.pendingUpdate=null,this.updateInternal({scene:e,originToWorld:i,viewToWorld:n})}},1))}updateInternal({scene:A,originToWorld:n,viewToWorld:t}){var e;if(!this.canAllocAccumulator())return!1;n||(n=this.active.toWorld),t=t??n.clone();const i=this.time??this.clock.getElapsedTime(),a=i-(this.lastUpdateTime??i);this.lastUpdateTime=i;const r=this.active.mapping.reduce((Q,l)=>(Q.set(l.node,l),Q),new Map),{generators:o,globalEdits:g}=this.compileScene(A);for(const Q of o)(e=Q.frameUpdate)==null||e.call(Q,{object:Q,time:i,deltaTime:a,viewToWorld:t,globalEdits:g});for(const Q of o){const l=r.get(Q),C=Q.generator?Q.numSplats:0;(Q.generator!==l?.generator||C!==l?.count)&&Q.updateVersion()}const I=!ft({matrix1:n,matrix2:this.active.toWorld,maxDistance:this.originDistance})||o.length!==r.size||o.some(Q=>{var l;return Q.version!==((l=r.get(Q))==null?void 0:l.version)});let B=null;if(I){if(B=this.maybeAllocAccumulator(),!B)throw new Error("Unreachable");const Q=!ft({matrix1:n,matrix2:this.active.toWorld,maxDistance:1e-5,minCoorient:.99999}),C=o.map((w,S)=>{const M=r.get(w);return M?[w.version-M.version,M.base,w]:[Number.POSITIVE_INFINITY,w.version,w]}).sort((w,S)=>w[0]!==S[0]?w[0]-S[0]:w[1]-S[1]).map(([w,S,M])=>M),E=C.map(w=>w.numSplats),{maxSplats:h,mapping:f}=B.splats.generateMapping(E),u=C.map((w,S)=>{const{base:M,count:K}=f[S];return{node:w,generator:w.generator,version:w.version,base:M,count:K}});n.clone().invert().decompose(this.translateToAccumulator.value,this.rotateToAccumulator.value,new m),B.ensureGenerate(h),B.generateSplats({renderer:this.renderer,modifier:this.modifier,generators:u,forceUpdate:Q,originToWorld:n}),B.splatsVersion=this.active.splatsVersion+1;const y=B.hasCorrespondence(this.active);B.mappingVersion=this.active.mappingVersion+(y?0:1),this.releaseAccumulator(this.active),this.active=B,this.prepareViewpoint()}return setTimeout(()=>{for(const Q of this.autoViewpoints)Q.autoPoll({accumulator:B??void 0})},1),!0}compileScene(A){const n=[];A.traverse(e=>{e instanceof ts&&n.push(e)});const t=new Set;return A.traverseVisible(e=>{if(e instanceof We){let i=e.parent;for(;i!=null&&!(i instanceof Fn);)i=i.parent;i==null&&t.add(e)}}),{generators:n,globalEdits:Array.from(t)}}async renderEnvMap({renderer:A,scene:n,worldCenter:t,size:e=256,near:i=.1,far:a=1e3,hideObjects:r=[],update:o=!1}){var g,c;if(this.envViewpoint||(this.envViewpoint=this.newViewpoint({sort360:!0})),!EA.cubeRender||EA.cubeRender.target.width!==e||EA.cubeRender.near!==i||EA.cubeRender.far!==a){EA.cubeRender&&EA.cubeRender.target.dispose();const C=new Ms(e,{format:En,generateMipmaps:!0,minFilter:bs}),E=new ks(i,a,C);EA.cubeRender={target:C,camera:E,near:i,far:a}}EA.pmrem||(EA.pmrem=new Fs(A??this.renderer));const I=new fA().setPosition(t);await((g=this.envViewpoint)==null?void 0:g.prepare({scene:n,viewToWorld:I,update:o}));const{target:B,camera:Q}=EA.cubeRender;Q.position.copy(t);const l=new Map;for(const C of r)l.set(C,C.visible),C.visible=!1;this.prepareViewpoint(this.envViewpoint),Q.update(A??this.renderer,n),this.prepareViewpoint(this.defaultView);for(const[C,E]of l.entries())C.visible=E;return(c=EA.pmrem)==null?void 0:c.fromCubemap(B.texture).texture}recurseSetEnvMap(A,n){A.traverse(t=>{if(t instanceof $A)if(Array.isArray(t.material))for(const e of t.material)e instanceof Cn&&(e.envMap=n);else t.material instanceof Cn&&(t.material.envMap=n)})}getRgba({generator:A,rgba:n}){const t=this.active.mapping.find(({node:e})=>e===A);if(!t)throw new Error("Generator not found");return n=n??new Ha,n.fromPackedSplats({packedSplats:this.active.splats,base:t.base,count:t.count,renderer:this.renderer}),n}async readRgba({generator:A,rgba:n}){return n=this.getRgba({generator:A,rgba:n}),n.read()}};_t.cubeRender=null;_t.pmrem=null;let Tt=_t;const ie=new mt(new Uint32Array(1),0);zA({packedSplats:Wn,index:"int"},{gsplat:W},({packedSplats:s,index:A})=>{if(!s||!A)throw new Error("Invalid input");return{gsplat:On(s,A)}});function mr(s){if(s.length===0)return null;const A=new m,n=new IA,t=new m,e=[],i=[];for(const a of s)a.decompose(A,n,t),e.push(A),i.push(n);return new fA().compose(Qa(e),la(i),new m(1,1,1))}lA(`
  struct GsplatSkinning {
    int numSplats;
    int numBones;
    usampler2DArray skinTexture;
    sampler2D boneTexture;
  };
`);lA(`
  void applyGsplatSkinning(
    int numSplats, int numBones,
    usampler2DArray skinTexture, sampler2D boneTexture,
    int splatIndex, inout vec3 center, inout vec4 quaternion
  ) {
    if ((splatIndex < 0) || (splatIndex >= numSplats)) {
      return;
    }

    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);

    float weights[4];
    weights[0] = float(skinData.x & 0xffu) / 255.0;
    weights[1] = float(skinData.y & 0xffu) / 255.0;
    weights[2] = float(skinData.z & 0xffu) / 255.0;
    weights[3] = float(skinData.w & 0xffu) / 255.0;

    uint boneIndices[4];
    boneIndices[0] = (skinData.x >> 8u) & 0xffu;
    boneIndices[1] = (skinData.y >> 8u) & 0xffu;
    boneIndices[2] = (skinData.z >> 8u) & 0xffu;
    boneIndices[3] = (skinData.w >> 8u) & 0xffu;

    vec4 quat = vec4(0.0);
    vec4 dual = vec4(0.0);
    for (int i = 0; i < 4; i++) {
      if (weights[i] > 0.0) {
        int boneIndex = int(boneIndices[i]);
        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 boneDual = vec4(0.0);
        if (boneIndex < numBones) {
          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);
          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);
        }

        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {
          // Flip sign if next blend is pointing in the opposite direction
          boneQuat = -boneQuat;
          boneDual = -boneDual;
        }
        quat += weights[i] * boneQuat;
        dual += weights[i] * boneDual;
      }
    }

    // Normalize dual quaternion
    float norm = length(quat);
    quat /= norm;
    dual /= norm;
    vec3 translate = vec3(
      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),
      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),
      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)
    );

    center = quatVec(quat, center) + translate;
    quaternion = quatQuat(quat, quaternion);
  }
`);new kt(new m(-1,-1,-1),new m(1,1,1)),new m(-1,-3,1).normalize(),new gA(1,1,1),new gA(.5,.5,1),new m(1,1,1);new kt(new m(-2,-1,-2),new m(2,5,2)),new m(0,-1,0),new gA(1,1,1),new gA(.25,.25,.5),new m(.1,1,.1);const Is=class xt{static createButton(A,n={}){const t=navigator.xr;if(!t)return null;const e=t,i=document.createElement("button");A.xr.enabled=!0,A.xr.setReferenceSpaceType("local");function a(){let I=null;async function B(C){console.log("onSessionStarted"),C.addEventListener("end",Q),await A.xr.setSession(C),i.textContent="EXIT VR",I=C}function Q(){console.log("onSessionEnded"),I?.removeEventListener("end",Q),i.textContent="ENTER VR",I=null}i.style.display="",i.style.cursor="pointer",i.style.left="calc(50% - 100px)",i.style.width="200px",i.style.height="100px",i.textContent="ENTER VR";const l={...n,optionalFeatures:[...n.optionalFeatures||[]]};i.onmouseenter=()=>{i.style.opacity="1.0"},i.onmouseleave=()=>{i.style.opacity="0.5"},i.onclick=()=>{I===null?(console.log("requesting session"),e.requestSession("immersive-vr",l).then(B)):(console.log("ending session"),I.end())}}function r(){i.style.display="none",i.style.cursor="auto",i.style.left="calc(50% - 75px)",i.style.width="150px",i.onmouseenter=null,i.onmouseleave=null,i.onclick=null}function o(){r(),i.textContent="VR NOT SUPPORTED"}function g(I){r(),console.warn("Exception when trying to call xr.isSessionSupported",I),i.textContent="VR NOT ALLOWED"}function c(I){I.style.position="absolute",I.style.bottom="20px",I.style.padding="12px 6px",I.style.border="1px solid #fff",I.style.borderRadius="4px",I.style.background="rgba(0,0,0,0.1)",I.style.color="#fff",I.style.font="normal 13px sans-serif",I.style.textAlign="center",I.style.opacity="0.5",I.style.outline="none",I.style.zIndex="999"}return i.id="VRButton",i.style.display="none",c(i),e.isSessionSupported("immersive-vr").then(I=>{I?a():o(),I&&xt.xrSessionIsGranted&&i.click()}).catch(g),i}static registerSessionGrantedListener(){const A=navigator.xr;if(!A)return null;const n=A;/WebXRViewer\//i.test(navigator.userAgent)||n.addEventListener("sessiongranted",()=>{xt.xrSessionIsGranted=!0})}};Is.xrSessionIsGranted=!1;let wr=Is;wr.registerSessionGrantedListener();var cs=(s=>(s.w="wrist",s.t0="thumb-metacarpal",s.t1="thumb-phalanx-proximal",s.t2="thumb-phalanx-distal",s.t3="thumb-tip",s.i0="index-finger-metacarpal",s.i1="index-finger-phalanx-proximal",s.i2="index-finger-phalanx-intermediate",s.i3="index-finger-phalanx-distal",s.i4="index-finger-tip",s.m0="middle-finger-metacarpal",s.m1="middle-finger-phalanx-proximal",s.m2="middle-finger-phalanx-intermediate",s.m3="middle-finger-phalanx-distal",s.m4="middle-finger-tip",s.r0="ring-finger-metacarpal",s.r1="ring-finger-phalanx-proximal",s.r2="ring-finger-phalanx-intermediate",s.r3="ring-finger-phalanx-distal",s.r4="ring-finger-tip",s.p0="pinky-finger-metacarpal",s.p1="pinky-finger-phalanx-proximal",s.p2="pinky-finger-phalanx-intermediate",s.p3="pinky-finger-phalanx-distal",s.p4="pinky-finger-tip",s))(cs||{});const Dr=Object.keys(cs);Dr.length;new m(0,0,-1),new m(0,0,1),new m(-1,0,0),new m(1,0,0),new m(0,1,0),new m(0,-1,0);new m(0,0,-1),new m(0,0,1),new m(-1,0,0),new m(1,0,0),new m(0,1,0),new m(0,-1,0);new m(0,0,1),new m(0,0,-1);new m(0,-1,0),new m(0,1,0),new m(-1,0,0),new m(1,0,0);const rn=new Ls(0,0,0,"YXZ"),on=new m,xr={type:"change"},Sr={type:"lock"},Mr={type:"unlock"},ae=Math.PI/2;class br extends Gs{constructor(A,n=null){super(A,n),this.isLocked=!1,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.pointerSpeed=1,this._onMouseMove=kr.bind(this),this._onPointerlockChange=Fr.bind(this),this._onPointerlockError=Rr.bind(this),this.domElement!==null&&this.connect()}connect(){this.domElement.ownerDocument.addEventListener("mousemove",this._onMouseMove),this.domElement.ownerDocument.addEventListener("pointerlockchange",this._onPointerlockChange),this.domElement.ownerDocument.addEventListener("pointerlockerror",this._onPointerlockError)}disconnect(){this.domElement.ownerDocument.removeEventListener("mousemove",this._onMouseMove),this.domElement.ownerDocument.removeEventListener("pointerlockchange",this._onPointerlockChange),this.domElement.ownerDocument.removeEventListener("pointerlockerror",this._onPointerlockError)}dispose(){this.disconnect()}getObject(){return console.warn("THREE.PointerLockControls: getObject() has been deprecated. Use controls.object instead."),this.object}getDirection(A){return A.set(0,0,-1).applyQuaternion(this.object.quaternion)}moveForward(A){if(this.enabled===!1)return;const n=this.object;on.setFromMatrixColumn(n.matrix,0),on.crossVectors(n.up,on),n.position.addScaledVector(on,A)}moveRight(A){if(this.enabled===!1)return;const n=this.object;on.setFromMatrixColumn(n.matrix,0),n.position.addScaledVector(on,A)}lock(){this.domElement.requestPointerLock()}unlock(){this.domElement.ownerDocument.exitPointerLock()}}function kr(s){if(this.enabled===!1||this.isLocked===!1)return;const A=this.object;rn.setFromQuaternion(A.quaternion),rn.y-=s.movementX*.002*this.pointerSpeed,rn.x-=s.movementY*.002*this.pointerSpeed,rn.x=Math.max(ae-this.maxPolarAngle,Math.min(ae-this.minPolarAngle,rn.x)),A.quaternion.setFromEuler(rn),this.dispatchEvent(xr)}function Fr(){this.domElement.ownerDocument.pointerLockElement===this.domElement?(this.dispatchEvent(Sr),this.isLocked=!0):(this.dispatchEvent(Mr),this.isLocked=!1)}function Rr(){console.error("THREE.PointerLockControls: Unable to use Pointer Lock API")}function re(s,A){if(A===Us)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),s;if(A===Et||A===fe){let n=s.getIndex();if(n===null){const a=[],r=s.getAttribute("position");if(r!==void 0){for(let o=0;o<r.count;o++)a.push(o);s.setIndex(a),n=s.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),s}const t=n.count-2,e=[];if(A===Et)for(let a=1;a<=t;a++)e.push(n.getX(0)),e.push(n.getX(a)),e.push(n.getX(a+1));else for(let a=0;a<t;a++)a%2===0?(e.push(n.getX(a)),e.push(n.getX(a+1)),e.push(n.getX(a+2))):(e.push(n.getX(a+2)),e.push(n.getX(a+1)),e.push(n.getX(a)));e.length/3!==t&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=s.clone();return i.setIndex(e),i.clearGroups(),i}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",A),s}class Nr extends _s{constructor(A){super(A),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(n){return new _r(n)}),this.register(function(n){return new Tr(n)}),this.register(function(n){return new jr(n)}),this.register(function(n){return new Vr(n)}),this.register(function(n){return new Xr(n)}),this.register(function(n){return new Jr(n)}),this.register(function(n){return new Hr(n)}),this.register(function(n){return new qr(n)}),this.register(function(n){return new zr(n)}),this.register(function(n){return new Ur(n)}),this.register(function(n){return new Kr(n)}),this.register(function(n){return new Yr(n)}),this.register(function(n){return new Or(n)}),this.register(function(n){return new Pr(n)}),this.register(function(n){return new Gr(n)}),this.register(function(n){return new Zr(n)}),this.register(function(n){return new Wr(n)})}load(A,n,t,e){const i=this;let a;if(this.resourcePath!=="")a=this.resourcePath;else if(this.path!==""){const g=wn.extractUrlBase(A);a=wn.resolveURL(g,this.path)}else a=wn.extractUrlBase(A);this.manager.itemStart(A);const r=function(g){e?e(g):console.error(g),i.manager.itemError(A),i.manager.itemEnd(A)},o=new ye(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(A,function(g){try{i.parse(g,a,function(c){n(c),i.manager.itemEnd(A)},r)}catch(c){r(c)}},t,r)}setDRACOLoader(A){return this.dracoLoader=A,this}setKTX2Loader(A){return this.ktx2Loader=A,this}setMeshoptDecoder(A){return this.meshoptDecoder=A,this}register(A){return this.pluginCallbacks.indexOf(A)===-1&&this.pluginCallbacks.push(A),this}unregister(A){return this.pluginCallbacks.indexOf(A)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(A),1),this}parse(A,n,t,e){let i;const a={},r={},o=new TextDecoder;if(typeof A=="string")i=JSON.parse(A);else if(A instanceof ArrayBuffer)if(o.decode(new Uint8Array(A,0,4))===Bs){try{a[R.KHR_BINARY_GLTF]=new $r(A)}catch(I){e&&e(I);return}i=JSON.parse(a[R.KHR_BINARY_GLTF].content)}else i=JSON.parse(o.decode(A));else i=A;if(i.asset===void 0||i.asset.version[0]<2){e&&e(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const g=new Bo(i,{path:n||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});g.fileLoader.setRequestHeader(this.requestHeader);for(let c=0;c<this.pluginCallbacks.length;c++){const I=this.pluginCallbacks[c](g);I.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),r[I.name]=I,a[I.name]=!0}if(i.extensionsUsed)for(let c=0;c<i.extensionsUsed.length;++c){const I=i.extensionsUsed[c],B=i.extensionsRequired||[];switch(I){case R.KHR_MATERIALS_UNLIT:a[I]=new Lr;break;case R.KHR_DRACO_MESH_COMPRESSION:a[I]=new Ao(i,this.dracoLoader);break;case R.KHR_TEXTURE_TRANSFORM:a[I]=new no;break;case R.KHR_MESH_QUANTIZATION:a[I]=new to;break;default:B.indexOf(I)>=0&&r[I]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+I+'".')}}g.setExtensions(a),g.setPlugins(r),g.parse(t,e)}parseAsync(A,n){const t=this;return new Promise(function(e,i){t.parse(A,n,e,i)})}}function vr(){let s={};return{get:function(A){return s[A]},add:function(A,n){s[A]=n},remove:function(A){delete s[A]},removeAll:function(){s={}}}}const R={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Gr{constructor(A){this.parser=A,this.name=R.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const A=this.parser,n=this.parser.json.nodes||[];for(let t=0,e=n.length;t<e;t++){const i=n[t];i.extensions&&i.extensions[this.name]&&i.extensions[this.name].light!==void 0&&A._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(A){const n=this.parser,t="light:"+A;let e=n.cache.get(t);if(e)return e;const i=n.json,o=((i.extensions&&i.extensions[this.name]||{}).lights||[])[A];let g;const c=new gA(16777215);o.color!==void 0&&c.setRGB(o.color[0],o.color[1],o.color[2],GA);const I=o.range!==void 0?o.range:0;switch(o.type){case"directional":g=new we(c),g.target.position.set(0,0,-1),g.add(g.target);break;case"point":g=new me(c),g.distance=I;break;case"spot":g=new Ts(c),g.distance=I,o.spot=o.spot||{},o.spot.innerConeAngle=o.spot.innerConeAngle!==void 0?o.spot.innerConeAngle:0,o.spot.outerConeAngle=o.spot.outerConeAngle!==void 0?o.spot.outerConeAngle:Math.PI/4,g.angle=o.spot.outerConeAngle,g.penumbra=1-o.spot.innerConeAngle/o.spot.outerConeAngle,g.target.position.set(0,0,-1),g.add(g.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+o.type)}return g.position.set(0,0,0),RA(g,o),o.intensity!==void 0&&(g.intensity=o.intensity),g.name=n.createUniqueName(o.name||"light_"+A),e=Promise.resolve(g),n.cache.add(t,e),e}getDependency(A,n){if(A==="light")return this._loadLight(n)}createNodeAttachment(A){const n=this,t=this.parser,i=t.json.nodes[A],r=(i.extensions&&i.extensions[this.name]||{}).light;return r===void 0?null:this._loadLight(r).then(function(o){return t._getNodeRef(n.cache,r,o)})}}class Lr{constructor(){this.name=R.KHR_MATERIALS_UNLIT}getMaterialType(){return dn}extendParams(A,n,t){const e=[];A.color=new gA(1,1,1),A.opacity=1;const i=n.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const a=i.baseColorFactor;A.color.setRGB(a[0],a[1],a[2],GA),A.opacity=a[3]}i.baseColorTexture!==void 0&&e.push(t.assignTexture(A,"map",i.baseColorTexture,qA))}return Promise.all(e)}}class Ur{constructor(A){this.parser=A,this.name=R.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(A,n){const e=this.parser.json.materials[A];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const i=e.extensions[this.name].emissiveStrength;return i!==void 0&&(n.emissiveIntensity=i),Promise.resolve()}}class _r{constructor(A){this.parser=A,this.name=R.KHR_MATERIALS_CLEARCOAT}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:MA}extendMaterialParams(A,n){const t=this.parser,e=t.json.materials[A];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const i=[],a=e.extensions[this.name];if(a.clearcoatFactor!==void 0&&(n.clearcoat=a.clearcoatFactor),a.clearcoatTexture!==void 0&&i.push(t.assignTexture(n,"clearcoatMap",a.clearcoatTexture)),a.clearcoatRoughnessFactor!==void 0&&(n.clearcoatRoughness=a.clearcoatRoughnessFactor),a.clearcoatRoughnessTexture!==void 0&&i.push(t.assignTexture(n,"clearcoatRoughnessMap",a.clearcoatRoughnessTexture)),a.clearcoatNormalTexture!==void 0&&(i.push(t.assignTexture(n,"clearcoatNormalMap",a.clearcoatNormalTexture)),a.clearcoatNormalTexture.scale!==void 0)){const r=a.clearcoatNormalTexture.scale;n.clearcoatNormalScale=new cn(r,r)}return Promise.all(i)}}class Tr{constructor(A){this.parser=A,this.name=R.KHR_MATERIALS_DISPERSION}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:MA}extendMaterialParams(A,n){const e=this.parser.json.materials[A];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const i=e.extensions[this.name];return n.dispersion=i.dispersion!==void 0?i.dispersion:0,Promise.resolve()}}class Yr{constructor(A){this.parser=A,this.name=R.KHR_MATERIALS_IRIDESCENCE}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:MA}extendMaterialParams(A,n){const t=this.parser,e=t.json.materials[A];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const i=[],a=e.extensions[this.name];return a.iridescenceFactor!==void 0&&(n.iridescence=a.iridescenceFactor),a.iridescenceTexture!==void 0&&i.push(t.assignTexture(n,"iridescenceMap",a.iridescenceTexture)),a.iridescenceIor!==void 0&&(n.iridescenceIOR=a.iridescenceIor),n.iridescenceThicknessRange===void 0&&(n.iridescenceThicknessRange=[100,400]),a.iridescenceThicknessMinimum!==void 0&&(n.iridescenceThicknessRange[0]=a.iridescenceThicknessMinimum),a.iridescenceThicknessMaximum!==void 0&&(n.iridescenceThicknessRange[1]=a.iridescenceThicknessMaximum),a.iridescenceThicknessTexture!==void 0&&i.push(t.assignTexture(n,"iridescenceThicknessMap",a.iridescenceThicknessTexture)),Promise.all(i)}}class Jr{constructor(A){this.parser=A,this.name=R.KHR_MATERIALS_SHEEN}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:MA}extendMaterialParams(A,n){const t=this.parser,e=t.json.materials[A];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const i=[];n.sheenColor=new gA(0,0,0),n.sheenRoughness=0,n.sheen=1;const a=e.extensions[this.name];if(a.sheenColorFactor!==void 0){const r=a.sheenColorFactor;n.sheenColor.setRGB(r[0],r[1],r[2],GA)}return a.sheenRoughnessFactor!==void 0&&(n.sheenRoughness=a.sheenRoughnessFactor),a.sheenColorTexture!==void 0&&i.push(t.assignTexture(n,"sheenColorMap",a.sheenColorTexture,qA)),a.sheenRoughnessTexture!==void 0&&i.push(t.assignTexture(n,"sheenRoughnessMap",a.sheenRoughnessTexture)),Promise.all(i)}}class Hr{constructor(A){this.parser=A,this.name=R.KHR_MATERIALS_TRANSMISSION}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:MA}extendMaterialParams(A,n){const t=this.parser,e=t.json.materials[A];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const i=[],a=e.extensions[this.name];return a.transmissionFactor!==void 0&&(n.transmission=a.transmissionFactor),a.transmissionTexture!==void 0&&i.push(t.assignTexture(n,"transmissionMap",a.transmissionTexture)),Promise.all(i)}}class qr{constructor(A){this.parser=A,this.name=R.KHR_MATERIALS_VOLUME}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:MA}extendMaterialParams(A,n){const t=this.parser,e=t.json.materials[A];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const i=[],a=e.extensions[this.name];n.thickness=a.thicknessFactor!==void 0?a.thicknessFactor:0,a.thicknessTexture!==void 0&&i.push(t.assignTexture(n,"thicknessMap",a.thicknessTexture)),n.attenuationDistance=a.attenuationDistance||1/0;const r=a.attenuationColor||[1,1,1];return n.attenuationColor=new gA().setRGB(r[0],r[1],r[2],GA),Promise.all(i)}}class zr{constructor(A){this.parser=A,this.name=R.KHR_MATERIALS_IOR}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:MA}extendMaterialParams(A,n){const e=this.parser.json.materials[A];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const i=e.extensions[this.name];return n.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}}class Kr{constructor(A){this.parser=A,this.name=R.KHR_MATERIALS_SPECULAR}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:MA}extendMaterialParams(A,n){const t=this.parser,e=t.json.materials[A];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const i=[],a=e.extensions[this.name];n.specularIntensity=a.specularFactor!==void 0?a.specularFactor:1,a.specularTexture!==void 0&&i.push(t.assignTexture(n,"specularIntensityMap",a.specularTexture));const r=a.specularColorFactor||[1,1,1];return n.specularColor=new gA().setRGB(r[0],r[1],r[2],GA),a.specularColorTexture!==void 0&&i.push(t.assignTexture(n,"specularColorMap",a.specularColorTexture,qA)),Promise.all(i)}}class Pr{constructor(A){this.parser=A,this.name=R.EXT_MATERIALS_BUMP}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:MA}extendMaterialParams(A,n){const t=this.parser,e=t.json.materials[A];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const i=[],a=e.extensions[this.name];return n.bumpScale=a.bumpFactor!==void 0?a.bumpFactor:1,a.bumpTexture!==void 0&&i.push(t.assignTexture(n,"bumpMap",a.bumpTexture)),Promise.all(i)}}class Or{constructor(A){this.parser=A,this.name=R.KHR_MATERIALS_ANISOTROPY}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:MA}extendMaterialParams(A,n){const t=this.parser,e=t.json.materials[A];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const i=[],a=e.extensions[this.name];return a.anisotropyStrength!==void 0&&(n.anisotropy=a.anisotropyStrength),a.anisotropyRotation!==void 0&&(n.anisotropyRotation=a.anisotropyRotation),a.anisotropyTexture!==void 0&&i.push(t.assignTexture(n,"anisotropyMap",a.anisotropyTexture)),Promise.all(i)}}class jr{constructor(A){this.parser=A,this.name=R.KHR_TEXTURE_BASISU}loadTexture(A){const n=this.parser,t=n.json,e=t.textures[A];if(!e.extensions||!e.extensions[this.name])return null;const i=e.extensions[this.name],a=n.options.ktx2Loader;if(!a){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return n.loadTextureImage(A,i.source,a)}}class Vr{constructor(A){this.parser=A,this.name=R.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(A){const n=this.name,t=this.parser,e=t.json,i=e.textures[A];if(!i.extensions||!i.extensions[n])return null;const a=i.extensions[n],r=e.images[a.source];let o=t.textureLoader;if(r.uri){const g=t.options.manager.getHandler(r.uri);g!==null&&(o=g)}return this.detectSupport().then(function(g){if(g)return t.loadTextureImage(A,a.source,o);if(e.extensionsRequired&&e.extensionsRequired.indexOf(n)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return t.loadTexture(A)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(A){const n=new Image;n.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",n.onload=n.onerror=function(){A(n.height===1)}})),this.isSupported}}class Xr{constructor(A){this.parser=A,this.name=R.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(A){const n=this.name,t=this.parser,e=t.json,i=e.textures[A];if(!i.extensions||!i.extensions[n])return null;const a=i.extensions[n],r=e.images[a.source];let o=t.textureLoader;if(r.uri){const g=t.options.manager.getHandler(r.uri);g!==null&&(o=g)}return this.detectSupport().then(function(g){if(g)return t.loadTextureImage(A,a.source,o);if(e.extensionsRequired&&e.extensionsRequired.indexOf(n)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return t.loadTexture(A)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(A){const n=new Image;n.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",n.onload=n.onerror=function(){A(n.height===1)}})),this.isSupported}}class Zr{constructor(A){this.name=R.EXT_MESHOPT_COMPRESSION,this.parser=A}loadBufferView(A){const n=this.parser.json,t=n.bufferViews[A];if(t.extensions&&t.extensions[this.name]){const e=t.extensions[this.name],i=this.parser.getDependency("buffer",e.buffer),a=this.parser.options.meshoptDecoder;if(!a||!a.supported){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return i.then(function(r){const o=e.byteOffset||0,g=e.byteLength||0,c=e.count,I=e.byteStride,B=new Uint8Array(r,o,g);return a.decodeGltfBufferAsync?a.decodeGltfBufferAsync(c,I,B,e.mode,e.filter).then(function(Q){return Q.buffer}):a.ready.then(function(){const Q=new ArrayBuffer(c*I);return a.decodeGltfBuffer(new Uint8Array(Q),c,I,B,e.mode,e.filter),Q})})}else return null}}class Wr{constructor(A){this.name=R.EXT_MESH_GPU_INSTANCING,this.parser=A}createNodeMesh(A){const n=this.parser.json,t=n.nodes[A];if(!t.extensions||!t.extensions[this.name]||t.mesh===void 0)return null;const e=n.meshes[t.mesh];for(const g of e.primitives)if(g.mode!==uA.TRIANGLES&&g.mode!==uA.TRIANGLE_STRIP&&g.mode!==uA.TRIANGLE_FAN&&g.mode!==void 0)return null;const a=t.extensions[this.name].attributes,r=[],o={};for(const g in a)r.push(this.parser.getDependency("accessor",a[g]).then(c=>(o[g]=c,o[g])));return r.length<1?null:(r.push(this.parser.createNodeMesh(A)),Promise.all(r).then(g=>{const c=g.pop(),I=c.isGroup?c.children:[c],B=g[0].count,Q=[];for(const l of I){const C=new fA,E=new m,h=new IA,f=new m(1,1,1),u=new Ys(l.geometry,l.material,B);for(let y=0;y<B;y++)o.TRANSLATION&&E.fromBufferAttribute(o.TRANSLATION,y),o.ROTATION&&h.fromBufferAttribute(o.ROTATION,y),o.SCALE&&f.fromBufferAttribute(o.SCALE,y),u.setMatrixAt(y,C.compose(E,h,f));for(const y in o)if(y==="_COLOR_0"){const w=o[y];u.instanceColor=new he(w.array,w.itemSize,w.normalized)}else y!=="TRANSLATION"&&y!=="ROTATION"&&y!=="SCALE"&&l.geometry.setAttribute(y,o[y]);Rn.prototype.copy.call(u,l),this.parser.assignFinalMaterial(u),Q.push(u)}return c.isGroup?(c.clear(),c.add(...Q),c):Q[0]}))}}const Bs="glTF",un=12,oe={JSON:1313821514,BIN:5130562};class $r{constructor(A){this.name=R.KHR_BINARY_GLTF,this.content=null,this.body=null;const n=new DataView(A,0,un),t=new TextDecoder;if(this.header={magic:t.decode(new Uint8Array(A.slice(0,4))),version:n.getUint32(4,!0),length:n.getUint32(8,!0)},this.header.magic!==Bs)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const e=this.header.length-un,i=new DataView(A,un);let a=0;for(;a<e;){const r=i.getUint32(a,!0);a+=4;const o=i.getUint32(a,!0);if(a+=4,o===oe.JSON){const g=new Uint8Array(A,un+a,r);this.content=t.decode(g)}else if(o===oe.BIN){const g=un+a;this.body=A.slice(g,g+r)}a+=r}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Ao{constructor(A,n){if(!n)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=R.KHR_DRACO_MESH_COMPRESSION,this.json=A,this.dracoLoader=n,this.dracoLoader.preload()}decodePrimitive(A,n){const t=this.json,e=this.dracoLoader,i=A.extensions[this.name].bufferView,a=A.extensions[this.name].attributes,r={},o={},g={};for(const c in a){const I=St[c]||c.toLowerCase();r[I]=a[c]}for(const c in A.attributes){const I=St[c]||c.toLowerCase();if(a[c]!==void 0){const B=t.accessors[A.attributes[c]],Q=Qn[B.componentType];g[I]=Q.name,o[I]=B.normalized===!0}}return n.getDependency("bufferView",i).then(function(c){return new Promise(function(I,B){e.decodeDracoFile(c,function(Q){for(const l in Q.attributes){const C=Q.attributes[l],E=o[l];E!==void 0&&(C.normalized=E)}I(Q)},r,g,GA,B)})})}}class no{constructor(){this.name=R.KHR_TEXTURE_TRANSFORM}extendTexture(A,n){return(n.texCoord===void 0||n.texCoord===A.channel)&&n.offset===void 0&&n.rotation===void 0&&n.scale===void 0||(A=A.clone(),n.texCoord!==void 0&&(A.channel=n.texCoord),n.offset!==void 0&&A.offset.fromArray(n.offset),n.rotation!==void 0&&(A.rotation=n.rotation),n.scale!==void 0&&A.repeat.fromArray(n.scale),A.needsUpdate=!0),A}}class to{constructor(){this.name=R.KHR_MESH_QUANTIZATION}}class Qs extends Ii{constructor(A,n,t,e){super(A,n,t,e)}copySampleValue_(A){const n=this.resultBuffer,t=this.sampleValues,e=this.valueSize,i=A*e*3+e;for(let a=0;a!==e;a++)n[a]=t[i+a];return n}interpolate_(A,n,t,e){const i=this.resultBuffer,a=this.sampleValues,r=this.valueSize,o=r*2,g=r*3,c=e-n,I=(t-n)/c,B=I*I,Q=B*I,l=A*g,C=l-g,E=-2*Q+3*B,h=Q-B,f=1-E,u=h-B+I;for(let y=0;y!==r;y++){const w=a[C+y+r],S=a[C+y+o]*c,M=a[l+y+r],K=a[l+y]*c;i[y]=f*w+u*S+E*M+h*K}return i}}const eo=new IA;class so extends Qs{interpolate_(A,n,t,e){const i=super.interpolate_(A,n,t,e);return eo.fromArray(i).normalize().toArray(i),i}}const uA={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Qn={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},ge={9728:ln,9729:Ct,9984:ti,9985:ei,9986:si,9987:xe},Ie={33071:ii,33648:ai,10497:ht},It={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},St={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},YA={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},io={CUBICSPLINE:void 0,LINEAR:Me,STEP:ri},ct={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function ao(s){return s.DefaultMaterial===void 0&&(s.DefaultMaterial=new Cn({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:be})),s.DefaultMaterial}function KA(s,A,n){for(const t in n.extensions)s[t]===void 0&&(A.userData.gltfExtensions=A.userData.gltfExtensions||{},A.userData.gltfExtensions[t]=n.extensions[t])}function RA(s,A){A.extras!==void 0&&(typeof A.extras=="object"?Object.assign(s.userData,A.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+A.extras))}function ro(s,A,n){let t=!1,e=!1,i=!1;for(let g=0,c=A.length;g<c;g++){const I=A[g];if(I.POSITION!==void 0&&(t=!0),I.NORMAL!==void 0&&(e=!0),I.COLOR_0!==void 0&&(i=!0),t&&e&&i)break}if(!t&&!e&&!i)return Promise.resolve(s);const a=[],r=[],o=[];for(let g=0,c=A.length;g<c;g++){const I=A[g];if(t){const B=I.POSITION!==void 0?n.getDependency("accessor",I.POSITION):s.attributes.position;a.push(B)}if(e){const B=I.NORMAL!==void 0?n.getDependency("accessor",I.NORMAL):s.attributes.normal;r.push(B)}if(i){const B=I.COLOR_0!==void 0?n.getDependency("accessor",I.COLOR_0):s.attributes.color;o.push(B)}}return Promise.all([Promise.all(a),Promise.all(r),Promise.all(o)]).then(function(g){const c=g[0],I=g[1],B=g[2];return t&&(s.morphAttributes.position=c),e&&(s.morphAttributes.normal=I),i&&(s.morphAttributes.color=B),s.morphTargetsRelative=!0,s})}function oo(s,A){if(s.updateMorphTargets(),A.weights!==void 0)for(let n=0,t=A.weights.length;n<t;n++)s.morphTargetInfluences[n]=A.weights[n];if(A.extras&&Array.isArray(A.extras.targetNames)){const n=A.extras.targetNames;if(s.morphTargetInfluences.length===n.length){s.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++)s.morphTargetDictionary[n[t]]=t}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function go(s){let A;const n=s.extensions&&s.extensions[R.KHR_DRACO_MESH_COMPRESSION];if(n?A="draco:"+n.bufferView+":"+n.indices+":"+Bt(n.attributes):A=s.indices+":"+Bt(s.attributes)+":"+s.mode,s.targets!==void 0)for(let t=0,e=s.targets.length;t<e;t++)A+=":"+Bt(s.targets[t]);return A}function Bt(s){let A="";const n=Object.keys(s).sort();for(let t=0,e=n.length;t<e;t++)A+=n[t]+":"+s[n[t]]+";";return A}function Mt(s){switch(s){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function Io(s){return s.search(/\.jpe?g($|\?)/i)>0||s.search(/^data\:image\/jpeg/)===0?"image/jpeg":s.search(/\.webp($|\?)/i)>0||s.search(/^data\:image\/webp/)===0?"image/webp":s.search(/\.ktx2($|\?)/i)>0||s.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"}const co=new fA;class Bo{constructor(A={},n={}){this.json=A,this.extensions={},this.plugins={},this.options=n,this.cache=new vr,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let t=!1,e=-1,i=!1,a=-1;if(typeof navigator<"u"){const r=navigator.userAgent;t=/^((?!chrome|android).)*safari/i.test(r)===!0;const o=r.match(/Version\/(\d+)/);e=t&&o?parseInt(o[1],10):-1,i=r.indexOf("Firefox")>-1,a=i?r.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||t&&e<17||i&&a<98?this.textureLoader=new De(this.options.manager):this.textureLoader=new Js(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new ye(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(A){this.extensions=A}setPlugins(A){this.plugins=A}parse(A,n){const t=this,e=this.json,i=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(a){return a._markDefs&&a._markDefs()}),Promise.all(this._invokeAll(function(a){return a.beforeRoot&&a.beforeRoot()})).then(function(){return Promise.all([t.getDependencies("scene"),t.getDependencies("animation"),t.getDependencies("camera")])}).then(function(a){const r={scene:a[0][e.scene||0],scenes:a[0],animations:a[1],cameras:a[2],asset:e.asset,parser:t,userData:{}};return KA(i,r,e),RA(r,e),Promise.all(t._invokeAll(function(o){return o.afterRoot&&o.afterRoot(r)})).then(function(){for(const o of r.scenes)o.updateMatrixWorld();A(r)})}).catch(n)}_markDefs(){const A=this.json.nodes||[],n=this.json.skins||[],t=this.json.meshes||[];for(let e=0,i=n.length;e<i;e++){const a=n[e].joints;for(let r=0,o=a.length;r<o;r++)A[a[r]].isBone=!0}for(let e=0,i=A.length;e<i;e++){const a=A[e];a.mesh!==void 0&&(this._addNodeRef(this.meshCache,a.mesh),a.skin!==void 0&&(t[a.mesh].isSkinnedMesh=!0)),a.camera!==void 0&&this._addNodeRef(this.cameraCache,a.camera)}}_addNodeRef(A,n){n!==void 0&&(A.refs[n]===void 0&&(A.refs[n]=A.uses[n]=0),A.refs[n]++)}_getNodeRef(A,n,t){if(A.refs[n]<=1)return t;const e=t.clone(),i=(a,r)=>{const o=this.associations.get(a);o!=null&&this.associations.set(r,o);for(const[g,c]of a.children.entries())i(c,r.children[g])};return i(t,e),e.name+="_instance_"+A.uses[n]++,e}_invokeOne(A){const n=Object.values(this.plugins);n.push(this);for(let t=0;t<n.length;t++){const e=A(n[t]);if(e)return e}return null}_invokeAll(A){const n=Object.values(this.plugins);n.unshift(this);const t=[];for(let e=0;e<n.length;e++){const i=A(n[e]);i&&t.push(i)}return t}getDependency(A,n){const t=A+":"+n;let e=this.cache.get(t);if(!e){switch(A){case"scene":e=this.loadScene(n);break;case"node":e=this._invokeOne(function(i){return i.loadNode&&i.loadNode(n)});break;case"mesh":e=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(n)});break;case"accessor":e=this.loadAccessor(n);break;case"bufferView":e=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(n)});break;case"buffer":e=this.loadBuffer(n);break;case"material":e=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(n)});break;case"texture":e=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(n)});break;case"skin":e=this.loadSkin(n);break;case"animation":e=this._invokeOne(function(i){return i.loadAnimation&&i.loadAnimation(n)});break;case"camera":e=this.loadCamera(n);break;default:if(e=this._invokeOne(function(i){return i!=this&&i.getDependency&&i.getDependency(A,n)}),!e)throw new Error("Unknown type: "+A);break}this.cache.add(t,e)}return e}getDependencies(A){let n=this.cache.get(A);if(!n){const t=this,e=this.json[A+(A==="mesh"?"es":"s")]||[];n=Promise.all(e.map(function(i,a){return t.getDependency(A,a)})),this.cache.add(A,n)}return n}loadBuffer(A){const n=this.json.buffers[A],t=this.fileLoader;if(n.type&&n.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+n.type+" buffer type is not supported.");if(n.uri===void 0&&A===0)return Promise.resolve(this.extensions[R.KHR_BINARY_GLTF].body);const e=this.options;return new Promise(function(i,a){t.load(wn.resolveURL(n.uri,e.path),i,void 0,function(){a(new Error('THREE.GLTFLoader: Failed to load buffer "'+n.uri+'".'))})})}loadBufferView(A){const n=this.json.bufferViews[A];return this.getDependency("buffer",n.buffer).then(function(t){const e=n.byteLength||0,i=n.byteOffset||0;return t.slice(i,i+e)})}loadAccessor(A){const n=this,t=this.json,e=this.json.accessors[A];if(e.bufferView===void 0&&e.sparse===void 0){const a=It[e.type],r=Qn[e.componentType],o=e.normalized===!0,g=new r(e.count*a);return Promise.resolve(new mn(g,a,o))}const i=[];return e.bufferView!==void 0?i.push(this.getDependency("bufferView",e.bufferView)):i.push(null),e.sparse!==void 0&&(i.push(this.getDependency("bufferView",e.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",e.sparse.values.bufferView))),Promise.all(i).then(function(a){const r=a[0],o=It[e.type],g=Qn[e.componentType],c=g.BYTES_PER_ELEMENT,I=c*o,B=e.byteOffset||0,Q=e.bufferView!==void 0?t.bufferViews[e.bufferView].byteStride:void 0,l=e.normalized===!0;let C,E;if(Q&&Q!==I){const h=Math.floor(B/Q),f="InterleavedBuffer:"+e.bufferView+":"+e.componentType+":"+h+":"+e.count;let u=n.cache.get(f);u||(C=new g(r,h*Q,e.count*Q/c),u=new Hs(C,Q/c),n.cache.add(f,u)),E=new oi(u,o,B%Q/c,l)}else r===null?C=new g(e.count*o):C=new g(r,B,e.count*o),E=new mn(C,o,l);if(e.sparse!==void 0){const h=It.SCALAR,f=Qn[e.sparse.indices.componentType],u=e.sparse.indices.byteOffset||0,y=e.sparse.values.byteOffset||0,w=new f(a[1],u,e.sparse.count*h),S=new g(a[2],y,e.sparse.count*o);r!==null&&(E=new mn(E.array.slice(),E.itemSize,E.normalized)),E.normalized=!1;for(let M=0,K=w.length;M<K;M++){const L=w[M];if(E.setX(L,S[M*o]),o>=2&&E.setY(L,S[M*o+1]),o>=3&&E.setZ(L,S[M*o+2]),o>=4&&E.setW(L,S[M*o+3]),o>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}E.normalized=l}return E})}loadTexture(A){const n=this.json,t=this.options,i=n.textures[A].source,a=n.images[i];let r=this.textureLoader;if(a.uri){const o=t.manager.getHandler(a.uri);o!==null&&(r=o)}return this.loadTextureImage(A,i,r)}loadTextureImage(A,n,t){const e=this,i=this.json,a=i.textures[A],r=i.images[n],o=(r.uri||r.bufferView)+":"+a.sampler;if(this.textureCache[o])return this.textureCache[o];const g=this.loadImageSource(n,t).then(function(c){c.flipY=!1,c.name=a.name||r.name||"",c.name===""&&typeof r.uri=="string"&&r.uri.startsWith("data:image/")===!1&&(c.name=r.uri);const B=(i.samplers||{})[a.sampler]||{};return c.magFilter=ge[B.magFilter]||Ct,c.minFilter=ge[B.minFilter]||xe,c.wrapS=Ie[B.wrapS]||ht,c.wrapT=Ie[B.wrapT]||ht,c.generateMipmaps=!c.isCompressedTexture&&c.minFilter!==ln&&c.minFilter!==Ct,e.associations.set(c,{textures:A}),c}).catch(function(){return null});return this.textureCache[o]=g,g}loadImageSource(A,n){const t=this,e=this.json,i=this.options;if(this.sourceCache[A]!==void 0)return this.sourceCache[A].then(I=>I.clone());const a=e.images[A],r=self.URL||self.webkitURL;let o=a.uri||"",g=!1;if(a.bufferView!==void 0)o=t.getDependency("bufferView",a.bufferView).then(function(I){g=!0;const B=new Blob([I],{type:a.mimeType});return o=r.createObjectURL(B),o});else if(a.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+A+" is missing URI and bufferView");const c=Promise.resolve(o).then(function(I){return new Promise(function(B,Q){let l=B;n.isImageBitmapLoader===!0&&(l=function(C){const E=new lt(C);E.needsUpdate=!0,B(E)}),n.load(wn.resolveURL(I,i.path),l,void 0,Q)})}).then(function(I){return g===!0&&r.revokeObjectURL(o),RA(I,a),I.userData.mimeType=a.mimeType||Io(a.uri),I}).catch(function(I){throw console.error("THREE.GLTFLoader: Couldn't load texture",o),I});return this.sourceCache[A]=c,c}assignTexture(A,n,t,e){const i=this;return this.getDependency("texture",t.index).then(function(a){if(!a)return null;if(t.texCoord!==void 0&&t.texCoord>0&&(a=a.clone(),a.channel=t.texCoord),i.extensions[R.KHR_TEXTURE_TRANSFORM]){const r=t.extensions!==void 0?t.extensions[R.KHR_TEXTURE_TRANSFORM]:void 0;if(r){const o=i.associations.get(a);a=i.extensions[R.KHR_TEXTURE_TRANSFORM].extendTexture(a,r),i.associations.set(a,o)}}return e!==void 0&&(a.colorSpace=e),A[n]=a,a})}assignFinalMaterial(A){const n=A.geometry;let t=A.material;const e=n.attributes.tangent===void 0,i=n.attributes.color!==void 0,a=n.attributes.normal===void 0;if(A.isPoints){const r="PointsMaterial:"+t.uuid;let o=this.cache.get(r);o||(o=new qs,$n.prototype.copy.call(o,t),o.color.copy(t.color),o.map=t.map,o.sizeAttenuation=!1,this.cache.add(r,o)),t=o}else if(A.isLine){const r="LineBasicMaterial:"+t.uuid;let o=this.cache.get(r);o||(o=new zs,$n.prototype.copy.call(o,t),o.color.copy(t.color),o.map=t.map,this.cache.add(r,o)),t=o}if(e||i||a){let r="ClonedMaterial:"+t.uuid+":";e&&(r+="derivative-tangents:"),i&&(r+="vertex-colors:"),a&&(r+="flat-shading:");let o=this.cache.get(r);o||(o=t.clone(),i&&(o.vertexColors=!0),a&&(o.flatShading=!0),e&&(o.normalScale&&(o.normalScale.y*=-1),o.clearcoatNormalScale&&(o.clearcoatNormalScale.y*=-1)),this.cache.add(r,o),this.associations.set(o,this.associations.get(t))),t=o}A.material=t}getMaterialType(){return Cn}loadMaterial(A){const n=this,t=this.json,e=this.extensions,i=t.materials[A];let a;const r={},o=i.extensions||{},g=[];if(o[R.KHR_MATERIALS_UNLIT]){const I=e[R.KHR_MATERIALS_UNLIT];a=I.getMaterialType(),g.push(I.extendParams(r,i,n))}else{const I=i.pbrMetallicRoughness||{};if(r.color=new gA(1,1,1),r.opacity=1,Array.isArray(I.baseColorFactor)){const B=I.baseColorFactor;r.color.setRGB(B[0],B[1],B[2],GA),r.opacity=B[3]}I.baseColorTexture!==void 0&&g.push(n.assignTexture(r,"map",I.baseColorTexture,qA)),r.metalness=I.metallicFactor!==void 0?I.metallicFactor:1,r.roughness=I.roughnessFactor!==void 0?I.roughnessFactor:1,I.metallicRoughnessTexture!==void 0&&(g.push(n.assignTexture(r,"metalnessMap",I.metallicRoughnessTexture)),g.push(n.assignTexture(r,"roughnessMap",I.metallicRoughnessTexture))),a=this._invokeOne(function(B){return B.getMaterialType&&B.getMaterialType(A)}),g.push(Promise.all(this._invokeAll(function(B){return B.extendMaterialParams&&B.extendMaterialParams(A,r)})))}i.doubleSided===!0&&(r.side=de);const c=i.alphaMode||ct.OPAQUE;if(c===ct.BLEND?(r.transparent=!0,r.depthWrite=!1):(r.transparent=!1,c===ct.MASK&&(r.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)),i.normalTexture!==void 0&&a!==dn&&(g.push(n.assignTexture(r,"normalMap",i.normalTexture)),r.normalScale=new cn(1,1),i.normalTexture.scale!==void 0)){const I=i.normalTexture.scale;r.normalScale.set(I,I)}if(i.occlusionTexture!==void 0&&a!==dn&&(g.push(n.assignTexture(r,"aoMap",i.occlusionTexture)),i.occlusionTexture.strength!==void 0&&(r.aoMapIntensity=i.occlusionTexture.strength)),i.emissiveFactor!==void 0&&a!==dn){const I=i.emissiveFactor;r.emissive=new gA().setRGB(I[0],I[1],I[2],GA)}return i.emissiveTexture!==void 0&&a!==dn&&g.push(n.assignTexture(r,"emissiveMap",i.emissiveTexture,qA)),Promise.all(g).then(function(){const I=new a(r);return i.name&&(I.name=i.name),RA(I,i),n.associations.set(I,{materials:A}),i.extensions&&KA(e,I,i),I})}createUniqueName(A){const n=Ks.sanitizeNodeName(A||"");return n in this.nodeNamesUsed?n+"_"+ ++this.nodeNamesUsed[n]:(this.nodeNamesUsed[n]=0,n)}loadGeometries(A){const n=this,t=this.extensions,e=this.primitiveCache;function i(r){return t[R.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(r,n).then(function(o){return ce(o,r,n)})}const a=[];for(let r=0,o=A.length;r<o;r++){const g=A[r],c=go(g),I=e[c];if(I)a.push(I.promise);else{let B;g.extensions&&g.extensions[R.KHR_DRACO_MESH_COMPRESSION]?B=i(g):B=ce(new Ps,g,n),e[c]={primitive:g,promise:B},a.push(B)}}return Promise.all(a)}loadMesh(A){const n=this,t=this.json,e=this.extensions,i=t.meshes[A],a=i.primitives,r=[];for(let o=0,g=a.length;o<g;o++){const c=a[o].material===void 0?ao(this.cache):this.getDependency("material",a[o].material);r.push(c)}return r.push(n.loadGeometries(a)),Promise.all(r).then(function(o){const g=o.slice(0,o.length-1),c=o[o.length-1],I=[];for(let Q=0,l=c.length;Q<l;Q++){const C=c[Q],E=a[Q];let h;const f=g[Q];if(E.mode===uA.TRIANGLES||E.mode===uA.TRIANGLE_STRIP||E.mode===uA.TRIANGLE_FAN||E.mode===void 0)h=i.isSkinnedMesh===!0?new Os(C,f):new $A(C,f),h.isSkinnedMesh===!0&&h.normalizeSkinWeights(),E.mode===uA.TRIANGLE_STRIP?h.geometry=re(h.geometry,fe):E.mode===uA.TRIANGLE_FAN&&(h.geometry=re(h.geometry,Et));else if(E.mode===uA.LINES)h=new js(C,f);else if(E.mode===uA.LINE_STRIP)h=new Vs(C,f);else if(E.mode===uA.LINE_LOOP)h=new Xs(C,f);else if(E.mode===uA.POINTS)h=new Zs(C,f);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+E.mode);Object.keys(h.geometry.morphAttributes).length>0&&oo(h,i),h.name=n.createUniqueName(i.name||"mesh_"+A),RA(h,i),E.extensions&&KA(e,h,E),n.assignFinalMaterial(h),I.push(h)}for(let Q=0,l=I.length;Q<l;Q++)n.associations.set(I[Q],{meshes:A,primitives:Q});if(I.length===1)return i.extensions&&KA(e,I[0],i),I[0];const B=new At;i.extensions&&KA(e,B,i),n.associations.set(B,{meshes:A});for(let Q=0,l=I.length;Q<l;Q++)B.add(I[Q]);return B})}loadCamera(A){let n;const t=this.json.cameras[A],e=t[t.type];if(!e){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return t.type==="perspective"?n=new Pn(Se.radToDeg(e.yfov),e.aspectRatio||1,e.znear||1,e.zfar||2e6):t.type==="orthographic"&&(n=new Ws(-e.xmag,e.xmag,e.ymag,-e.ymag,e.znear,e.zfar)),t.name&&(n.name=this.createUniqueName(t.name)),RA(n,t),Promise.resolve(n)}loadSkin(A){const n=this.json.skins[A],t=[];for(let e=0,i=n.joints.length;e<i;e++)t.push(this._loadNodeShallow(n.joints[e]));return n.inverseBindMatrices!==void 0?t.push(this.getDependency("accessor",n.inverseBindMatrices)):t.push(null),Promise.all(t).then(function(e){const i=e.pop(),a=e,r=[],o=[];for(let g=0,c=a.length;g<c;g++){const I=a[g];if(I){r.push(I);const B=new fA;i!==null&&B.fromArray(i.array,g*16),o.push(B)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',n.joints[g])}return new $s(r,o)})}loadAnimation(A){const n=this.json,t=this,e=n.animations[A],i=e.name?e.name:"animation_"+A,a=[],r=[],o=[],g=[],c=[];for(let I=0,B=e.channels.length;I<B;I++){const Q=e.channels[I],l=e.samplers[Q.sampler],C=Q.target,E=C.node,h=e.parameters!==void 0?e.parameters[l.input]:l.input,f=e.parameters!==void 0?e.parameters[l.output]:l.output;C.node!==void 0&&(a.push(this.getDependency("node",E)),r.push(this.getDependency("accessor",h)),o.push(this.getDependency("accessor",f)),g.push(l),c.push(C))}return Promise.all([Promise.all(a),Promise.all(r),Promise.all(o),Promise.all(g),Promise.all(c)]).then(function(I){const B=I[0],Q=I[1],l=I[2],C=I[3],E=I[4],h=[];for(let f=0,u=B.length;f<u;f++){const y=B[f],w=Q[f],S=l[f],M=C[f],K=E[f];if(y===void 0)continue;y.updateMatrix&&y.updateMatrix();const L=t._createAnimationTracks(y,w,S,M,K);if(L)for(let P=0;P<L.length;P++)h.push(L[P])}return new Ai(i,void 0,h)})}createNodeMesh(A){const n=this.json,t=this,e=n.nodes[A];return e.mesh===void 0?null:t.getDependency("mesh",e.mesh).then(function(i){const a=t._getNodeRef(t.meshCache,e.mesh,i);return e.weights!==void 0&&a.traverse(function(r){if(r.isMesh)for(let o=0,g=e.weights.length;o<g;o++)r.morphTargetInfluences[o]=e.weights[o]}),a})}loadNode(A){const n=this.json,t=this,e=n.nodes[A],i=t._loadNodeShallow(A),a=[],r=e.children||[];for(let g=0,c=r.length;g<c;g++)a.push(t.getDependency("node",r[g]));const o=e.skin===void 0?Promise.resolve(null):t.getDependency("skin",e.skin);return Promise.all([i,Promise.all(a),o]).then(function(g){const c=g[0],I=g[1],B=g[2];B!==null&&c.traverse(function(Q){Q.isSkinnedMesh&&Q.bind(B,co)});for(let Q=0,l=I.length;Q<l;Q++)c.add(I[Q]);return c})}_loadNodeShallow(A){const n=this.json,t=this.extensions,e=this;if(this.nodeCache[A]!==void 0)return this.nodeCache[A];const i=n.nodes[A],a=i.name?e.createUniqueName(i.name):"",r=[],o=e._invokeOne(function(g){return g.createNodeMesh&&g.createNodeMesh(A)});return o&&r.push(o),i.camera!==void 0&&r.push(e.getDependency("camera",i.camera).then(function(g){return e._getNodeRef(e.cameraCache,i.camera,g)})),e._invokeAll(function(g){return g.createNodeAttachment&&g.createNodeAttachment(A)}).forEach(function(g){r.push(g)}),this.nodeCache[A]=Promise.all(r).then(function(g){let c;if(i.isBone===!0?c=new ni:g.length>1?c=new At:g.length===1?c=g[0]:c=new Rn,c!==g[0])for(let I=0,B=g.length;I<B;I++)c.add(g[I]);if(i.name&&(c.userData.name=i.name,c.name=a),RA(c,i),i.extensions&&KA(t,c,i),i.matrix!==void 0){const I=new fA;I.fromArray(i.matrix),c.applyMatrix4(I)}else i.translation!==void 0&&c.position.fromArray(i.translation),i.rotation!==void 0&&c.quaternion.fromArray(i.rotation),i.scale!==void 0&&c.scale.fromArray(i.scale);return e.associations.has(c)||e.associations.set(c,{}),e.associations.get(c).nodes=A,c}),this.nodeCache[A]}loadScene(A){const n=this.extensions,t=this.json.scenes[A],e=this,i=new At;t.name&&(i.name=e.createUniqueName(t.name)),RA(i,t),t.extensions&&KA(n,i,t);const a=t.nodes||[],r=[];for(let o=0,g=a.length;o<g;o++)r.push(e.getDependency("node",a[o]));return Promise.all(r).then(function(o){for(let c=0,I=o.length;c<I;c++)i.add(o[c]);const g=c=>{const I=new Map;for(const[B,Q]of e.associations)(B instanceof $n||B instanceof lt)&&I.set(B,Q);return c.traverse(B=>{const Q=e.associations.get(B);Q!=null&&I.set(B,Q)}),I};return e.associations=g(i),i})}_createAnimationTracks(A,n,t,e,i){const a=[],r=A.name?A.name:A.uuid,o=[];YA[i.path]===YA.weights?A.traverse(function(B){B.morphTargetInfluences&&o.push(B.name?B.name:B.uuid)}):o.push(r);let g;switch(YA[i.path]){case YA.weights:g=Pt;break;case YA.rotation:g=Ot;break;case YA.position:case YA.scale:g=Kt;break;default:switch(t.itemSize){case 1:g=Pt;break;case 2:case 3:default:g=Kt;break}break}const c=e.interpolation!==void 0?io[e.interpolation]:Me,I=this._getArrayFromAccessor(t);for(let B=0,Q=o.length;B<Q;B++){const l=new g(o[B]+"."+YA[i.path],n.array,I,c);e.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(l),a.push(l)}return a}_getArrayFromAccessor(A){let n=A.array;if(A.normalized){const t=Mt(n.constructor),e=new Float32Array(n.length);for(let i=0,a=n.length;i<a;i++)e[i]=n[i]*t;n=e}return n}_createCubicSplineTrackInterpolant(A){A.createInterpolant=function(t){const e=this instanceof Ot?so:Qs;return new e(this.times,this.values,this.getValueSize()/3,t)},A.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function Qo(s,A,n){const t=A.attributes,e=new kt;if(t.POSITION!==void 0){const r=n.json.accessors[t.POSITION],o=r.min,g=r.max;if(o!==void 0&&g!==void 0){if(e.set(new m(o[0],o[1],o[2]),new m(g[0],g[1],g[2])),r.normalized){const c=Mt(Qn[r.componentType]);e.min.multiplyScalar(c),e.max.multiplyScalar(c)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=A.targets;if(i!==void 0){const r=new m,o=new m;for(let g=0,c=i.length;g<c;g++){const I=i[g];if(I.POSITION!==void 0){const B=n.json.accessors[I.POSITION],Q=B.min,l=B.max;if(Q!==void 0&&l!==void 0){if(o.setX(Math.max(Math.abs(Q[0]),Math.abs(l[0]))),o.setY(Math.max(Math.abs(Q[1]),Math.abs(l[1]))),o.setZ(Math.max(Math.abs(Q[2]),Math.abs(l[2]))),B.normalized){const C=Mt(Qn[B.componentType]);o.multiplyScalar(C)}r.max(o)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}e.expandByVector(r)}s.boundingBox=e;const a=new gi;e.getCenter(a.center),a.radius=e.min.distanceTo(e.max)/2,s.boundingSphere=a}function ce(s,A,n){const t=A.attributes,e=[];function i(a,r){return n.getDependency("accessor",a).then(function(o){s.setAttribute(r,o)})}for(const a in t){const r=St[a]||a.toLowerCase();r in s.attributes||e.push(i(t[a],r))}if(A.indices!==void 0&&!s.index){const a=n.getDependency("accessor",A.indices).then(function(r){s.setIndex(r)});e.push(a)}return zt.workingColorSpace!==GA&&"COLOR_0"in t&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${zt.workingColorSpace}" not supported.`),RA(s,A),Qo(s,A,n),Promise.all(e).then(function(){return A.targets!==void 0?ro(s,A.targets,n):s})}const DA=1,Yn=.1*DA,Qt=.5*DA,lo=1*DA,Eo=8*DA,Be=1/60,Co=5;window.__MUTED__=!1;function Qe(s){window.__MUTED__=!!s;const A=document.getElementById("volumeToggle");A&&(A.textContent=window.__MUTED__?"":"")}async function ho(s){try{const d=fs(),p=new Promise((x,D)=>setTimeout(()=>D(new Error("Rapier initialization timeout")),s.RAPIER_INIT_TIMEOUT));await Promise.race([d,p]),console.log(" Rapier physics initialized")}catch(d){console.error("Failed to initialize Rapier:",d)}const A=new NA;A.background=new gA(2105376);const n=new Pn(75,window.innerWidth/window.innerHeight,.1,1e3);n.rotation.y=Math.PI;const t=new ci;t.setSize(window.innerWidth,window.innerHeight),t.setPixelRatio(1),t.outputColorSpace=qA;const e=new Tt({renderer:t});console.log("created spark renderer"),e.defaultView&&(console.log("setting sort32"),e.defaultView.sort32=!0,e.defaultView.sortRadial=!0),n.add(e),document.body.appendChild(t.domElement);const i=new Bi(16774374,2759178,1);i.position.set(0,20,0),A.add(i);const a=new we(16770764,.3);a.position.set(3,10,-5),A.add(a);const r=new me(16753920,2,10);r.position.set(-3.2,-1,4.5),A.add(r);const o=new ys((d=>{const x=Math.sqrt(d[0]*d[0]+d[1]*d[1]+d[2]+d[2]);return{x:9.81*d[0]/x,y:9.81*d[1]/x,z:9.81*d[2]/x}})(s.GRAVITY)),g=new Map;let c=null;{const p=Yt.dynamic().setTranslation(0,1.2,0).lockRotations(!0).setLinearDamping(4).setCcdEnabled(!0);c=o.createRigidBody(p);const x=Jt.capsule(Qt,Yn).setFriction(.8).setRestitution(0);o.createCollider(x,c)}const I=new br(n,document.body),B=document.getElementById("start"),Q=document.getElementById("info"),l=document.getElementById("loading");B.addEventListener("click",()=>I.lock()),I.addEventListener("lock",()=>{Q.style.display="none";const d=document.getElementById("reticle");d&&(d.style.display="block")}),I.addEventListener("unlock",()=>{Q.style.display="";const d=document.getElementById("reticle");d&&(d.style.display="none")});let C=null;function E(){C||(C=new(window.AudioContext||window.webkitAudioContext),Promise.all([]).then(()=>{console.log(" Audio system initialized")}).catch(d=>{console.error("Audio loading error:",d)}))}document.addEventListener("click",E,{once:!0}),document.addEventListener("keydown",E,{once:!0});const h=document.getElementById("volumeToggle");h&&(h.addEventListener("click",()=>{Qe(!window.__MUTED__)}),Qe(window.__MUTED__));const f=new Qi,u=new Map;s.objects.find(d=>d.type==="gaussian-model")&&(l.style.display="block");function y(d,p){p!==void 0&&(d.rotateX(p[0]*Math.PI/180),d.rotateY(p[1]*Math.PI/180),d.rotateZ(p[2]*Math.PI/180))}const w=new Nr;async function S({url:d,rotation:p,scale:x=1}){const b=(await w.loadAsync(d)).scene;return y(b,p),b.scale.set(-x*DA,-x*DA,x*DA),b}function M(d,p=0){d.traverse(x=>{if(x.isMesh){const D=x.geometry.clone();x.updateWorldMatrix(!0,!1),D.applyMatrix4(x.matrixWorld);const b=new Float32Array(D.attributes.position.array);let k;if(D.index)k=new Uint32Array(D.index.array);else{const F=D.attributes.position.count;k=new Uint32Array(F);for(let U=0;U<F;U++)k[U]=U}const J=Jt.trimesh(b,k).setRestitution(p),H=o.createRigidBody(Yt.fixed());o.createCollider(J,H)}})}function K({url:d,rotation:p,position:x,scale:D=1}){return new Promise(b=>{const k=new Fn({url:d,onLoad:()=>{y(k,p),k.scale.set(3*D*DA,-3*D*DA,3*D*DA),k.position.set(...x??[0,0,0]),b(k)}})})}const L=new De;function P({texture:d,width:p,height:x,position:D,rotation:b,scale:k}){const J=p/x,H=1,F=H*J,U=new Kn(F,H),q=new Cn({map:d,side:be}),$=new Kn(F,H),UA=new Cn({color:8421504,side:Ci}),_A=new $A(U,q),An=new $A($,UA);return _A.position.set(...D),An.position.set(...D),y(_A,b),y(An,b),_A.scale.set(k,k,k),An.scale.set(k,k,k),[_A,An]}async function _({url:d,...p}){const x=await L.loadAsync(d),D=x.image.width,b=x.image.height;return P({texture:x,width:D,height:b,...p})}async function j({url:d,muted:p,loop:x,...D}){const b=document.createElement("video");b.src=d,b.muted=p,b.loop=x,document.addEventListener("click",()=>b.play()),await new Promise((F,U)=>{b.addEventListener("loadedmetadata",F,{once:!0}),b.addEventListener("error",U,{once:!0})});const k=b.videoWidth,J=b.videoHeight,H=new li(b);return P({texture:H,width:k,height:J,...D})}const eA=[],V=[],sA=[];let O=!1;Promise.allSettled(s.objects.map(async d=>{if(d.type==="gaussian-model"){const p=await K(d);A.add(p),l.style.display="none",eA.push(p)}else if(d.type==="collision-mesh"){const p=await S(d);M(p,d.restitution),A.add(p),p.visible=!1,V.push(p)}else if(d.type==="image"){const[p,x]=await _(d);M(p,d.restitution),A.add(p),A.add(x),d.to!==void 0&&g.set(p,function(){const D=new URL(window.location);D.searchParams.set("model",d.to),window.location.href=D}),sA.push(p)}else if(d.type==="video"){const[p,x]=await j(d);M(p,d.restitution),A.add(p),A.add(x),sA.push(p)}else console.error("Unknown type")}).map(d=>d.catch(p=>console.error(p)))).then(()=>{O=!0});const N={};let iA=!1,Y={mesh:null,savedEmissive:null};window.addEventListener("keydown",d=>{if(N[d.code]=!0,d.code==="KeyM"&&(iA=!iA,CA()),d.code==="Space"&&c&&wA()){const p=c.linvel();c.setLinvel({x:p.x,y:Eo,z:p.z},!0)}if(d.code==="KeyP")if(c){const p=c.translation(),x=`pos=(${p.x.toFixed(3)}, ${p.y.toFixed(3)}, ${p.z.toFixed(3)})`,D=new m;n.getWorldDirection(D),D.normalize();const b=Math.atan2(D.x,D.z)*180/Math.PI,k=Math.asin(Se.clamp(D.y,-1,1))*180/Math.PI,J=c.rotation?.(),H=J?`quat=(${J.x.toFixed(3)}, ${J.y.toFixed(3)}, ${J.z.toFixed(3)}, ${J.w.toFixed(3)})`:"";console.log(`[Player] ${x}  yaw=${b.toFixed(1)}  pitch=${k.toFixed(1)}  ${H}`)}else console.log("[Player] body not initialized yet")}),window.addEventListener("keyup",d=>{N[d.code]=!1}),window.addEventListener("click",()=>{I.isLocked&&Y.mesh&&g.get(Y.mesh)()});function wA(){if(!c)return!1;const d=c.translation(),p={x:d.x,y:d.y,z:d.z},x={x:0,y:-1,z:0},D=new Ht(p,x),b=Qt+Yn,k=o.castRayAndGetNormal(D,b+.6,!0);if(!k)return!1;const J=k.normal?k.normal.y:1,H=k.toi<=b+.12&&J>.3,F=c.linvel().y;return H&&F<=.6}function CA(){O&&(iA?(eA.forEach(d=>A.remove(d)),V.forEach(d=>{d.visible=!0,d.traverse(p=>{p.isMesh&&(u.has(p.uuid)||u.set(p.uuid,p.material),p.material=f)})})):(eA.forEach(d=>A.add(d)),V.forEach(d=>{d.visible=!1,d.traverse(p=>{p.isMesh&&u.has(p.uuid)&&(p.material=u.get(p.uuid))})})))}let cA=s.height_offset??0;function aA(d){if(!I.isLocked||!c)return;const p=new m;n.getWorldDirection(p),p.y=0,p.normalize();const x=new m;x.crossVectors(p,n.up).normalize();const D=new m;if(N.KeyW&&D.add(p),N.KeyS&&D.sub(p),N.KeyD&&D.add(x),N.KeyA&&D.sub(x),window.debug){let F=Y.mesh;F===null&&window.sceneDebug&&A.children.find(q=>q instanceof Fn);const U=N.AltLeft?-1:1;if(N.KeyZ&&(F.position.x+=U*.001),N.KeyX&&(F.position.y+=U*.001),N.KeyC&&(F.position.z+=U*.001),N.KeyV&&F.rotateX(U*.001),N.KeyB&&F.rotateY(U*.001),N.KeyN&&F.rotateZ(U*.001),N.Comma&&F.scale.multiplyScalar(1+U*.001),N.Period){const q=[F.position.x,F.position.y,F.position.z],$=[F.rotation.x,F.rotation.y,F.rotation.z].map(_A=>_A*180/Math.PI),UA=F.scale.x;console.log({position:q,rotation:$,scale:UA})}}let b=0,k=0;if(D.lengthSq()>0){D.normalize().multiplyScalar(s.MOVE_SPEED);const F=D.clone(),U=yA(F);b=U.x,k=U.z}let H=c.linvel().y;s.movable_ground?(N.KeyR&&(cA+=s.movable_ground),N.KeyF&&(cA-=s.movable_ground)):(N.KeyR&&(H+=s.MOVE_SPEED),N.KeyF&&(H-=s.MOVE_SPEED)),c.setLinvel({x:b,y:H,z:k},!0)}function yA(d){const p=d.clone();if(p.lengthSq()===0)return p;const x=c.translation(),D=new m(p.x,0,p.z);if(D.length()===0)return p;D.normalize();const k={x:x.x,y:x.y,z:x.z},J={x:D.x,y:0,z:D.z},H=new Ht(k,J),F=Yn+.1,q=o.castRayAndGetNormal(H,F,!0)?.normal;if(q){const $=new m(q.x,q.y,q.z);if($.y=0,$.lengthSq()>1e-4){$.normalize();const UA=p.dot($);UA>0&&p.addScaledVector($,-UA)}}return p}let rA=performance.now(),BA=0;function v(d){requestAnimationFrame(v);const p=Math.min((d-rA)/1e3,.1);if(rA=d,O){aA(),BA+=p;const x=Math.min(Math.floor(BA/Be),Co);for(let D=0;D<x;D++)o.step(),BA-=Be;if(c){const D=c.translation(),b=D.y-(Qt+Yn);n.position.set(D.x,b+lo+cA,D.z)}}e?.update({scene:A}),hA(),t.render(A,n)}function hA(){if(Y.mesh&&Y.savedEmissive!=null){const k=Y.mesh.material;k&&k.emissive&&k.emissive.setHex(Y.savedEmissive)}Y={mesh:null,savedEmissive:null};const d=new Ei;d.far=s.INTERACTION.MAX_DISTANCE,d.setFromCamera({x:0,y:0},n);const p=d.intersectObjects(sA,!1);if(!p||p.length===0)return;const x=p.find(k=>k.distance<=s.INTERACTION.MAX_DISTANCE);if(!x)return;const D=x.object;if(!D||!g.has(D))return;const b=D.material;b&&b.emissive&&(Y={mesh:D,savedEmissive:b.emissive.getHex()},b.emissive.setHex(16776960))}window.addEventListener("resize",()=>{n.aspect=window.innerWidth/window.innerHeight,n.updateProjectionMatrix(),t.setSize(window.innerWidth,window.innerHeight)}),v(rA),console.log(" Tavern demo initialized successfully!")}const uo=new URLSearchParams(window.location.search).get("model");fetch(`${uo}.json`).then(s=>s.json()).then(s=>ho(s));
