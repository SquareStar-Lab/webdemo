import{A as sl,O as rl,L as oi,x as ai,E as li}from"./rapier-7f742b17.js";import{E as at,V as F,C as il,a as zt,b as ol,L as zn,c as pn,F as Bs,T as Br,R as Hn,d as pr,e as mr,M as Yn,f as al,g as _t,h as Se,S as Ue,i as ll,j as he,G as Je,B as As,P as Vn,O as Ze,k as Ps,l as ys,m as Ae,n as ko,D as Pr,o as Dr,p as Oe,q as _n,r as Fr,s as Cn,A as cl,t as je,u as nt,U as ul,v as We,w as ge,x as dl,y as vs,Q as ce,z as Wn,H as xn,N as gr,I as hl,J as Ar,K as Oo,W as Pt,X as rt,Y as bt,Z as fl,_ as Uo,$ as pl,a0 as He,a1 as ml,a2 as yr,a3 as No,a4 as zo,a5 as Ho,a6 as fs,a7 as xs,a8 as Sn,a9 as Ds,aa as gl,ab as Vo,ac as Lr,ad as Wo,ae as Al,af as yl,ag as vl,ah as xl,ai as Sl,aj as Ss,ak as wl,al as Qt,am as _l,an as Cl,ao as wt,ap as Tl,aq as Ml,ar as jo,as as Qo,at as mn,au as El,av as bl,aw as Tn,ax as Go,ay as ci,az as ws,aA as Il,aB as Rl,aC as jn,aD as Bl,aE as Pl,aF as qo,aG as Xo,aH as Dl,aI as Yt,aJ as Zt,aK as ui,aL as Fl,aM as Ct,aN as Ll,aO as kl,aP as Pn,aQ as Ol,aR as di,aS as hi,aT as _s,aU as Ul,aV as vr,aW as Nl,aX as Os,aY as Ut,aZ as zl,a_ as Hl,a$ as fi,b0 as Ko,b1 as Vl,b2 as Wl,b3 as jl,b4 as Ql,b5 as Gl,b6 as ql,b7 as Xl}from"./three-8b03339f.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const r of s)if(r.type==="childList")for(const i of r.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&n(i)}).observe(document,{childList:!0,subtree:!0});function t(s){const r={};return s.integrity&&(r.integrity=s.integrity),s.referrerPolicy&&(r.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?r.credentials="include":s.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function n(s){if(s.ep)return;s.ep=!0;const r=t(s);fetch(s.href,r)}})();const Jt=new at(0,0,0,"YXZ"),$t=new F,Kl={type:"change"},Yl={type:"lock"},Zl={type:"unlock"},pi=Math.PI/2;class Jl extends il{constructor(e,t=null){super(e,t),this.isLocked=!1,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.pointerSpeed=1,this._onMouseMove=$l.bind(this),this._onPointerlockChange=ec.bind(this),this._onPointerlockError=tc.bind(this),this.domElement!==null&&this.connect()}connect(){this.domElement.ownerDocument.addEventListener("mousemove",this._onMouseMove),this.domElement.ownerDocument.addEventListener("pointerlockchange",this._onPointerlockChange),this.domElement.ownerDocument.addEventListener("pointerlockerror",this._onPointerlockError)}disconnect(){this.domElement.ownerDocument.removeEventListener("mousemove",this._onMouseMove),this.domElement.ownerDocument.removeEventListener("pointerlockchange",this._onPointerlockChange),this.domElement.ownerDocument.removeEventListener("pointerlockerror",this._onPointerlockError)}dispose(){this.disconnect()}getObject(){return console.warn("THREE.PointerLockControls: getObject() has been deprecated. Use controls.object instead."),this.object}getDirection(e){return e.set(0,0,-1).applyQuaternion(this.object.quaternion)}moveForward(e){if(this.enabled===!1)return;const t=this.object;$t.setFromMatrixColumn(t.matrix,0),$t.crossVectors(t.up,$t),t.position.addScaledVector($t,e)}moveRight(e){if(this.enabled===!1)return;const t=this.object;$t.setFromMatrixColumn(t.matrix,0),t.position.addScaledVector($t,e)}lock(){this.domElement.requestPointerLock()}unlock(){this.domElement.ownerDocument.exitPointerLock()}}function $l(l){if(this.enabled===!1||this.isLocked===!1)return;const e=this.object;Jt.setFromQuaternion(e.quaternion),Jt.y-=l.movementX*.002*this.pointerSpeed,Jt.x-=l.movementY*.002*this.pointerSpeed,Jt.x=Math.max(pi-this.maxPolarAngle,Math.min(pi-this.minPolarAngle,Jt.x)),e.quaternion.setFromEuler(Jt),this.dispatchEvent(Kl)}function ec(){this.domElement.ownerDocument.pointerLockElement===this.domElement?(this.dispatchEvent(Yl),this.isLocked=!0):(this.dispatchEvent(Zl),this.isLocked=!1)}function tc(){console.error("THREE.PointerLockControls: Unable to use Pointer Lock API")}/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.8.2
*/var pt=Uint8Array,hn=Uint16Array,nc=Int32Array,Yo=new pt([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Zo=new pt([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),sc=new pt([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Jo=function(l,e){for(var t=new hn(31),n=0;n<31;++n)t[n]=e+=1<<l[n-1];for(var s=new nc(t[30]),n=1;n<30;++n)for(var r=t[n];r<t[n+1];++r)s[r]=r-t[n]<<5|n;return{b:t,r:s}},$o=Jo(Yo,2),ea=$o.b,rc=$o.r;ea[28]=258,rc[258]=28;var ic=Jo(Zo,0),oc=ic.b,xr=new hn(32768);for(var De=0;De<32768;++De){var Ft=(De&43690)>>1|(De&21845)<<1;Ft=(Ft&52428)>>2|(Ft&13107)<<2,Ft=(Ft&61680)>>4|(Ft&3855)<<4,xr[De]=((Ft&65280)>>8|(Ft&255)<<8)>>1}var Fn=function(l,e,t){for(var n=l.length,s=0,r=new hn(e);s<n;++s)l[s]&&++r[l[s]-1];var i=new hn(e);for(s=1;s<e;++s)i[s]=i[s-1]+r[s-1]<<1;var o;if(t){o=new hn(1<<e);var a=15-e;for(s=0;s<n;++s)if(l[s])for(var c=s<<4|l[s],d=e-l[s],u=i[l[s]-1]++<<d,f=u|(1<<d)-1;u<=f;++u)o[xr[u]>>a]=c}else for(o=new hn(n),s=0;s<n;++s)l[s]&&(o[s]=xr[i[l[s]-1]++]>>15-l[s]);return o},Gn=new pt(288);for(var De=0;De<144;++De)Gn[De]=8;for(var De=144;De<256;++De)Gn[De]=9;for(var De=256;De<280;++De)Gn[De]=7;for(var De=280;De<288;++De)Gn[De]=8;var ta=new pt(32);for(var De=0;De<32;++De)ta[De]=5;var ac=Fn(Gn,9,1),lc=Fn(ta,5,1),Us=function(l){for(var e=l[0],t=1;t<l.length;++t)l[t]>e&&(e=l[t]);return e},gt=function(l,e,t){var n=e/8|0;return(l[n]|l[n+1]<<8)>>(e&7)&t},Ns=function(l,e){var t=e/8|0;return(l[t]|l[t+1]<<8|l[t+2]<<16)>>(e&7)},cc=function(l){return(l+7)/8|0},uc=function(l,e,t){return(e==null||e<0)&&(e=0),(t==null||t>l.length)&&(t=l.length),new pt(l.subarray(e,t))},dc=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],At=function(l,e,t){var n=new Error(e||dc[l]);if(n.code=l,Error.captureStackTrace&&Error.captureStackTrace(n,At),!t)throw n;return n},hc=function(l,e,t,n){var s=l.length,r=n?n.length:0;if(!s||e.f&&!e.l)return t||new pt(0);var i=!t,o=i||e.i!=2,a=e.i;i&&(t=new pt(s*3));var c=function(X){var ie=t.length;if(X>ie){var ee=new pt(Math.max(ie*2,X));ee.set(t),t=ee}},d=e.f||0,u=e.p||0,f=e.b||0,h=e.l,g=e.d,p=e.m,m=e.n,A=s*8;do{if(!h){d=gt(l,u,1);var y=gt(l,u+1,3);if(u+=3,y)if(y==1)h=ac,g=lc,p=9,m=5;else if(y==2){var T=gt(l,u,31)+257,C=gt(l,u+10,15)+4,E=T+gt(l,u+5,31)+1;u+=14;for(var I=new pt(E),P=new pt(19),B=0;B<C;++B)P[sc[B]]=gt(l,u+B*3,7);u+=C*3;for(var M=Us(P),D=(1<<M)-1,_=Fn(P,M,1),B=0;B<E;){var k=_[gt(l,u,D)];u+=k&15;var v=k>>4;if(v<16)I[B++]=v;else{var G=0,O=0;for(v==16?(O=3+gt(l,u,3),u+=2,G=I[B-1]):v==17?(O=3+gt(l,u,7),u+=3):v==18&&(O=11+gt(l,u,127),u+=7);O--;)I[B++]=G}}var $=I.subarray(0,T),U=I.subarray(T);p=Us($),m=Us(U),h=Fn($,p,1),g=Fn(U,m,1)}else At(1);else{var v=cc(u)+4,x=l[v-4]|l[v-3]<<8,w=v+x;if(w>s){a&&At(0);break}o&&c(f+x),t.set(l.subarray(v,w),f),e.b=f+=x,e.p=u=w*8,e.f=d;continue}if(u>A){a&&At(0);break}}o&&c(f+131072);for(var Z=(1<<p)-1,V=(1<<m)-1,z=u;;z=u){var G=h[Ns(l,u)&Z],ne=G>>4;if(u+=G&15,u>A){a&&At(0);break}if(G||At(2),ne<256)t[f++]=ne;else if(ne==256){z=u,h=null;break}else{var te=ne-254;if(ne>264){var B=ne-257,J=Yo[B];te=gt(l,u,(1<<J)-1)+ea[B],u+=J}var ue=g[Ns(l,u)&V],me=ue>>4;ue||At(3),u+=ue&15;var U=oc[me];if(me>3){var J=Zo[me];U+=Ns(l,u)&(1<<J)-1,u+=J}if(u>A){a&&At(0);break}o&&c(f+131072);var de=f+te;if(f<U){var fe=r-U,q=Math.min(U,de);for(fe+f<0&&At(3);f<q;++f)t[f]=n[fe+f]}for(;f<de;++f)t[f]=t[f-U]}}e.l=h,e.p=z,e.b=f,e.f=d,h&&(d=1,e.m=p,e.d=g,e.n=m)}while(!d);return f!=t.length&&i?uc(t,0,f):t.subarray(0,f)},fc=new pt(0),pc=function(l,e){return((l[0]&15)!=8||l[0]>>4>7||(l[0]<<8|l[1])%31)&&At(6,"invalid zlib data"),(l[1]>>5&1)==+!e&&At(6,"invalid zlib data: "+(l[1]&32?"need":"unexpected")+" dictionary"),(l[1]>>3&4)+2};function mc(l,e){return hc(l.subarray(pc(l,e&&e.dictionary),-4),{i:2},e&&e.out,e&&e.dictionary)}var gc=typeof TextDecoder<"u"&&new TextDecoder,Ac=0;try{gc.decode(fc,{stream:!0}),Ac=1}catch{}function na(l,e,t){const n=t.length-l-1;if(e>=t[n])return n-1;if(e<=t[l])return l;let s=l,r=n,i=Math.floor((s+r)/2);for(;e<t[i]||e>=t[i+1];)e<t[i]?r=i:s=i,i=Math.floor((s+r)/2);return i}function yc(l,e,t,n){const s=[],r=[],i=[];s[0]=1;for(let o=1;o<=t;++o){r[o]=e-n[l+1-o],i[o]=n[l+o]-e;let a=0;for(let c=0;c<o;++c){const d=i[c+1],u=r[o-c],f=s[c]/(d+u);s[c]=a+d*f,a=u*f}s[o]=a}return s}function vc(l,e,t,n){const s=na(l,n,e),r=yc(s,n,l,e),i=new zt(0,0,0,0);for(let o=0;o<=l;++o){const a=t[s-l+o],c=r[o],d=a.w*c;i.x+=a.x*d,i.y+=a.y*d,i.z+=a.z*d,i.w+=a.w*c}return i}function xc(l,e,t,n,s){const r=[];for(let u=0;u<=t;++u)r[u]=0;const i=[];for(let u=0;u<=n;++u)i[u]=r.slice(0);const o=[];for(let u=0;u<=t;++u)o[u]=r.slice(0);o[0][0]=1;const a=r.slice(0),c=r.slice(0);for(let u=1;u<=t;++u){a[u]=e-s[l+1-u],c[u]=s[l+u]-e;let f=0;for(let h=0;h<u;++h){const g=c[h+1],p=a[u-h];o[u][h]=g+p;const m=o[h][u-1]/o[u][h];o[h][u]=f+g*m,f=p*m}o[u][u]=f}for(let u=0;u<=t;++u)i[0][u]=o[u][t];for(let u=0;u<=t;++u){let f=0,h=1;const g=[];for(let p=0;p<=t;++p)g[p]=r.slice(0);g[0][0]=1;for(let p=1;p<=n;++p){let m=0;const A=u-p,y=t-p;u>=p&&(g[h][0]=g[f][0]/o[y+1][A],m=g[h][0]*o[A][y]);const v=A>=-1?1:-A,x=u-1<=y?p-1:t-u;for(let T=v;T<=x;++T)g[h][T]=(g[f][T]-g[f][T-1])/o[y+1][A+T],m+=g[h][T]*o[A+T][y];u<=y&&(g[h][p]=-g[f][p-1]/o[y+1][u],m+=g[h][p]*o[u][y]),i[p][u]=m;const w=f;f=h,h=w}}let d=t;for(let u=1;u<=n;++u){for(let f=0;f<=t;++f)i[u][f]*=d;d*=t-u}return i}function Sc(l,e,t,n,s){const r=s<l?s:l,i=[],o=na(l,n,e),a=xc(o,n,l,r,e),c=[];for(let d=0;d<t.length;++d){const u=t[d].clone(),f=u.w;u.x*=f,u.y*=f,u.z*=f,c[d]=u}for(let d=0;d<=r;++d){const u=c[o-l].clone().multiplyScalar(a[d][0]);for(let f=1;f<=l;++f)u.add(c[o-l+f].clone().multiplyScalar(a[d][f]));i[d]=u}for(let d=r+1;d<=s+1;++d)i[d]=new zt(0,0,0);return i}function wc(l,e){let t=1;for(let s=2;s<=l;++s)t*=s;let n=1;for(let s=2;s<=e;++s)n*=s;for(let s=2;s<=l-e;++s)n*=s;return t/n}function _c(l){const e=l.length,t=[],n=[];for(let r=0;r<e;++r){const i=l[r];t[r]=new F(i.x,i.y,i.z),n[r]=i.w}const s=[];for(let r=0;r<e;++r){const i=t[r].clone();for(let o=1;o<=r;++o)i.sub(s[r-o].clone().multiplyScalar(wc(r,o)*n[o]));s[r]=i.divideScalar(n[0])}return s}function Cc(l,e,t,n,s){const r=Sc(l,e,t,n,s);return _c(r)}class Tc extends ol{constructor(e,t,n,s,r){super();const i=t?t.length-1:0,o=n?n.length:0;this.degree=e,this.knots=t,this.controlPoints=[],this.startKnot=s||0,this.endKnot=r||i;for(let a=0;a<o;++a){const c=n[a];this.controlPoints[a]=new zt(c.x,c.y,c.z,c.w)}}getPoint(e,t=new F){const n=t,s=this.knots[this.startKnot]+e*(this.knots[this.endKnot]-this.knots[this.startKnot]),r=vc(this.degree,this.knots,this.controlPoints,s);return r.w!==1&&r.divideScalar(r.w),n.set(r.x,r.y,r.z)}getTangent(e,t=new F){const n=t,s=this.knots[0]+e*(this.knots[this.knots.length-1]-this.knots[0]),r=Cc(this.degree,this.knots,this.controlPoints,s,1);return n.copy(r[1]).normalize(),n}toJSON(){const e=super.toJSON();return e.degree=this.degree,e.knots=[...this.knots],e.controlPoints=this.controlPoints.map(t=>t.toArray()),e.startKnot=this.startKnot,e.endKnot=this.endKnot,e}fromJSON(e){return super.fromJSON(e),this.degree=e.degree,this.knots=[...e.knots],this.controlPoints=e.controlPoints.map(t=>new zt(t[0],t[1],t[2],t[3])),this.startKnot=e.startKnot,this.endKnot=e.endKnot,this}}let ye,Ne,et;class Mc extends zn{constructor(e){super(e)}load(e,t,n,s){const r=this,i=r.path===""?pn.extractUrlBase(e):r.path,o=new Bs(this.manager);o.setPath(r.path),o.setResponseType("arraybuffer"),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(e,function(a){try{t(r.parse(a,i))}catch(c){s?s(c):console.error(c),r.manager.itemError(e)}},n,s)}parse(e,t){if(Pc(e))ye=new Bc().parse(e);else{const s=ia(e);if(!Dc(s))throw new Error("THREE.FBXLoader: Unknown format.");if(gi(s)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+gi(s));ye=new Rc().parse(s)}const n=new Br(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new Ec(n,this.manager).parse(ye)}}class Ec{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){Ne=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),n=this.parseMaterials(t),s=this.parseDeformers(),r=new bc().parse(s);return this.parseScene(s,r,n),et}parseConnections(){const e=new Map;return"Connections"in ye&&ye.Connections.connections.forEach(function(n){const s=n[0],r=n[1],i=n[2];e.has(s)||e.set(s,{parents:[],children:[]});const o={ID:r,relationship:i};e.get(s).parents.push(o),e.has(r)||e.set(r,{parents:[],children:[]});const a={ID:s,relationship:i};e.get(r).children.push(a)}),e}parseImages(){const e={},t={};if("Video"in ye.Objects){const n=ye.Objects.Video;for(const s in n){const r=n[s],i=parseInt(s);if(e[i]=r.RelativeFilename||r.Filename,"Content"in r){const o=r.Content instanceof ArrayBuffer&&r.Content.byteLength>0,a=typeof r.Content=="string"&&r.Content!=="";if(o||a){const c=this.parseImage(n[s]);t[r.RelativeFilename||r.Filename]=c}}}}for(const n in e){const s=e[n];t[s]!==void 0?e[n]=t[s]:e[n]=e[n].split("\\").pop()}return e}parseImage(e){const t=e.Content,n=e.RelativeFilename||e.Filename,s=n.slice(n.lastIndexOf(".")+1).toLowerCase();let r;switch(s){case"bmp":r="image/bmp";break;case"jpg":case"jpeg":r="image/jpeg";break;case"png":r="image/png";break;case"tif":r="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",n),r="image/tga";break;default:console.warn('FBXLoader: Image type "'+s+'" is not supported.');return}if(typeof t=="string")return"data:"+r+";base64,"+t;{const i=new Uint8Array(t);return window.URL.createObjectURL(new Blob([i],{type:r}))}}parseTextures(e){const t=new Map;if("Texture"in ye.Objects){const n=ye.Objects.Texture;for(const s in n){const r=this.parseTexture(n[s],e);t.set(parseInt(s),r)}}return t}parseTexture(e,t){const n=this.loadTexture(e,t);n.ID=e.id,n.name=e.attrName;const s=e.WrapModeU,r=e.WrapModeV,i=s!==void 0?s.value:0,o=r!==void 0?r.value:0;if(n.wrapS=i===0?Hn:pr,n.wrapT=o===0?Hn:pr,"Scaling"in e){const a=e.Scaling.value;n.repeat.x=a[0],n.repeat.y=a[1]}if("Translation"in e){const a=e.Translation.value;n.offset.x=a[0],n.offset.y=a[1]}return n}loadTexture(e,t){const n=new Set(["tga","tif","tiff","exr","dds","hdr","ktx2"]),s=e.FileName.split(".").pop().toLowerCase(),r=n.has(s)?this.manager.getHandler(`.${s}`):this.textureLoader;if(!r)return console.warn(`FBXLoader: ${s.toUpperCase()} loader not found, creating placeholder texture for`,e.RelativeFilename),new mr;const i=r.path;i||r.setPath(this.textureLoader.path);const o=Ne.get(e.id).children;let a;o!==void 0&&o.length>0&&t[o[0].ID]!==void 0&&(a=t[o[0].ID],(a.indexOf("blob:")===0||a.indexOf("data:")===0)&&r.setPath(void 0));const c=r.load(a);return r.setPath(i),c}parseMaterials(e){const t=new Map;if("Material"in ye.Objects){const n=ye.Objects.Material;for(const s in n){const r=this.parseMaterial(n[s],e);r!==null&&t.set(parseInt(s),r)}}return t}parseMaterial(e,t){const n=e.id,s=e.attrName;let r=e.ShadingModel;if(typeof r=="object"&&(r=r.value),!Ne.has(n))return null;const i=this.parseParameters(e,t,n);let o;switch(r.toLowerCase()){case"phong":o=new Yn;break;case"lambert":o=new al;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',r),o=new Yn;break}return o.setValues(i),o.name=s,o}parseParameters(e,t,n){const s={};e.BumpFactor&&(s.bumpScale=e.BumpFactor.value),e.Diffuse?s.color=_t.toWorkingColorSpace(new Se().fromArray(e.Diffuse.value),Ue):e.DiffuseColor&&(e.DiffuseColor.type==="Color"||e.DiffuseColor.type==="ColorRGB")&&(s.color=_t.toWorkingColorSpace(new Se().fromArray(e.DiffuseColor.value),Ue)),e.DisplacementFactor&&(s.displacementScale=e.DisplacementFactor.value),e.Emissive?s.emissive=_t.toWorkingColorSpace(new Se().fromArray(e.Emissive.value),Ue):e.EmissiveColor&&(e.EmissiveColor.type==="Color"||e.EmissiveColor.type==="ColorRGB")&&(s.emissive=_t.toWorkingColorSpace(new Se().fromArray(e.EmissiveColor.value),Ue)),e.EmissiveFactor&&(s.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),s.opacity=1-(e.TransparencyFactor?parseFloat(e.TransparencyFactor.value):0),(s.opacity===1||s.opacity===0)&&(s.opacity=e.Opacity?parseFloat(e.Opacity.value):null,s.opacity===null&&(s.opacity=1-(e.TransparentColor?parseFloat(e.TransparentColor.value[0]):0))),s.opacity<1&&(s.transparent=!0),e.ReflectionFactor&&(s.reflectivity=e.ReflectionFactor.value),e.Shininess&&(s.shininess=e.Shininess.value),e.Specular?s.specular=_t.toWorkingColorSpace(new Se().fromArray(e.Specular.value),Ue):e.SpecularColor&&e.SpecularColor.type==="Color"&&(s.specular=_t.toWorkingColorSpace(new Se().fromArray(e.SpecularColor.value),Ue));const r=this;return Ne.get(n).children.forEach(function(i){const o=i.relationship;switch(o){case"Bump":s.bumpMap=r.getTexture(t,i.ID);break;case"Maya|TEX_ao_map":s.aoMap=r.getTexture(t,i.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":s.map=r.getTexture(t,i.ID),s.map!==void 0&&(s.map.colorSpace=Ue);break;case"DisplacementColor":s.displacementMap=r.getTexture(t,i.ID);break;case"EmissiveColor":s.emissiveMap=r.getTexture(t,i.ID),s.emissiveMap!==void 0&&(s.emissiveMap.colorSpace=Ue);break;case"NormalMap":case"Maya|TEX_normal_map":s.normalMap=r.getTexture(t,i.ID);break;case"ReflectionColor":s.envMap=r.getTexture(t,i.ID),s.envMap!==void 0&&(s.envMap.mapping=ll,s.envMap.colorSpace=Ue);break;case"SpecularColor":s.specularMap=r.getTexture(t,i.ID),s.specularMap!==void 0&&(s.specularMap.colorSpace=Ue);break;case"TransparentColor":case"TransparencyFactor":s.alphaMap=r.getTexture(t,i.ID),s.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",o);break}}),s}getTexture(e,t){return"LayeredTexture"in ye.Objects&&t in ye.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=Ne.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in ye.Objects){const n=ye.Objects.Deformer;for(const s in n){const r=n[s],i=Ne.get(parseInt(s));if(r.attrType==="Skin"){const o=this.parseSkeleton(i,n);o.ID=s,i.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),o.geometryID=i.parents[0].ID,e[s]=o}else if(r.attrType==="BlendShape"){const o={id:s};o.rawTargets=this.parseMorphTargets(i,n),o.id=s,i.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[s]=o}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const n=[];return e.children.forEach(function(s){const r=t[s.ID];if(r.attrType!=="Cluster")return;const i={ID:s.ID,indices:[],weights:[],transformLink:new he().fromArray(r.TransformLink.a)};"Indexes"in r&&(i.indices=r.Indexes.a,i.weights=r.Weights.a),n.push(i)}),{rawBones:n,bones:[]}}parseMorphTargets(e,t){const n=[];for(let s=0;s<e.children.length;s++){const r=e.children[s],i=t[r.ID],o={name:i.attrName,initialWeight:i.DeformPercent,id:i.id,fullWeights:i.FullWeights.a};if(i.attrType!=="BlendShapeChannel")return;o.geoID=Ne.get(parseInt(r.ID)).children.filter(function(a){return a.relationship===void 0})[0].ID,n.push(o)}return n}parseScene(e,t,n){et=new Je;const s=this.parseModels(e.skeletons,t,n),r=ye.Objects.Model,i=this;s.forEach(function(a){const c=r[a.ID];i.setLookAtProperties(a,c),Ne.get(a.ID).parents.forEach(function(u){const f=s.get(u.ID);f!==void 0&&f.add(a)}),a.parent===null&&et.add(a)}),this.bindSkeleton(e.skeletons,t,s),this.addGlobalSceneSettings(),et.traverse(function(a){if(a.userData.transformData){a.parent&&(a.userData.transformData.parentMatrix=a.parent.matrix,a.userData.transformData.parentMatrixWorld=a.parent.matrixWorld);const c=ra(a.userData.transformData);a.applyMatrix4(c),a.updateWorldMatrix()}});const o=new Ic().parse();et.children.length===1&&et.children[0].isGroup&&(et.children[0].animations=o,et=et.children[0]),et.animations=o}parseModels(e,t,n){const s=new Map,r=ye.Objects.Model;for(const i in r){const o=parseInt(i),a=r[i],c=Ne.get(o);let d=this.buildSkeleton(c,e,o,a.attrName);if(!d){switch(a.attrType){case"Camera":d=this.createCamera(c);break;case"Light":d=this.createLight(c);break;case"Mesh":d=this.createMesh(c,t,n);break;case"NurbsCurve":d=this.createCurve(c,t);break;case"LimbNode":case"Root":d=new As;break;case"Null":default:d=new Je;break}d.name=a.attrName?Vn.sanitizeNodeName(a.attrName):"",d.userData.originalName=a.attrName,d.ID=o}this.getTransformData(d,a),s.set(o,d)}return s}buildSkeleton(e,t,n,s){let r=null;return e.parents.forEach(function(i){for(const o in t){const a=t[o];a.rawBones.forEach(function(c,d){if(c.ID===i.ID){const u=r;r=new As,r.matrixWorld.copy(c.transformLink),r.name=s?Vn.sanitizeNodeName(s):"",r.userData.originalName=s,r.ID=n,a.bones[d]=r,u!==null&&r.add(u)}})}}),r}createCamera(e){let t,n;if(e.children.forEach(function(s){const r=ye.Objects.NodeAttribute[s.ID];r!==void 0&&(n=r)}),n===void 0)t=new Ze;else{let s=0;n.CameraProjectionType!==void 0&&n.CameraProjectionType.value===1&&(s=1);let r=1;n.NearPlane!==void 0&&(r=n.NearPlane.value/1e3);let i=1e3;n.FarPlane!==void 0&&(i=n.FarPlane.value/1e3);let o=window.innerWidth,a=window.innerHeight;n.AspectWidth!==void 0&&n.AspectHeight!==void 0&&(o=n.AspectWidth.value,a=n.AspectHeight.value);const c=o/a;let d=45;n.FieldOfView!==void 0&&(d=n.FieldOfView.value);const u=n.FocalLength?n.FocalLength.value:null;switch(s){case 0:t=new Ps(d,c,r,i),u!==null&&t.setFocalLength(u);break;case 1:console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."),t=new Ze;break;default:console.warn("THREE.FBXLoader: Unknown camera type "+s+"."),t=new Ze;break}}return t}createLight(e){let t,n;if(e.children.forEach(function(s){const r=ye.Objects.NodeAttribute[s.ID];r!==void 0&&(n=r)}),n===void 0)t=new Ze;else{let s;n.LightType===void 0?s=0:s=n.LightType.value;let r=16777215;n.Color!==void 0&&(r=_t.toWorkingColorSpace(new Se().fromArray(n.Color.value),Ue));let i=n.Intensity===void 0?1:n.Intensity.value/100;n.CastLightOnObject!==void 0&&n.CastLightOnObject.value===0&&(i=0);let o=0;n.FarAttenuationEnd!==void 0&&(n.EnableFarAttenuation!==void 0&&n.EnableFarAttenuation.value===0?o=0:o=n.FarAttenuationEnd.value);const a=1;switch(s){case 0:t=new ys(r,i,o,a);break;case 1:t=new Pr(r,i);break;case 2:let c=Math.PI/3;n.InnerAngle!==void 0&&(c=Ae.degToRad(n.InnerAngle.value));let d=0;n.OuterAngle!==void 0&&(d=Ae.degToRad(n.OuterAngle.value),d=Math.max(d,1)),t=new ko(r,i,o,c,d,a);break;default:console.warn("THREE.FBXLoader: Unknown light type "+n.LightType.value+", defaulting to a PointLight."),t=new ys(r,i);break}n.CastShadows!==void 0&&n.CastShadows.value===1&&(t.castShadow=!0)}return t}createMesh(e,t,n){let s,r=null,i=null;const o=[];if(e.children.forEach(function(a){t.has(a.ID)&&(r=t.get(a.ID)),n.has(a.ID)&&o.push(n.get(a.ID))}),o.length>1?i=o:o.length>0?i=o[0]:(i=new Yn({name:zn.DEFAULT_MATERIAL_NAME,color:13421772}),o.push(i)),"color"in r.attributes&&o.forEach(function(a){a.vertexColors=!0}),r.groups.length>0){let a=!1;for(let c=0,d=r.groups.length;c<d;c++){const u=r.groups[c];(u.materialIndex<0||u.materialIndex>=o.length)&&(u.materialIndex=o.length,a=!0)}if(a){const c=new Yn;o.push(c)}}return r.FBX_Deformer?(s=new Dr(r,i),s.normalizeSkinWeights()):s=new Oe(r,i),s}createCurve(e,t){const n=e.children.reduce(function(r,i){return t.has(i.ID)&&(r=t.get(i.ID)),r},null),s=new _n({name:zn.DEFAULT_MATERIAL_NAME,color:3342591,linewidth:1});return new Fr(n,s)}getTransformData(e,t){const n={};"InheritType"in t&&(n.inheritType=parseInt(t.InheritType.value)),"RotationOrder"in t?n.eulerOrder=Qn(t.RotationOrder.value):n.eulerOrder=Qn(0),"Lcl_Translation"in t&&(n.translation=t.Lcl_Translation.value),"PreRotation"in t&&(n.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(n.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(n.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(n.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(n.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(n.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(n.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(n.rotationPivot=t.RotationPivot.value),e.userData.transformData=n}setLookAtProperties(e,t){"LookAtProperty"in t&&Ne.get(e.ID).children.forEach(function(s){if(s.relationship==="LookAtProperty"){const r=ye.Objects.Model[s.ID];if("Lcl_Translation"in r){const i=r.Lcl_Translation.value;e.target!==void 0?(e.target.position.fromArray(i),et.add(e.target)):e.lookAt(new F().fromArray(i))}}})}bindSkeleton(e,t,n){const s=this.parsePoseNodes();for(const r in e){const i=e[r];Ne.get(parseInt(i.ID)).parents.forEach(function(a){if(t.has(a.ID)){const c=a.ID;Ne.get(c).parents.forEach(function(u){n.has(u.ID)&&n.get(u.ID).bind(new Cn(i.bones),s[u.ID])})}})}}parsePoseNodes(){const e={};if("Pose"in ye.Objects){const t=ye.Objects.Pose;for(const n in t)if(t[n].attrType==="BindPose"&&t[n].NbPoseNodes>0){const s=t[n].PoseNode;Array.isArray(s)?s.forEach(function(r){e[r.Node]=new he().fromArray(r.Matrix.a)}):e[s.Node]=new he().fromArray(s.Matrix.a)}}return e}addGlobalSceneSettings(){if("GlobalSettings"in ye){if("AmbientColor"in ye.GlobalSettings){const e=ye.GlobalSettings.AmbientColor.value,t=e[0],n=e[1],s=e[2];if(t!==0||n!==0||s!==0){const r=new Se().setRGB(t,n,s,Ue);et.add(new cl(r,1))}}"UnitScaleFactor"in ye.GlobalSettings&&(et.userData.unitScaleFactor=ye.GlobalSettings.UnitScaleFactor.value)}}}class bc{constructor(){this.negativeMaterialIndices=!1}parse(e){const t=new Map;if("Geometry"in ye.Objects){const n=ye.Objects.Geometry;for(const s in n){const r=Ne.get(parseInt(s)),i=this.parseGeometry(r,n[s],e);t.set(parseInt(s),i)}}return this.negativeMaterialIndices===!0&&console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),t}parseGeometry(e,t,n){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,n);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,n){const s=n.skeletons,r=[],i=e.parents.map(function(u){return ye.Objects.Model[u.ID]});if(i.length===0)return;const o=e.children.reduce(function(u,f){return s[f.ID]!==void 0&&(u=s[f.ID]),u},null);e.children.forEach(function(u){n.morphTargets[u.ID]!==void 0&&r.push(n.morphTargets[u.ID])});const a=i[0],c={};"RotationOrder"in a&&(c.eulerOrder=Qn(a.RotationOrder.value)),"InheritType"in a&&(c.inheritType=parseInt(a.InheritType.value)),"GeometricTranslation"in a&&(c.translation=a.GeometricTranslation.value),"GeometricRotation"in a&&(c.rotation=a.GeometricRotation.value),"GeometricScaling"in a&&(c.scale=a.GeometricScaling.value);const d=ra(c);return this.genGeometry(t,o,r,d)}genGeometry(e,t,n,s){const r=new je;e.attrName&&(r.name=e.attrName);const i=this.parseGeoNode(e,t),o=this.genBuffers(i),a=new nt(o.vertex,3);if(a.applyMatrix4(s),r.setAttribute("position",a),o.colors.length>0&&r.setAttribute("color",new nt(o.colors,3)),t&&(r.setAttribute("skinIndex",new ul(o.weightsIndices,4)),r.setAttribute("skinWeight",new nt(o.vertexWeights,4)),r.FBX_Deformer=t),o.normal.length>0){const c=new We().getNormalMatrix(s),d=new nt(o.normal,3);d.applyNormalMatrix(c),r.setAttribute("normal",d)}if(o.uvs.forEach(function(c,d){const u=d===0?"uv":`uv${d}`;r.setAttribute(u,new nt(o.uvs[d],2))}),i.material&&i.material.mappingType!=="AllSame"){let c=o.materialIndex[0],d=0;if(o.materialIndex.forEach(function(u,f){u!==c&&(r.addGroup(d,f-d,c),c=u,d=f)}),r.groups.length>0){const u=r.groups[r.groups.length-1],f=u.start+u.count;f!==o.materialIndex.length&&r.addGroup(f,o.materialIndex.length-f,c)}r.groups.length===0&&r.addGroup(0,o.materialIndex.length,o.materialIndex[0])}return this.addMorphTargets(r,e,n,s),r}parseGeoNode(e,t){const n={};if(n.vertexPositions=e.Vertices!==void 0?e.Vertices.a:[],n.vertexIndices=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(n.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(n.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(n.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){n.uv=[];let s=0;for(;e.LayerElementUV[s];)e.LayerElementUV[s].UV&&n.uv.push(this.parseUVs(e.LayerElementUV[s])),s++}return n.weightTable={},t!==null&&(n.skeleton=t,t.rawBones.forEach(function(s,r){s.indices.forEach(function(i,o){n.weightTable[i]===void 0&&(n.weightTable[i]=[]),n.weightTable[i].push({id:r,weight:s.weights[o]})})})),n}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let n=0,s=0,r=!1,i=[],o=[],a=[],c=[],d=[],u=[];const f=this;return e.vertexIndices.forEach(function(h,g){let p,m=!1;h<0&&(h=h^-1,m=!0);let A=[],y=[];if(i.push(h*3,h*3+1,h*3+2),e.color){const v=Zn(g,n,h,e.color);a.push(v[0],v[1],v[2])}if(e.skeleton){if(e.weightTable[h]!==void 0&&e.weightTable[h].forEach(function(v){y.push(v.weight),A.push(v.id)}),y.length>4){r||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),r=!0);const v=[0,0,0,0],x=[0,0,0,0];y.forEach(function(w,T){let C=w,E=A[T];x.forEach(function(I,P,B){if(C>I){B[P]=C,C=I;const M=v[P];v[P]=E,E=M}})}),A=v,y=x}for(;y.length<4;)y.push(0),A.push(0);for(let v=0;v<4;++v)d.push(y[v]),u.push(A[v])}if(e.normal){const v=Zn(g,n,h,e.normal);o.push(v[0],v[1],v[2])}e.material&&e.material.mappingType!=="AllSame"&&(p=Zn(g,n,h,e.material)[0],p<0&&(f.negativeMaterialIndices=!0,p=0)),e.uv&&e.uv.forEach(function(v,x){const w=Zn(g,n,h,v);c[x]===void 0&&(c[x]=[]),c[x].push(w[0]),c[x].push(w[1])}),s++,m&&(f.genFace(t,e,i,p,o,a,c,d,u,s),n++,s=0,i=[],o=[],a=[],c=[],d=[],u=[])}),t}getNormalNewell(e){const t=new F(0,0,0);for(let n=0;n<e.length;n++){const s=e[n],r=e[(n+1)%e.length];t.x+=(s.y-r.y)*(s.z+r.z),t.y+=(s.z-r.z)*(s.x+r.x),t.z+=(s.x-r.x)*(s.y+r.y)}return t.normalize(),t}getNormalTangentAndBitangent(e){const t=this.getNormalNewell(e),s=(Math.abs(t.z)>.5?new F(0,1,0):new F(0,0,1)).cross(t).normalize(),r=t.clone().cross(s).normalize();return{normal:t,tangent:s,bitangent:r}}flattenVertex(e,t,n){return new ge(e.dot(t),e.dot(n))}genFace(e,t,n,s,r,i,o,a,c,d){let u;if(d>3){const f=[],h=t.baseVertexPositions||t.vertexPositions;for(let A=0;A<n.length;A+=3)f.push(new F(h[n[A]],h[n[A+1]],h[n[A+2]]));const{tangent:g,bitangent:p}=this.getNormalTangentAndBitangent(f),m=[];for(const A of f)m.push(this.flattenVertex(A,g,p));u=dl.triangulateShape(m,[])}else u=[[0,1,2]];for(const[f,h,g]of u)e.vertex.push(t.vertexPositions[n[f*3]]),e.vertex.push(t.vertexPositions[n[f*3+1]]),e.vertex.push(t.vertexPositions[n[f*3+2]]),e.vertex.push(t.vertexPositions[n[h*3]]),e.vertex.push(t.vertexPositions[n[h*3+1]]),e.vertex.push(t.vertexPositions[n[h*3+2]]),e.vertex.push(t.vertexPositions[n[g*3]]),e.vertex.push(t.vertexPositions[n[g*3+1]]),e.vertex.push(t.vertexPositions[n[g*3+2]]),t.skeleton&&(e.vertexWeights.push(a[f*4]),e.vertexWeights.push(a[f*4+1]),e.vertexWeights.push(a[f*4+2]),e.vertexWeights.push(a[f*4+3]),e.vertexWeights.push(a[h*4]),e.vertexWeights.push(a[h*4+1]),e.vertexWeights.push(a[h*4+2]),e.vertexWeights.push(a[h*4+3]),e.vertexWeights.push(a[g*4]),e.vertexWeights.push(a[g*4+1]),e.vertexWeights.push(a[g*4+2]),e.vertexWeights.push(a[g*4+3]),e.weightsIndices.push(c[f*4]),e.weightsIndices.push(c[f*4+1]),e.weightsIndices.push(c[f*4+2]),e.weightsIndices.push(c[f*4+3]),e.weightsIndices.push(c[h*4]),e.weightsIndices.push(c[h*4+1]),e.weightsIndices.push(c[h*4+2]),e.weightsIndices.push(c[h*4+3]),e.weightsIndices.push(c[g*4]),e.weightsIndices.push(c[g*4+1]),e.weightsIndices.push(c[g*4+2]),e.weightsIndices.push(c[g*4+3])),t.color&&(e.colors.push(i[f*3]),e.colors.push(i[f*3+1]),e.colors.push(i[f*3+2]),e.colors.push(i[h*3]),e.colors.push(i[h*3+1]),e.colors.push(i[h*3+2]),e.colors.push(i[g*3]),e.colors.push(i[g*3+1]),e.colors.push(i[g*3+2])),t.material&&t.material.mappingType!=="AllSame"&&(e.materialIndex.push(s),e.materialIndex.push(s),e.materialIndex.push(s)),t.normal&&(e.normal.push(r[f*3]),e.normal.push(r[f*3+1]),e.normal.push(r[f*3+2]),e.normal.push(r[h*3]),e.normal.push(r[h*3+1]),e.normal.push(r[h*3+2]),e.normal.push(r[g*3]),e.normal.push(r[g*3+1]),e.normal.push(r[g*3+2])),t.uv&&t.uv.forEach(function(p,m){e.uvs[m]===void 0&&(e.uvs[m]=[]),e.uvs[m].push(o[m][f*2]),e.uvs[m].push(o[m][f*2+1]),e.uvs[m].push(o[m][h*2]),e.uvs[m].push(o[m][h*2+1]),e.uvs[m].push(o[m][g*2]),e.uvs[m].push(o[m][g*2+1])})}addMorphTargets(e,t,n,s){if(n.length===0)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const r=this;n.forEach(function(i){i.rawTargets.forEach(function(o){const a=ye.Objects.Geometry[o.geoID];a!==void 0&&r.genMorphGeometry(e,t,a,s,o.name)})})}genMorphGeometry(e,t,n,s,r){const i=t.Vertices!==void 0?t.Vertices.a:[],o=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],a=n.Vertices!==void 0?n.Vertices.a:[],c=n.Indexes!==void 0?n.Indexes.a:[],d=e.attributes.position.count*3,u=new Float32Array(d);for(let p=0;p<c.length;p++){const m=c[p]*3;u[m]=a[p*3],u[m+1]=a[p*3+1],u[m+2]=a[p*3+2]}const f={vertexIndices:o,vertexPositions:u,baseVertexPositions:i},h=this.genBuffers(f),g=new nt(h.vertex,3);g.name=r||n.attrName,g.applyMatrix4(s),e.morphAttributes.position.push(g)}parseNormals(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,s=e.Normals.a;let r=[];return n==="IndexToDirect"&&("NormalIndex"in e?r=e.NormalIndex.a:"NormalsIndex"in e&&(r=e.NormalsIndex.a)),{dataSize:3,buffer:s,indices:r,mappingType:t,referenceType:n}}parseUVs(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,s=e.UV.a;let r=[];return n==="IndexToDirect"&&(r=e.UVIndex.a),{dataSize:2,buffer:s,indices:r,mappingType:t,referenceType:n}}parseVertexColors(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,s=e.Colors.a;let r=[];n==="IndexToDirect"&&(r=e.ColorIndex.a);for(let i=0,o=new Se;i<s.length;i+=4)o.fromArray(s,i),_t.toWorkingColorSpace(o,Ue),o.toArray(s,i);return{dataSize:4,buffer:s,indices:r,mappingType:t,referenceType:n}}parseMaterialIndices(e){const t=e.MappingInformationType,n=e.ReferenceInformationType;if(t==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:n};const s=e.Materials.a,r=[];for(let i=0;i<s.length;++i)r.push(i);return{dataSize:1,buffer:s,indices:r,mappingType:t,referenceType:n}}parseNurbsGeometry(e){const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new je;const n=t-1,s=e.KnotVector.a,r=[],i=e.Points.a;for(let u=0,f=i.length;u<f;u+=4)r.push(new zt().fromArray(i,u));let o,a;if(e.Form==="Closed")r.push(r[0]);else if(e.Form==="Periodic"){o=n,a=s.length-1-o;for(let u=0;u<n;++u)r.push(r[u])}const d=new Tc(n,s,r,o,a).getPoints(r.length*12);return new je().setFromPoints(d)}}class Ic{parse(){const e=[],t=this.parseClips();if(t!==void 0)for(const n in t){const s=t[n],r=this.addClip(s);e.push(r)}return e}parseClips(){if(ye.Objects.AnimationCurve===void 0)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=ye.Objects.AnimationCurveNode,t=new Map;for(const n in e){const s=e[n];if(s.attrName.match(/S|R|T|DeformPercent/)!==null){const r={id:s.id,attr:s.attrName,curves:{}};t.set(r.id,r)}}return t}parseAnimationCurves(e){const t=ye.Objects.AnimationCurve;for(const n in t){const s={id:t[n].id,times:t[n].KeyTime.a.map(Fc),values:t[n].KeyValueFloat.a},r=Ne.get(s.id);if(r!==void 0){const i=r.parents[0].ID,o=r.parents[0].relationship;o.match(/X/)?e.get(i).curves.x=s:o.match(/Y/)?e.get(i).curves.y=s:o.match(/Z/)?e.get(i).curves.z=s:o.match(/DeformPercent/)&&e.has(i)&&(e.get(i).curves.morph=s)}}}parseAnimationLayers(e){const t=ye.Objects.AnimationLayer,n=new Map;for(const s in t){const r=[],i=Ne.get(parseInt(s));i!==void 0&&(i.children.forEach(function(a,c){if(e.has(a.ID)){const d=e.get(a.ID);if(d.curves.x!==void 0||d.curves.y!==void 0||d.curves.z!==void 0){if(r[c]===void 0){const u=Ne.get(a.ID).parents.filter(function(f){return f.relationship!==void 0})[0].ID;if(u!==void 0){const f=ye.Objects.Model[u.toString()];if(f===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",a);return}const h={modelName:f.attrName?Vn.sanitizeNodeName(f.attrName):"",ID:f.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};et.traverse(function(g){g.ID===f.id&&(h.transform=g.matrix,g.userData.transformData&&(h.eulerOrder=g.userData.transformData.eulerOrder))}),h.transform||(h.transform=new he),"PreRotation"in f&&(h.preRotation=f.PreRotation.value),"PostRotation"in f&&(h.postRotation=f.PostRotation.value),r[c]=h}}r[c]&&(r[c][d.attr]=d)}else if(d.curves.morph!==void 0){if(r[c]===void 0){const u=Ne.get(a.ID).parents.filter(function(A){return A.relationship!==void 0})[0].ID,f=Ne.get(u).parents[0].ID,h=Ne.get(f).parents[0].ID,g=Ne.get(h).parents[0].ID,p=ye.Objects.Model[g],m={modelName:p.attrName?Vn.sanitizeNodeName(p.attrName):"",morphName:ye.Objects.Deformer[u].attrName};r[c]=m}r[c][d.attr]=d}}}),n.set(parseInt(s),r))}return n}parseAnimStacks(e){const t=ye.Objects.AnimationStack,n={};for(const s in t){const r=Ne.get(parseInt(s)).children;r.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const i=e.get(r[0].ID);n[s]={name:t[s].attrName,layer:i}}return n}addClip(e){let t=[];const n=this;return e.layer.forEach(function(s){t=t.concat(n.generateTracks(s))}),new vs(e.name,-1,t)}generateTracks(e){const t=[];let n=new F,s=new F;if(e.transform&&e.transform.decompose(n,new ce,s),n=n.toArray(),s=s.toArray(),e.T!==void 0&&Object.keys(e.T.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.T.curves,n,"position");r!==void 0&&t.push(r)}if(e.R!==void 0&&Object.keys(e.R.curves).length>0){const r=this.generateRotationTrack(e.modelName,e.R.curves,e.preRotation,e.postRotation,e.eulerOrder);r!==void 0&&t.push(r)}if(e.S!==void 0&&Object.keys(e.S.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.S.curves,s,"scale");r!==void 0&&t.push(r)}if(e.DeformPercent!==void 0){const r=this.generateMorphTrack(e);r!==void 0&&t.push(r)}return t}generateVectorTrack(e,t,n,s){const r=this.getTimesForAllAxes(t),i=this.getKeyframeTrackValues(r,t,n);return new Wn(e+"."+s,r,i)}generateRotationTrack(e,t,n,s,r){let i,o;if(t.x!==void 0&&t.y!==void 0&&t.z!==void 0){const f=this.interpolateRotations(t.x,t.y,t.z,r);i=f[0],o=f[1]}const a=Qn(0);n!==void 0&&(n=n.map(Ae.degToRad),n.push(a),n=new at().fromArray(n),n=new ce().setFromEuler(n)),s!==void 0&&(s=s.map(Ae.degToRad),s.push(a),s=new at().fromArray(s),s=new ce().setFromEuler(s).invert());const c=new ce,d=new at,u=[];if(!o||!i)return new xn(e+".quaternion",[0],[0]);for(let f=0;f<o.length;f+=3)d.set(o[f],o[f+1],o[f+2],r),c.setFromEuler(d),n!==void 0&&c.premultiply(n),s!==void 0&&c.multiply(s),f>2&&new ce().fromArray(u,(f-3)/3*4).dot(c)<0&&c.set(-c.x,-c.y,-c.z,-c.w),c.toArray(u,f/3*4);return new xn(e+".quaternion",i,u)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,n=t.values.map(function(r){return r/100}),s=et.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new gr(e.modelName+".morphTargetInfluences["+s+"]",t.times,n)}getTimesForAllAxes(e){let t=[];if(e.x!==void 0&&(t=t.concat(e.x.times)),e.y!==void 0&&(t=t.concat(e.y.times)),e.z!==void 0&&(t=t.concat(e.z.times)),t=t.sort(function(n,s){return n-s}),t.length>1){let n=1,s=t[0];for(let r=1;r<t.length;r++){const i=t[r];i!==s&&(t[n]=i,s=i,n++)}t=t.slice(0,n)}return t}getKeyframeTrackValues(e,t,n){const s=n,r=[];let i=-1,o=-1,a=-1;return e.forEach(function(c){if(t.x&&(i=t.x.times.indexOf(c)),t.y&&(o=t.y.times.indexOf(c)),t.z&&(a=t.z.times.indexOf(c)),i!==-1){const d=t.x.values[i];r.push(d),s[0]=d}else r.push(s[0]);if(o!==-1){const d=t.y.values[o];r.push(d),s[1]=d}else r.push(s[1]);if(a!==-1){const d=t.z.values[a];r.push(d),s[2]=d}else r.push(s[2])}),r}interpolateRotations(e,t,n,s){const r=[],i=[];r.push(e.times[0]),i.push(Ae.degToRad(e.values[0])),i.push(Ae.degToRad(t.values[0])),i.push(Ae.degToRad(n.values[0]));for(let o=1;o<e.values.length;o++){const a=[e.values[o-1],t.values[o-1],n.values[o-1]];if(isNaN(a[0])||isNaN(a[1])||isNaN(a[2]))continue;const c=a.map(Ae.degToRad),d=[e.values[o],t.values[o],n.values[o]];if(isNaN(d[0])||isNaN(d[1])||isNaN(d[2]))continue;const u=d.map(Ae.degToRad),f=[d[0]-a[0],d[1]-a[1],d[2]-a[2]],h=[Math.abs(f[0]),Math.abs(f[1]),Math.abs(f[2])];if(h[0]>=180||h[1]>=180||h[2]>=180){const p=Math.max(...h)/180,m=new at(...c,s),A=new at(...u,s),y=new ce().setFromEuler(m),v=new ce().setFromEuler(A);y.dot(v)&&v.set(-v.x,-v.y,-v.z,-v.w);const x=e.times[o-1],w=e.times[o]-x,T=new ce,C=new at;for(let E=0;E<1;E+=1/p)T.copy(y.clone().slerp(v.clone(),E)),r.push(x+E*w),C.setFromQuaternion(T,s),i.push(C.x),i.push(C.y),i.push(C.z)}else r.push(e.times[o]),i.push(Ae.degToRad(e.values[o])),i.push(Ae.degToRad(t.values[o])),i.push(Ae.degToRad(n.values[o]))}return[r,i]}}class Rc{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new sa,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,n=e.split(/[\r\n]+/);return n.forEach(function(s,r){const i=s.match(/^[\s\t]*;/),o=s.match(/^[\s\t]*$/);if(i||o)return;const a=s.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),c=s.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),d=s.match("^\\t{"+(t.currentIndent-1)+"}}");a?t.parseNodeBegin(s,a):c?t.parseNodeProperty(s,c,n[++r]):d?t.popStack():s.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(s)}),this.allNodes}parseNodeBegin(e,t){const n=t[1].trim().replace(/^"/,"").replace(/"$/,""),s=t[2].split(",").map(function(a){return a.trim().replace(/^"/,"").replace(/"$/,"")}),r={name:n},i=this.parseNodeAttr(s),o=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(n,r):n in o?(n==="PoseNode"?o.PoseNode.push(r):o[n].id!==void 0&&(o[n]={},o[n][o[n].id]=o[n]),i.id!==""&&(o[n][i.id]=r)):typeof i.id=="number"?(o[n]={},o[n][i.id]=r):n!=="Properties70"&&(n==="PoseNode"?o[n]=[r]:o[n]=r),typeof i.id=="number"&&(r.id=i.id),i.name!==""&&(r.attrName=i.name),i.type!==""&&(r.attrType=i.type),this.pushStack(r)}parseNodeAttr(e){let t=e[0];e[0]!==""&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let n="",s="";return e.length>1&&(n=e[1].replace(/^(\w+)::/,""),s=e[2]),{id:t,name:n,type:s}}parseNodeProperty(e,t,n){let s=t[1].replace(/^"/,"").replace(/"$/,"").trim(),r=t[2].replace(/^"/,"").replace(/"$/,"").trim();s==="Content"&&r===","&&(r=n.replace(/"/g,"").replace(/,$/,"").trim());const i=this.getCurrentNode();if(i.name==="Properties70"){this.parseNodeSpecialProperty(e,s,r);return}if(s==="C"){const a=r.split(",").slice(1),c=parseInt(a[0]),d=parseInt(a[1]);let u=r.split(",").slice(3);u=u.map(function(f){return f.trim().replace(/^"/,"")}),s="connections",r=[c,d],kc(r,u),i[s]===void 0&&(i[s]=[])}s==="Node"&&(i.id=r),s in i&&Array.isArray(i[s])?i[s].push(r):s!=="a"?i[s]=r:i.a=r,this.setCurrentProp(i,s),s==="a"&&r.slice(-1)!==","&&(i.a=Hs(r))}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,e.slice(-1)!==","&&(t.a=Hs(t.a))}parseNodeSpecialProperty(e,t,n){const s=n.split('",').map(function(d){return d.trim().replace(/^\"/,"").replace(/\s/,"_")}),r=s[0],i=s[1],o=s[2],a=s[3];let c=s[4];switch(i){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":c=parseFloat(c);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":c=Hs(c);break}this.getPrevNode()[r]={type:i,type2:o,flag:a,value:c},this.setCurrentProp(this.getPrevNode(),r)}}class Bc{parse(e){const t=new mi(e);t.skip(23);const n=t.getUint32();if(n<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+n);const s=new sa;for(;!this.endOfContent(t);){const r=this.parseNode(t,n);r!==null&&s.add(r.name,r)}return s}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const n={},s=t>=7500?e.getUint64():e.getUint32(),r=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const i=e.getUint8(),o=e.getString(i);if(s===0)return null;const a=[];for(let f=0;f<r;f++)a.push(this.parseProperty(e));const c=a.length>0?a[0]:"",d=a.length>1?a[1]:"",u=a.length>2?a[2]:"";for(n.singleProperty=r===1&&e.getOffset()===s;s>e.getOffset();){const f=this.parseNode(e,t);f!==null&&this.parseSubNode(o,n,f)}return n.propertyList=a,typeof c=="number"&&(n.id=c),d!==""&&(n.attrName=d),u!==""&&(n.attrType=u),o!==""&&(n.name=o),n}parseSubNode(e,t,n){if(n.singleProperty===!0){const s=n.propertyList[0];Array.isArray(s)?(t[n.name]=n,n.a=s):t[n.name]=s}else if(e==="Connections"&&n.name==="C"){const s=[];n.propertyList.forEach(function(r,i){i!==0&&s.push(r)}),t.connections===void 0&&(t.connections=[]),t.connections.push(s)}else if(n.name==="Properties70")Object.keys(n).forEach(function(r){t[r]=n[r]});else if(e==="Properties70"&&n.name==="P"){let s=n.propertyList[0],r=n.propertyList[1];const i=n.propertyList[2],o=n.propertyList[3];let a;s.indexOf("Lcl ")===0&&(s=s.replace("Lcl ","Lcl_")),r.indexOf("Lcl ")===0&&(r=r.replace("Lcl ","Lcl_")),r==="Color"||r==="ColorRGB"||r==="Vector"||r==="Vector3D"||r.indexOf("Lcl_")===0?a=[n.propertyList[4],n.propertyList[5],n.propertyList[6]]:a=n.propertyList[4],t[s]={type:r,type2:i,flag:o,value:a}}else t[n.name]===void 0?typeof n.id=="number"?(t[n.name]={},t[n.name][n.id]=n):t[n.name]=n:n.name==="PoseNode"?(Array.isArray(t[n.name])||(t[n.name]=[t[n.name]]),t[n.name].push(n)):t[n.name][n.id]===void 0&&(t[n.name][n.id]=n)}parseProperty(e){const t=e.getString(1);let n;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return n=e.getUint32(),e.getArrayBuffer(n);case"S":return n=e.getUint32(),e.getString(n);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const s=e.getUint32(),r=e.getUint32(),i=e.getUint32();if(r===0)switch(t){case"b":case"c":return e.getBooleanArray(s);case"d":return e.getFloat64Array(s);case"f":return e.getFloat32Array(s);case"i":return e.getInt32Array(s);case"l":return e.getInt64Array(s)}const o=mc(new Uint8Array(e.getArrayBuffer(i))),a=new mi(o.buffer);switch(t){case"b":case"c":return a.getBooleanArray(s);case"d":return a.getFloat64Array(s);case"f":return a.getFloat32Array(s);case"i":return a.getInt32Array(s);case"l":return a.getInt64Array(s)}break;default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class mi{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=t!==void 0?t:!0,this._textDecoder=new TextDecoder}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(e){const t=[];for(let n=0;n<e;n++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t&2147483648?(t=~t&4294967295,e=~e&4294967295,e===4294967295&&(t=t+1&4294967295),e=e+1&4294967295,-(t*4294967296+e)):t*4294967296+e}getInt64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t*4294967296+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){const t=this.offset;let n=new Uint8Array(this.dv.buffer,t,e);this.skip(e);const s=n.indexOf(0);return s>=0&&(n=new Uint8Array(this.dv.buffer,t,s)),this._textDecoder.decode(n)}}class sa{add(e,t){this[e]=t}}function Pc(l){const e="Kaydara FBX Binary  \0";return l.byteLength>=e.length&&e===ia(l,0,e.length)}function Dc(l){const e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let t=0;function n(s){const r=l[s-1];return l=l.slice(t+s),t++,r}for(let s=0;s<e.length;++s)if(n(1)===e[s])return!1;return!0}function gi(l){const e=/FBXVersion: (\d+)/,t=l.match(e);if(t)return parseInt(t[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function Fc(l){return l/46186158e3}const Lc=[];function Zn(l,e,t,n){let s;switch(n.mappingType){case"ByPolygonVertex":s=l;break;case"ByPolygon":s=e;break;case"ByVertice":s=t;break;case"AllSame":s=n.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+n.mappingType)}n.referenceType==="IndexToDirect"&&(s=n.indices[s]);const r=s*n.dataSize,i=r+n.dataSize;return Oc(Lc,n.buffer,r,i)}const zs=new at,en=new F;function ra(l){const e=new he,t=new he,n=new he,s=new he,r=new he,i=new he,o=new he,a=new he,c=new he,d=new he,u=new he,f=new he,h=l.inheritType?l.inheritType:0;l.translation&&e.setPosition(en.fromArray(l.translation));const g=Qn(0);if(l.preRotation){const B=l.preRotation.map(Ae.degToRad);B.push(g),t.makeRotationFromEuler(zs.fromArray(B))}if(l.rotation){const B=l.rotation.map(Ae.degToRad);B.push(l.eulerOrder||g),n.makeRotationFromEuler(zs.fromArray(B))}if(l.postRotation){const B=l.postRotation.map(Ae.degToRad);B.push(g),s.makeRotationFromEuler(zs.fromArray(B)),s.invert()}l.scale&&r.scale(en.fromArray(l.scale)),l.scalingOffset&&o.setPosition(en.fromArray(l.scalingOffset)),l.scalingPivot&&i.setPosition(en.fromArray(l.scalingPivot)),l.rotationOffset&&a.setPosition(en.fromArray(l.rotationOffset)),l.rotationPivot&&c.setPosition(en.fromArray(l.rotationPivot)),l.parentMatrixWorld&&(u.copy(l.parentMatrix),d.copy(l.parentMatrixWorld));const p=t.clone().multiply(n).multiply(s),m=new he;m.extractRotation(d);const A=new he;A.copyPosition(d);const y=A.clone().invert().multiply(d),v=m.clone().invert().multiply(y),x=r,w=new he;if(h===0)w.copy(m).multiply(p).multiply(v).multiply(x);else if(h===1)w.copy(m).multiply(v).multiply(p).multiply(x);else{const M=new he().scale(new F().setFromMatrixScale(u)).clone().invert(),D=v.clone().multiply(M);w.copy(m).multiply(p).multiply(D).multiply(x)}const T=c.clone().invert(),C=i.clone().invert();let E=e.clone().multiply(a).multiply(c).multiply(t).multiply(n).multiply(s).multiply(T).multiply(o).multiply(i).multiply(r).multiply(C);const I=new he().copyPosition(E),P=d.clone().multiply(I);return f.copyPosition(P),E=f.clone().multiply(w),E.premultiply(d.invert()),E}function Qn(l){l=l||0;const e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return l===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[l]}function Hs(l){return l.split(",").map(function(t){return parseFloat(t)})}function ia(l,e,t){return e===void 0&&(e=0),t===void 0&&(t=l.byteLength),new TextDecoder().decode(new Uint8Array(l,e,t))}function kc(l,e){for(let t=0,n=l.length,s=e.length;t<s;t++,n++)l[n]=e[t]}function Oc(l,e,t,n){for(let s=t,r=0;s<n;s++,r++)l[r]=e[s];return l}function Ai(l,e){if(e===hl)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),l;if(e===Ar||e===Oo){let t=l.getIndex();if(t===null){const i=[],o=l.getAttribute("position");if(o!==void 0){for(let a=0;a<o.count;a++)i.push(a);l.setIndex(i),t=l.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),l}const n=t.count-2,s=[];if(e===Ar)for(let i=1;i<=n;i++)s.push(t.getX(0)),s.push(t.getX(i)),s.push(t.getX(i+1));else for(let i=0;i<n;i++)i%2===0?(s.push(t.getX(i)),s.push(t.getX(i+1)),s.push(t.getX(i+2))):(s.push(t.getX(i+2)),s.push(t.getX(i+1)),s.push(t.getX(i)));s.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=l.clone();return r.setIndex(s),r.clearGroups(),r}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),l}class oa extends zn{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new Vc(t)}),this.register(function(t){return new Wc(t)}),this.register(function(t){return new Jc(t)}),this.register(function(t){return new $c(t)}),this.register(function(t){return new eu(t)}),this.register(function(t){return new Qc(t)}),this.register(function(t){return new Gc(t)}),this.register(function(t){return new qc(t)}),this.register(function(t){return new Xc(t)}),this.register(function(t){return new Hc(t)}),this.register(function(t){return new Kc(t)}),this.register(function(t){return new jc(t)}),this.register(function(t){return new Zc(t)}),this.register(function(t){return new Yc(t)}),this.register(function(t){return new Nc(t)}),this.register(function(t){return new tu(t)}),this.register(function(t){return new nu(t)})}load(e,t,n,s){const r=this;let i;if(this.resourcePath!=="")i=this.resourcePath;else if(this.path!==""){const c=pn.extractUrlBase(e);i=pn.resolveURL(c,this.path)}else i=pn.extractUrlBase(e);this.manager.itemStart(e);const o=function(c){s?s(c):console.error(c),r.manager.itemError(e),r.manager.itemEnd(e)},a=new Bs(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(c){try{r.parse(c,i,function(d){t(d),r.manager.itemEnd(e)},o)}catch(d){o(d)}},n,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,s){let r;const i={},o={},a=new TextDecoder;if(typeof e=="string")r=JSON.parse(e);else if(e instanceof ArrayBuffer)if(a.decode(new Uint8Array(e,0,4))===aa){try{i[xe.KHR_BINARY_GLTF]=new su(e)}catch(u){s&&s(u);return}r=JSON.parse(i[xe.KHR_BINARY_GLTF].content)}else r=JSON.parse(a.decode(e));else r=e;if(r.asset===void 0||r.asset.version[0]<2){s&&s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new gu(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let d=0;d<this.pluginCallbacks.length;d++){const u=this.pluginCallbacks[d](c);u.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),o[u.name]=u,i[u.name]=!0}if(r.extensionsUsed)for(let d=0;d<r.extensionsUsed.length;++d){const u=r.extensionsUsed[d],f=r.extensionsRequired||[];switch(u){case xe.KHR_MATERIALS_UNLIT:i[u]=new zc;break;case xe.KHR_DRACO_MESH_COMPRESSION:i[u]=new ru(r,this.dracoLoader);break;case xe.KHR_TEXTURE_TRANSFORM:i[u]=new iu;break;case xe.KHR_MESH_QUANTIZATION:i[u]=new ou;break;default:f.indexOf(u)>=0&&o[u]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+u+'".')}}c.setExtensions(i),c.setPlugins(o),c.parse(n,s)}parseAsync(e,t){const n=this;return new Promise(function(s,r){n.parse(e,t,s,r)})}}function Uc(){let l={};return{get:function(e){return l[e]},add:function(e,t){l[e]=t},remove:function(e){delete l[e]},removeAll:function(){l={}}}}const xe={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Nc{constructor(e){this.parser=e,this.name=xe.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,s=t.length;n<s;n++){const r=t[n];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let s=t.cache.get(n);if(s)return s;const r=t.json,a=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let c;const d=new Se(16777215);a.color!==void 0&&d.setRGB(a.color[0],a.color[1],a.color[2],Pt);const u=a.range!==void 0?a.range:0;switch(a.type){case"directional":c=new Pr(d),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new ys(d),c.distance=u;break;case"spot":c=new ko(d),c.distance=u,a.spot=a.spot||{},a.spot.innerConeAngle=a.spot.innerConeAngle!==void 0?a.spot.innerConeAngle:0,a.spot.outerConeAngle=a.spot.outerConeAngle!==void 0?a.spot.outerConeAngle:Math.PI/4,c.angle=a.spot.outerConeAngle,c.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return c.position.set(0,0,0),Rt(c,a),a.intensity!==void 0&&(c.intensity=a.intensity),c.name=t.createUniqueName(a.name||"light_"+e),s=Promise.resolve(c),t.cache.add(n,s),s}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,n=this.parser,r=n.json.nodes[e],o=(r.extensions&&r.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(a){return n._getNodeRef(t.cache,o,a)})}}class zc{constructor(){this.name=xe.KHR_MATERIALS_UNLIT}getMaterialType(){return rt}extendParams(e,t,n){const s=[];e.color=new Se(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const i=r.baseColorFactor;e.color.setRGB(i[0],i[1],i[2],Pt),e.opacity=i[3]}r.baseColorTexture!==void 0&&s.push(n.assignTexture(e,"map",r.baseColorTexture,Ue))}return Promise.all(s)}}class Hc{constructor(e){this.parser=e,this.name=xe.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=s.extensions[this.name].emissiveStrength;return r!==void 0&&(t.emissiveIntensity=r),Promise.resolve()}}class Vc{constructor(e){this.parser=e,this.name=xe.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:bt}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],i=s.extensions[this.name];if(i.clearcoatFactor!==void 0&&(t.clearcoat=i.clearcoatFactor),i.clearcoatTexture!==void 0&&r.push(n.assignTexture(t,"clearcoatMap",i.clearcoatTexture)),i.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=i.clearcoatRoughnessFactor),i.clearcoatRoughnessTexture!==void 0&&r.push(n.assignTexture(t,"clearcoatRoughnessMap",i.clearcoatRoughnessTexture)),i.clearcoatNormalTexture!==void 0&&(r.push(n.assignTexture(t,"clearcoatNormalMap",i.clearcoatNormalTexture)),i.clearcoatNormalTexture.scale!==void 0)){const o=i.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new ge(o,o)}return Promise.all(r)}}class Wc{constructor(e){this.parser=e,this.name=xe.KHR_MATERIALS_DISPERSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:bt}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=s.extensions[this.name];return t.dispersion=r.dispersion!==void 0?r.dispersion:0,Promise.resolve()}}class jc{constructor(e){this.parser=e,this.name=xe.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:bt}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],i=s.extensions[this.name];return i.iridescenceFactor!==void 0&&(t.iridescence=i.iridescenceFactor),i.iridescenceTexture!==void 0&&r.push(n.assignTexture(t,"iridescenceMap",i.iridescenceTexture)),i.iridescenceIor!==void 0&&(t.iridescenceIOR=i.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),i.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=i.iridescenceThicknessMinimum),i.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=i.iridescenceThicknessMaximum),i.iridescenceThicknessTexture!==void 0&&r.push(n.assignTexture(t,"iridescenceThicknessMap",i.iridescenceThicknessTexture)),Promise.all(r)}}class Qc{constructor(e){this.parser=e,this.name=xe.KHR_MATERIALS_SHEEN}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:bt}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new Se(0,0,0),t.sheenRoughness=0,t.sheen=1;const i=s.extensions[this.name];if(i.sheenColorFactor!==void 0){const o=i.sheenColorFactor;t.sheenColor.setRGB(o[0],o[1],o[2],Pt)}return i.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=i.sheenRoughnessFactor),i.sheenColorTexture!==void 0&&r.push(n.assignTexture(t,"sheenColorMap",i.sheenColorTexture,Ue)),i.sheenRoughnessTexture!==void 0&&r.push(n.assignTexture(t,"sheenRoughnessMap",i.sheenRoughnessTexture)),Promise.all(r)}}class Gc{constructor(e){this.parser=e,this.name=xe.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:bt}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],i=s.extensions[this.name];return i.transmissionFactor!==void 0&&(t.transmission=i.transmissionFactor),i.transmissionTexture!==void 0&&r.push(n.assignTexture(t,"transmissionMap",i.transmissionTexture)),Promise.all(r)}}class qc{constructor(e){this.parser=e,this.name=xe.KHR_MATERIALS_VOLUME}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:bt}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],i=s.extensions[this.name];t.thickness=i.thicknessFactor!==void 0?i.thicknessFactor:0,i.thicknessTexture!==void 0&&r.push(n.assignTexture(t,"thicknessMap",i.thicknessTexture)),t.attenuationDistance=i.attenuationDistance||1/0;const o=i.attenuationColor||[1,1,1];return t.attenuationColor=new Se().setRGB(o[0],o[1],o[2],Pt),Promise.all(r)}}class Xc{constructor(e){this.parser=e,this.name=xe.KHR_MATERIALS_IOR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:bt}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=s.extensions[this.name];return t.ior=r.ior!==void 0?r.ior:1.5,Promise.resolve()}}class Kc{constructor(e){this.parser=e,this.name=xe.KHR_MATERIALS_SPECULAR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:bt}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],i=s.extensions[this.name];t.specularIntensity=i.specularFactor!==void 0?i.specularFactor:1,i.specularTexture!==void 0&&r.push(n.assignTexture(t,"specularIntensityMap",i.specularTexture));const o=i.specularColorFactor||[1,1,1];return t.specularColor=new Se().setRGB(o[0],o[1],o[2],Pt),i.specularColorTexture!==void 0&&r.push(n.assignTexture(t,"specularColorMap",i.specularColorTexture,Ue)),Promise.all(r)}}class Yc{constructor(e){this.parser=e,this.name=xe.EXT_MATERIALS_BUMP}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:bt}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],i=s.extensions[this.name];return t.bumpScale=i.bumpFactor!==void 0?i.bumpFactor:1,i.bumpTexture!==void 0&&r.push(n.assignTexture(t,"bumpMap",i.bumpTexture)),Promise.all(r)}}class Zc{constructor(e){this.parser=e,this.name=xe.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:bt}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],i=s.extensions[this.name];return i.anisotropyStrength!==void 0&&(t.anisotropy=i.anisotropyStrength),i.anisotropyRotation!==void 0&&(t.anisotropyRotation=i.anisotropyRotation),i.anisotropyTexture!==void 0&&r.push(n.assignTexture(t,"anisotropyMap",i.anisotropyTexture)),Promise.all(r)}}class Jc{constructor(e){this.parser=e,this.name=xe.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,s=n.textures[e];if(!s.extensions||!s.extensions[this.name])return null;const r=s.extensions[this.name],i=t.options.ktx2Loader;if(!i){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,i)}}class $c{constructor(e){this.parser=e,this.name=xe.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,s=n.json,r=s.textures[e];if(!r.extensions||!r.extensions[t])return null;const i=r.extensions[t],o=s.images[i.source];let a=n.textureLoader;if(o.uri){const c=n.options.manager.getHandler(o.uri);c!==null&&(a=c)}return this.detectSupport().then(function(c){if(c)return n.loadTextureImage(e,i.source,a);if(s.extensionsRequired&&s.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class eu{constructor(e){this.parser=e,this.name=xe.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,s=n.json,r=s.textures[e];if(!r.extensions||!r.extensions[t])return null;const i=r.extensions[t],o=s.images[i.source];let a=n.textureLoader;if(o.uri){const c=n.options.manager.getHandler(o.uri);c!==null&&(a=c)}return this.detectSupport().then(function(c){if(c)return n.loadTextureImage(e,i.source,a);if(s.extensionsRequired&&s.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class tu{constructor(e){this.name=xe.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const s=n.extensions[this.name],r=this.parser.getDependency("buffer",s.buffer),i=this.parser.options.meshoptDecoder;if(!i||!i.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then(function(o){const a=s.byteOffset||0,c=s.byteLength||0,d=s.count,u=s.byteStride,f=new Uint8Array(o,a,c);return i.decodeGltfBufferAsync?i.decodeGltfBufferAsync(d,u,f,s.mode,s.filter).then(function(h){return h.buffer}):i.ready.then(function(){const h=new ArrayBuffer(d*u);return i.decodeGltfBuffer(new Uint8Array(h),d,u,f,s.mode,s.filter),h})})}else return null}}class nu{constructor(e){this.name=xe.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,n=t.nodes[e];if(!n.extensions||!n.extensions[this.name]||n.mesh===void 0)return null;const s=t.meshes[n.mesh];for(const c of s.primitives)if(c.mode!==ft.TRIANGLES&&c.mode!==ft.TRIANGLE_STRIP&&c.mode!==ft.TRIANGLE_FAN&&c.mode!==void 0)return null;const i=n.extensions[this.name].attributes,o=[],a={};for(const c in i)o.push(this.parser.getDependency("accessor",i[c]).then(d=>(a[c]=d,a[c])));return o.length<1?null:(o.push(this.parser.createNodeMesh(e)),Promise.all(o).then(c=>{const d=c.pop(),u=d.isGroup?d.children:[d],f=c[0].count,h=[];for(const g of u){const p=new he,m=new F,A=new ce,y=new F(1,1,1),v=new fl(g.geometry,g.material,f);for(let x=0;x<f;x++)a.TRANSLATION&&m.fromBufferAttribute(a.TRANSLATION,x),a.ROTATION&&A.fromBufferAttribute(a.ROTATION,x),a.SCALE&&y.fromBufferAttribute(a.SCALE,x),v.setMatrixAt(x,p.compose(m,A,y));for(const x in a)if(x==="_COLOR_0"){const w=a[x];v.instanceColor=new Uo(w.array,w.itemSize,w.normalized)}else x!=="TRANSLATION"&&x!=="ROTATION"&&x!=="SCALE"&&g.geometry.setAttribute(x,a[x]);Ze.prototype.copy.call(v,g),this.parser.assignFinalMaterial(v),h.push(v)}return d.isGroup?(d.clear(),d.add(...h),d):h[0]}))}}const aa="glTF",Mn=12,yi={JSON:1313821514,BIN:5130562};class su{constructor(e){this.name=xe.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Mn),n=new TextDecoder;if(this.header={magic:n.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==aa)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const s=this.header.length-Mn,r=new DataView(e,Mn);let i=0;for(;i<s;){const o=r.getUint32(i,!0);i+=4;const a=r.getUint32(i,!0);if(i+=4,a===yi.JSON){const c=new Uint8Array(e,Mn+i,o);this.content=n.decode(c)}else if(a===yi.BIN){const c=Mn+i;this.body=e.slice(c,c+o)}i+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class ru{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=xe.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,s=this.dracoLoader,r=e.extensions[this.name].bufferView,i=e.extensions[this.name].attributes,o={},a={},c={};for(const d in i){const u=Sr[d]||d.toLowerCase();o[u]=i[d]}for(const d in e.attributes){const u=Sr[d]||d.toLowerCase();if(i[d]!==void 0){const f=n.accessors[e.attributes[d]],h=gn[f.componentType];c[u]=h.name,a[u]=f.normalized===!0}}return t.getDependency("bufferView",r).then(function(d){return new Promise(function(u,f){s.decodeDracoFile(d,function(h){for(const g in h.attributes){const p=h.attributes[g],m=a[g];m!==void 0&&(p.normalized=m)}u(h)},o,c,Pt,f)})})}}class iu{constructor(){this.name=xe.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class ou{constructor(){this.name=xe.KHR_MESH_QUANTIZATION}}class la extends Cl{constructor(e,t,n,s){super(e,t,n,s)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,s=this.valueSize,r=e*s*3+s;for(let i=0;i!==s;i++)t[i]=n[r+i];return t}interpolate_(e,t,n,s){const r=this.resultBuffer,i=this.sampleValues,o=this.valueSize,a=o*2,c=o*3,d=s-t,u=(n-t)/d,f=u*u,h=f*u,g=e*c,p=g-c,m=-2*h+3*f,A=h-f,y=1-m,v=A-f+u;for(let x=0;x!==o;x++){const w=i[p+x+o],T=i[p+x+a]*d,C=i[g+x+o],E=i[g+x]*d;r[x]=y*w+v*T+m*C+A*E}return r}}const au=new ce;class lu extends la{interpolate_(e,t,n,s){const r=super.interpolate_(e,t,n,s);return au.fromArray(r).normalize().toArray(r),r}}const ft={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},gn={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},vi={9728:zo,9729:yr,9984:Al,9985:yl,9986:vl,9987:No},xi={33071:pr,33648:xl,10497:Hn},Vs={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Sr={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Lt={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},cu={CUBICSPLINE:void 0,LINEAR:Wo,STEP:Sl},Ws={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function uu(l){return l.DefaultMaterial===void 0&&(l.DefaultMaterial=new xs({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Ss})),l.DefaultMaterial}function Ht(l,e,t){for(const n in t.extensions)l[n]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[n]=t.extensions[n])}function Rt(l,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(l.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function du(l,e,t){let n=!1,s=!1,r=!1;for(let c=0,d=e.length;c<d;c++){const u=e[c];if(u.POSITION!==void 0&&(n=!0),u.NORMAL!==void 0&&(s=!0),u.COLOR_0!==void 0&&(r=!0),n&&s&&r)break}if(!n&&!s&&!r)return Promise.resolve(l);const i=[],o=[],a=[];for(let c=0,d=e.length;c<d;c++){const u=e[c];if(n){const f=u.POSITION!==void 0?t.getDependency("accessor",u.POSITION):l.attributes.position;i.push(f)}if(s){const f=u.NORMAL!==void 0?t.getDependency("accessor",u.NORMAL):l.attributes.normal;o.push(f)}if(r){const f=u.COLOR_0!==void 0?t.getDependency("accessor",u.COLOR_0):l.attributes.color;a.push(f)}}return Promise.all([Promise.all(i),Promise.all(o),Promise.all(a)]).then(function(c){const d=c[0],u=c[1],f=c[2];return n&&(l.morphAttributes.position=d),s&&(l.morphAttributes.normal=u),r&&(l.morphAttributes.color=f),l.morphTargetsRelative=!0,l})}function hu(l,e){if(l.updateMorphTargets(),e.weights!==void 0)for(let t=0,n=e.weights.length;t<n;t++)l.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(l.morphTargetInfluences.length===t.length){l.morphTargetDictionary={};for(let n=0,s=t.length;n<s;n++)l.morphTargetDictionary[t[n]]=n}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function fu(l){let e;const t=l.extensions&&l.extensions[xe.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+js(t.attributes):e=l.indices+":"+js(l.attributes)+":"+l.mode,l.targets!==void 0)for(let n=0,s=l.targets.length;n<s;n++)e+=":"+js(l.targets[n]);return e}function js(l){let e="";const t=Object.keys(l).sort();for(let n=0,s=t.length;n<s;n++)e+=t[n]+":"+l[t[n]]+";";return e}function wr(l){switch(l){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function pu(l){return l.search(/\.jpe?g($|\?)/i)>0||l.search(/^data\:image\/jpeg/)===0?"image/jpeg":l.search(/\.webp($|\?)/i)>0||l.search(/^data\:image\/webp/)===0?"image/webp":l.search(/\.ktx2($|\?)/i)>0||l.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"}const mu=new he;class gu{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new Uc,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,s=-1,r=!1,i=-1;if(typeof navigator<"u"){const o=navigator.userAgent;n=/^((?!chrome|android).)*safari/i.test(o)===!0;const a=o.match(/Version\/(\d+)/);s=n&&a?parseInt(a[1],10):-1,r=o.indexOf("Firefox")>-1,i=r?o.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||n&&s<17||r&&i<98?this.textureLoader=new Br(this.options.manager):this.textureLoader=new pl(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Bs(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,s=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(i){return i._markDefs&&i._markDefs()}),Promise.all(this._invokeAll(function(i){return i.beforeRoot&&i.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(i){const o={scene:i[0][s.scene||0],scenes:i[0],animations:i[1],cameras:i[2],asset:s.asset,parser:n,userData:{}};return Ht(r,o,s),Rt(o,s),Promise.all(n._invokeAll(function(a){return a.afterRoot&&a.afterRoot(o)})).then(function(){for(const a of o.scenes)a.updateMatrixWorld();e(o)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let s=0,r=t.length;s<r;s++){const i=t[s].joints;for(let o=0,a=i.length;o<a;o++)e[i[o]].isBone=!0}for(let s=0,r=e.length;s<r;s++){const i=e[s];i.mesh!==void 0&&(this._addNodeRef(this.meshCache,i.mesh),i.skin!==void 0&&(n[i.mesh].isSkinnedMesh=!0)),i.camera!==void 0&&this._addNodeRef(this.cameraCache,i.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const s=n.clone(),r=(i,o)=>{const a=this.associations.get(i);a!=null&&this.associations.set(o,a);for(const[c,d]of i.children.entries())r(d,o.children[c])};return r(n,s),s.name+="_instance_"+e.uses[t]++,s}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const s=e(t[n]);if(s)return s}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let s=0;s<t.length;s++){const r=e(t[s]);r&&n.push(r)}return n}getDependency(e,t){const n=e+":"+t;let s=this.cache.get(n);if(!s){switch(e){case"scene":s=this.loadScene(t);break;case"node":s=this._invokeOne(function(r){return r.loadNode&&r.loadNode(t)});break;case"mesh":s=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(t)});break;case"accessor":s=this.loadAccessor(t);break;case"bufferView":s=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(t)});break;case"buffer":s=this.loadBuffer(t);break;case"material":s=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(t)});break;case"texture":s=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(t)});break;case"skin":s=this.loadSkin(t);break;case"animation":s=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(t)});break;case"camera":s=this.loadCamera(t);break;default:if(s=this._invokeOne(function(r){return r!=this&&r.getDependency&&r.getDependency(e,t)}),!s)throw new Error("Unknown type: "+e);break}this.cache.add(n,s)}return s}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,s=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(s.map(function(r,i){return n.getDependency(e,i)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],n=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[xe.KHR_BINARY_GLTF].body);const s=this.options;return new Promise(function(r,i){n.load(pn.resolveURL(t.uri,s.path),r,void 0,function(){i(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(n){const s=t.byteLength||0,r=t.byteOffset||0;return n.slice(r,r+s)})}loadAccessor(e){const t=this,n=this.json,s=this.json.accessors[e];if(s.bufferView===void 0&&s.sparse===void 0){const i=Vs[s.type],o=gn[s.componentType],a=s.normalized===!0,c=new o(s.count*i);return Promise.resolve(new He(c,i,a))}const r=[];return s.bufferView!==void 0?r.push(this.getDependency("bufferView",s.bufferView)):r.push(null),s.sparse!==void 0&&(r.push(this.getDependency("bufferView",s.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",s.sparse.values.bufferView))),Promise.all(r).then(function(i){const o=i[0],a=Vs[s.type],c=gn[s.componentType],d=c.BYTES_PER_ELEMENT,u=d*a,f=s.byteOffset||0,h=s.bufferView!==void 0?n.bufferViews[s.bufferView].byteStride:void 0,g=s.normalized===!0;let p,m;if(h&&h!==u){const A=Math.floor(f/h),y="InterleavedBuffer:"+s.bufferView+":"+s.componentType+":"+A+":"+s.count;let v=t.cache.get(y);v||(p=new c(o,A*h,s.count*h/d),v=new ml(p,h/d),t.cache.add(y,v)),m=new wl(v,a,f%h/d,g)}else o===null?p=new c(s.count*a):p=new c(o,f,s.count*a),m=new He(p,a,g);if(s.sparse!==void 0){const A=Vs.SCALAR,y=gn[s.sparse.indices.componentType],v=s.sparse.indices.byteOffset||0,x=s.sparse.values.byteOffset||0,w=new y(i[1],v,s.sparse.count*A),T=new c(i[2],x,s.sparse.count*a);o!==null&&(m=new He(m.array.slice(),m.itemSize,m.normalized)),m.normalized=!1;for(let C=0,E=w.length;C<E;C++){const I=w[C];if(m.setX(I,T[C*a]),a>=2&&m.setY(I,T[C*a+1]),a>=3&&m.setZ(I,T[C*a+2]),a>=4&&m.setW(I,T[C*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}m.normalized=g}return m})}loadTexture(e){const t=this.json,n=this.options,r=t.textures[e].source,i=t.images[r];let o=this.textureLoader;if(i.uri){const a=n.manager.getHandler(i.uri);a!==null&&(o=a)}return this.loadTextureImage(e,r,o)}loadTextureImage(e,t,n){const s=this,r=this.json,i=r.textures[e],o=r.images[t],a=(o.uri||o.bufferView)+":"+i.sampler;if(this.textureCache[a])return this.textureCache[a];const c=this.loadImageSource(t,n).then(function(d){d.flipY=!1,d.name=i.name||o.name||"",d.name===""&&typeof o.uri=="string"&&o.uri.startsWith("data:image/")===!1&&(d.name=o.uri);const f=(r.samplers||{})[i.sampler]||{};return d.magFilter=vi[f.magFilter]||yr,d.minFilter=vi[f.minFilter]||No,d.wrapS=xi[f.wrapS]||Hn,d.wrapT=xi[f.wrapT]||Hn,d.generateMipmaps=!d.isCompressedTexture&&d.minFilter!==zo&&d.minFilter!==yr,s.associations.set(d,{textures:e}),d}).catch(function(){return null});return this.textureCache[a]=c,c}loadImageSource(e,t){const n=this,s=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(u=>u.clone());const i=s.images[e],o=self.URL||self.webkitURL;let a=i.uri||"",c=!1;if(i.bufferView!==void 0)a=n.getDependency("bufferView",i.bufferView).then(function(u){c=!0;const f=new Blob([u],{type:i.mimeType});return a=o.createObjectURL(f),a});else if(i.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const d=Promise.resolve(a).then(function(u){return new Promise(function(f,h){let g=f;t.isImageBitmapLoader===!0&&(g=function(p){const m=new mr(p);m.needsUpdate=!0,f(m)}),t.load(pn.resolveURL(u,r.path),g,void 0,h)})}).then(function(u){return c===!0&&o.revokeObjectURL(a),Rt(u,i),u.userData.mimeType=i.mimeType||pu(i.uri),u}).catch(function(u){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),u});return this.sourceCache[e]=d,d}assignTexture(e,t,n,s){const r=this;return this.getDependency("texture",n.index).then(function(i){if(!i)return null;if(n.texCoord!==void 0&&n.texCoord>0&&(i=i.clone(),i.channel=n.texCoord),r.extensions[xe.KHR_TEXTURE_TRANSFORM]){const o=n.extensions!==void 0?n.extensions[xe.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const a=r.associations.get(i);i=r.extensions[xe.KHR_TEXTURE_TRANSFORM].extendTexture(i,o),r.associations.set(i,a)}}return s!==void 0&&(i.colorSpace=s),e[t]=i,i})}assignFinalMaterial(e){const t=e.geometry;let n=e.material;const s=t.attributes.tangent===void 0,r=t.attributes.color!==void 0,i=t.attributes.normal===void 0;if(e.isPoints){const o="PointsMaterial:"+n.uuid;let a=this.cache.get(o);a||(a=new Ho,fs.prototype.copy.call(a,n),a.color.copy(n.color),a.map=n.map,a.sizeAttenuation=!1,this.cache.add(o,a)),n=a}else if(e.isLine){const o="LineBasicMaterial:"+n.uuid;let a=this.cache.get(o);a||(a=new _n,fs.prototype.copy.call(a,n),a.color.copy(n.color),a.map=n.map,this.cache.add(o,a)),n=a}if(s||r||i){let o="ClonedMaterial:"+n.uuid+":";s&&(o+="derivative-tangents:"),r&&(o+="vertex-colors:"),i&&(o+="flat-shading:");let a=this.cache.get(o);a||(a=n.clone(),r&&(a.vertexColors=!0),i&&(a.flatShading=!0),s&&(a.normalScale&&(a.normalScale.y*=-1),a.clearcoatNormalScale&&(a.clearcoatNormalScale.y*=-1)),this.cache.add(o,a),this.associations.set(a,this.associations.get(n))),n=a}e.material=n}getMaterialType(){return xs}loadMaterial(e){const t=this,n=this.json,s=this.extensions,r=n.materials[e];let i;const o={},a=r.extensions||{},c=[];if(a[xe.KHR_MATERIALS_UNLIT]){const u=s[xe.KHR_MATERIALS_UNLIT];i=u.getMaterialType(),c.push(u.extendParams(o,r,t))}else{const u=r.pbrMetallicRoughness||{};if(o.color=new Se(1,1,1),o.opacity=1,Array.isArray(u.baseColorFactor)){const f=u.baseColorFactor;o.color.setRGB(f[0],f[1],f[2],Pt),o.opacity=f[3]}u.baseColorTexture!==void 0&&c.push(t.assignTexture(o,"map",u.baseColorTexture,Ue)),o.metalness=u.metallicFactor!==void 0?u.metallicFactor:1,o.roughness=u.roughnessFactor!==void 0?u.roughnessFactor:1,u.metallicRoughnessTexture!==void 0&&(c.push(t.assignTexture(o,"metalnessMap",u.metallicRoughnessTexture)),c.push(t.assignTexture(o,"roughnessMap",u.metallicRoughnessTexture))),i=this._invokeOne(function(f){return f.getMaterialType&&f.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(f){return f.extendMaterialParams&&f.extendMaterialParams(e,o)})))}r.doubleSided===!0&&(o.side=Sn);const d=r.alphaMode||Ws.OPAQUE;if(d===Ws.BLEND?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,d===Ws.MASK&&(o.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&i!==rt&&(c.push(t.assignTexture(o,"normalMap",r.normalTexture)),o.normalScale=new ge(1,1),r.normalTexture.scale!==void 0)){const u=r.normalTexture.scale;o.normalScale.set(u,u)}if(r.occlusionTexture!==void 0&&i!==rt&&(c.push(t.assignTexture(o,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&i!==rt){const u=r.emissiveFactor;o.emissive=new Se().setRGB(u[0],u[1],u[2],Pt)}return r.emissiveTexture!==void 0&&i!==rt&&c.push(t.assignTexture(o,"emissiveMap",r.emissiveTexture,Ue)),Promise.all(c).then(function(){const u=new i(o);return r.name&&(u.name=r.name),Rt(u,r),t.associations.set(u,{materials:e}),r.extensions&&Ht(s,u,r),u})}createUniqueName(e){const t=Vn.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,n=this.extensions,s=this.primitiveCache;function r(o){return n[xe.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,t).then(function(a){return Si(a,o,t)})}const i=[];for(let o=0,a=e.length;o<a;o++){const c=e[o],d=fu(c),u=s[d];if(u)i.push(u.promise);else{let f;c.extensions&&c.extensions[xe.KHR_DRACO_MESH_COMPRESSION]?f=r(c):f=Si(new je,c,t),s[d]={primitive:c,promise:f},i.push(f)}}return Promise.all(i)}loadMesh(e){const t=this,n=this.json,s=this.extensions,r=n.meshes[e],i=r.primitives,o=[];for(let a=0,c=i.length;a<c;a++){const d=i[a].material===void 0?uu(this.cache):this.getDependency("material",i[a].material);o.push(d)}return o.push(t.loadGeometries(i)),Promise.all(o).then(function(a){const c=a.slice(0,a.length-1),d=a[a.length-1],u=[];for(let h=0,g=d.length;h<g;h++){const p=d[h],m=i[h];let A;const y=c[h];if(m.mode===ft.TRIANGLES||m.mode===ft.TRIANGLE_STRIP||m.mode===ft.TRIANGLE_FAN||m.mode===void 0)A=r.isSkinnedMesh===!0?new Dr(p,y):new Oe(p,y),A.isSkinnedMesh===!0&&A.normalizeSkinWeights(),m.mode===ft.TRIANGLE_STRIP?A.geometry=Ai(A.geometry,Oo):m.mode===ft.TRIANGLE_FAN&&(A.geometry=Ai(A.geometry,Ar));else if(m.mode===ft.LINES)A=new Ds(p,y);else if(m.mode===ft.LINE_STRIP)A=new Fr(p,y);else if(m.mode===ft.LINE_LOOP)A=new gl(p,y);else if(m.mode===ft.POINTS)A=new Vo(p,y);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+m.mode);Object.keys(A.geometry.morphAttributes).length>0&&hu(A,r),A.name=t.createUniqueName(r.name||"mesh_"+e),Rt(A,r),m.extensions&&Ht(s,A,m),t.assignFinalMaterial(A),u.push(A)}for(let h=0,g=u.length;h<g;h++)t.associations.set(u[h],{meshes:e,primitives:h});if(u.length===1)return r.extensions&&Ht(s,u[0],r),u[0];const f=new Je;r.extensions&&Ht(s,f,r),t.associations.set(f,{meshes:e});for(let h=0,g=u.length;h<g;h++)f.add(u[h]);return f})}loadCamera(e){let t;const n=this.json.cameras[e],s=n[n.type];if(!s){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return n.type==="perspective"?t=new Ps(Ae.radToDeg(s.yfov),s.aspectRatio||1,s.znear||1,s.zfar||2e6):n.type==="orthographic"&&(t=new Lr(-s.xmag,s.xmag,s.ymag,-s.ymag,s.znear,s.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),Rt(t,n),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],n=[];for(let s=0,r=t.joints.length;s<r;s++)n.push(this._loadNodeShallow(t.joints[s]));return t.inverseBindMatrices!==void 0?n.push(this.getDependency("accessor",t.inverseBindMatrices)):n.push(null),Promise.all(n).then(function(s){const r=s.pop(),i=s,o=[],a=[];for(let c=0,d=i.length;c<d;c++){const u=i[c];if(u){o.push(u);const f=new he;r!==null&&f.fromArray(r.array,c*16),a.push(f)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[c])}return new Cn(o,a)})}loadAnimation(e){const t=this.json,n=this,s=t.animations[e],r=s.name?s.name:"animation_"+e,i=[],o=[],a=[],c=[],d=[];for(let u=0,f=s.channels.length;u<f;u++){const h=s.channels[u],g=s.samplers[h.sampler],p=h.target,m=p.node,A=s.parameters!==void 0?s.parameters[g.input]:g.input,y=s.parameters!==void 0?s.parameters[g.output]:g.output;p.node!==void 0&&(i.push(this.getDependency("node",m)),o.push(this.getDependency("accessor",A)),a.push(this.getDependency("accessor",y)),c.push(g),d.push(p))}return Promise.all([Promise.all(i),Promise.all(o),Promise.all(a),Promise.all(c),Promise.all(d)]).then(function(u){const f=u[0],h=u[1],g=u[2],p=u[3],m=u[4],A=[];for(let y=0,v=f.length;y<v;y++){const x=f[y],w=h[y],T=g[y],C=p[y],E=m[y];if(x===void 0)continue;x.updateMatrix&&x.updateMatrix();const I=n._createAnimationTracks(x,w,T,C,E);if(I)for(let P=0;P<I.length;P++)A.push(I[P])}return new vs(r,void 0,A)})}createNodeMesh(e){const t=this.json,n=this,s=t.nodes[e];return s.mesh===void 0?null:n.getDependency("mesh",s.mesh).then(function(r){const i=n._getNodeRef(n.meshCache,s.mesh,r);return s.weights!==void 0&&i.traverse(function(o){if(o.isMesh)for(let a=0,c=s.weights.length;a<c;a++)o.morphTargetInfluences[a]=s.weights[a]}),i})}loadNode(e){const t=this.json,n=this,s=t.nodes[e],r=n._loadNodeShallow(e),i=[],o=s.children||[];for(let c=0,d=o.length;c<d;c++)i.push(n.getDependency("node",o[c]));const a=s.skin===void 0?Promise.resolve(null):n.getDependency("skin",s.skin);return Promise.all([r,Promise.all(i),a]).then(function(c){const d=c[0],u=c[1],f=c[2];f!==null&&d.traverse(function(h){h.isSkinnedMesh&&h.bind(f,mu)});for(let h=0,g=u.length;h<g;h++)d.add(u[h]);return d})}_loadNodeShallow(e){const t=this.json,n=this.extensions,s=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const r=t.nodes[e],i=r.name?s.createUniqueName(r.name):"",o=[],a=s._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return a&&o.push(a),r.camera!==void 0&&o.push(s.getDependency("camera",r.camera).then(function(c){return s._getNodeRef(s.cameraCache,r.camera,c)})),s._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){o.push(c)}),this.nodeCache[e]=Promise.all(o).then(function(c){let d;if(r.isBone===!0?d=new As:c.length>1?d=new Je:c.length===1?d=c[0]:d=new Ze,d!==c[0])for(let u=0,f=c.length;u<f;u++)d.add(c[u]);if(r.name&&(d.userData.name=r.name,d.name=i),Rt(d,r),r.extensions&&Ht(n,d,r),r.matrix!==void 0){const u=new he;u.fromArray(r.matrix),d.applyMatrix4(u)}else r.translation!==void 0&&d.position.fromArray(r.translation),r.rotation!==void 0&&d.quaternion.fromArray(r.rotation),r.scale!==void 0&&d.scale.fromArray(r.scale);return s.associations.has(d)||s.associations.set(d,{}),s.associations.get(d).nodes=e,d}),this.nodeCache[e]}loadScene(e){const t=this.extensions,n=this.json.scenes[e],s=this,r=new Je;n.name&&(r.name=s.createUniqueName(n.name)),Rt(r,n),n.extensions&&Ht(t,r,n);const i=n.nodes||[],o=[];for(let a=0,c=i.length;a<c;a++)o.push(s.getDependency("node",i[a]));return Promise.all(o).then(function(a){for(let d=0,u=a.length;d<u;d++)r.add(a[d]);const c=d=>{const u=new Map;for(const[f,h]of s.associations)(f instanceof fs||f instanceof mr)&&u.set(f,h);return d.traverse(f=>{const h=s.associations.get(f);h!=null&&u.set(f,h)}),u};return s.associations=c(r),r})}_createAnimationTracks(e,t,n,s,r){const i=[],o=e.name?e.name:e.uuid,a=[];Lt[r.path]===Lt.weights?e.traverse(function(f){f.morphTargetInfluences&&a.push(f.name?f.name:f.uuid)}):a.push(o);let c;switch(Lt[r.path]){case Lt.weights:c=gr;break;case Lt.rotation:c=xn;break;case Lt.position:case Lt.scale:c=Wn;break;default:switch(n.itemSize){case 1:c=gr;break;case 2:case 3:default:c=Wn;break}break}const d=s.interpolation!==void 0?cu[s.interpolation]:Wo,u=this._getArrayFromAccessor(n);for(let f=0,h=a.length;f<h;f++){const g=new c(a[f]+"."+Lt[r.path],t.array,u,d);s.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(g),i.push(g)}return i}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const n=wr(t.constructor),s=new Float32Array(t.length);for(let r=0,i=t.length;r<i;r++)s[r]=t[r]*n;t=s}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(n){const s=this instanceof xn?lu:la;return new s(this.times,this.values,this.getValueSize()/3,n)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function Au(l,e,t){const n=e.attributes,s=new Qt;if(n.POSITION!==void 0){const o=t.json.accessors[n.POSITION],a=o.min,c=o.max;if(a!==void 0&&c!==void 0){if(s.set(new F(a[0],a[1],a[2]),new F(c[0],c[1],c[2])),o.normalized){const d=wr(gn[o.componentType]);s.min.multiplyScalar(d),s.max.multiplyScalar(d)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const r=e.targets;if(r!==void 0){const o=new F,a=new F;for(let c=0,d=r.length;c<d;c++){const u=r[c];if(u.POSITION!==void 0){const f=t.json.accessors[u.POSITION],h=f.min,g=f.max;if(h!==void 0&&g!==void 0){if(a.setX(Math.max(Math.abs(h[0]),Math.abs(g[0]))),a.setY(Math.max(Math.abs(h[1]),Math.abs(g[1]))),a.setZ(Math.max(Math.abs(h[2]),Math.abs(g[2]))),f.normalized){const p=wr(gn[f.componentType]);a.multiplyScalar(p)}o.max(a)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}s.expandByVector(o)}l.boundingBox=s;const i=new _l;s.getCenter(i.center),i.radius=s.min.distanceTo(s.max)/2,l.boundingSphere=i}function Si(l,e,t){const n=e.attributes,s=[];function r(i,o){return t.getDependency("accessor",i).then(function(a){l.setAttribute(o,a)})}for(const i in n){const o=Sr[i]||i.toLowerCase();o in l.attributes||s.push(r(n[i],o))}if(e.indices!==void 0&&!l.index){const i=t.getDependency("accessor",e.indices).then(function(o){l.setIndex(o)});s.push(i)}return _t.workingColorSpace!==Pt&&"COLOR_0"in n&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${_t.workingColorSpace}" not supported.`),Rt(l,e),Au(l,e,t),Promise.all(s).then(function(){return e.targets!==void 0?du(l,e.targets,t):l})}const ot=new Se;class yu extends zn{constructor(e){super(e),this.propertyNameMapping={},this.customPropertyMapping={}}load(e,t,n,s){const r=this,i=new Bs(this.manager);i.setPath(this.path),i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,function(o){try{t(r.parse(o))}catch(a){s?s(a):console.error(a),r.manager.itemError(e)}},n,s)}setPropertyNameMapping(e){this.propertyNameMapping=e}setCustomPropertyNameMapping(e){this.customPropertyMapping=e}parse(e){function t(m,A=0){const y=/^ply([\s\S]*)end_header(\r\n|\r|\n)/;let v="";const x=y.exec(m);x!==null&&(v=x[1]);const w={comments:[],elements:[],headerLength:A,objInfo:""},T=v.split(/\r\n|\r|\n/);let C;function E(I,P){const B={type:I[0]};return B.type==="list"?(B.name=I[3],B.countType=I[1],B.itemType=I[2]):B.name=I[1],B.name in P&&(B.name=P[B.name]),B}for(let I=0;I<T.length;I++){let P=T[I];if(P=P.trim(),P==="")continue;const B=P.split(/\s+/),M=B.shift();switch(P=B.join(" "),M){case"format":w.format=B[0],w.version=B[1];break;case"comment":w.comments.push(P);break;case"element":C!==void 0&&w.elements.push(C),C={},C.name=B[0],C.count=parseInt(B[1]),C.properties=[];break;case"property":C.properties.push(E(B,p.propertyNameMapping));break;case"obj_info":w.objInfo=P;break;default:console.log("unhandled",M,B)}}return C!==void 0&&w.elements.push(C),w}function n(m,A){switch(A){case"char":case"uchar":case"short":case"ushort":case"int":case"uint":case"int8":case"uint8":case"int16":case"uint16":case"int32":case"uint32":return parseInt(m);case"float":case"double":case"float32":case"float64":return parseFloat(m)}}function s(m,A){const y={};for(let v=0;v<m.length;v++){if(A.empty())return null;if(m[v].type==="list"){const x=[],w=n(A.next(),m[v].countType);for(let T=0;T<w;T++){if(A.empty())return null;x.push(n(A.next(),m[v].itemType))}y[m[v].name]=x}else y[m[v].name]=n(A.next(),m[v].type)}return y}function r(){const m={indices:[],vertices:[],normals:[],uvs:[],faceVertexUvs:[],colors:[],faceVertexColors:[]};for(const A of Object.keys(p.customPropertyMapping))m[A]=[];return m}function i(m){const A=m.map(v=>v.name);function y(v){for(let x=0,w=v.length;x<w;x++){const T=v[x];if(A.includes(T))return T}return null}return{attrX:y(["x","px","posx"])||"x",attrY:y(["y","py","posy"])||"y",attrZ:y(["z","pz","posz"])||"z",attrNX:y(["nx","normalx"]),attrNY:y(["ny","normaly"]),attrNZ:y(["nz","normalz"]),attrS:y(["s","u","texture_u","tx"]),attrT:y(["t","v","texture_v","ty"]),attrR:y(["red","diffuse_red","r","diffuse_r"]),attrG:y(["green","diffuse_green","g","diffuse_g"]),attrB:y(["blue","diffuse_blue","b","diffuse_b"])}}function o(m,A){const y=r(),v=/end_header\s+(\S[\s\S]*\S|\S)\s*$/;let x,w;(w=v.exec(m))!==null?x=w[1].split(/\s+/):x=[];const T=new vu(x);e:for(let C=0;C<A.elements.length;C++){const E=A.elements[C],I=i(E.properties);for(let P=0;P<E.count;P++){const B=s(E.properties,T);if(!B)break e;c(y,E.name,B,I)}}return a(y)}function a(m){let A=new je;m.indices.length>0&&A.setIndex(m.indices),A.setAttribute("position",new nt(m.vertices,3)),m.normals.length>0&&A.setAttribute("normal",new nt(m.normals,3)),m.uvs.length>0&&A.setAttribute("uv",new nt(m.uvs,2)),m.colors.length>0&&A.setAttribute("color",new nt(m.colors,3)),(m.faceVertexUvs.length>0||m.faceVertexColors.length>0)&&(A=A.toNonIndexed(),m.faceVertexUvs.length>0&&A.setAttribute("uv",new nt(m.faceVertexUvs,2)),m.faceVertexColors.length>0&&A.setAttribute("color",new nt(m.faceVertexColors,3)));for(const y of Object.keys(p.customPropertyMapping))m[y].length>0&&A.setAttribute(y,new nt(m[y],p.customPropertyMapping[y].length));return A.computeBoundingSphere(),A}function c(m,A,y,v){if(A==="vertex"){m.vertices.push(y[v.attrX],y[v.attrY],y[v.attrZ]),v.attrNX!==null&&v.attrNY!==null&&v.attrNZ!==null&&m.normals.push(y[v.attrNX],y[v.attrNY],y[v.attrNZ]),v.attrS!==null&&v.attrT!==null&&m.uvs.push(y[v.attrS],y[v.attrT]),v.attrR!==null&&v.attrG!==null&&v.attrB!==null&&(ot.setRGB(y[v.attrR]/255,y[v.attrG]/255,y[v.attrB]/255,Ue),m.colors.push(ot.r,ot.g,ot.b));for(const x of Object.keys(p.customPropertyMapping))for(const w of p.customPropertyMapping[x])m[x].push(y[w])}else if(A==="face"){const x=y.vertex_indices||y.vertex_index,w=y.texcoord;x.length===3?(m.indices.push(x[0],x[1],x[2]),w&&w.length===6&&(m.faceVertexUvs.push(w[0],w[1]),m.faceVertexUvs.push(w[2],w[3]),m.faceVertexUvs.push(w[4],w[5]))):x.length===4&&(m.indices.push(x[0],x[1],x[3]),m.indices.push(x[1],x[2],x[3])),v.attrR!==null&&v.attrG!==null&&v.attrB!==null&&(ot.setRGB(y[v.attrR]/255,y[v.attrG]/255,y[v.attrB]/255,Ue),m.faceVertexColors.push(ot.r,ot.g,ot.b),m.faceVertexColors.push(ot.r,ot.g,ot.b),m.faceVertexColors.push(ot.r,ot.g,ot.b))}}function d(m,A){const y={};let v=0;for(let x=0;x<A.length;x++){const w=A[x],T=w.valueReader;if(w.type==="list"){const C=[],E=w.countReader.read(m+v);v+=w.countReader.size;for(let I=0;I<E;I++)C.push(T.read(m+v)),v+=T.size;y[w.name]=C}else y[w.name]=T.read(m+v),v+=T.size}return[y,v]}function u(m,A,y){function v(x,w,T){switch(w){case"int8":case"char":return{read:C=>x.getInt8(C),size:1};case"uint8":case"uchar":return{read:C=>x.getUint8(C),size:1};case"int16":case"short":return{read:C=>x.getInt16(C,T),size:2};case"uint16":case"ushort":return{read:C=>x.getUint16(C,T),size:2};case"int32":case"int":return{read:C=>x.getInt32(C,T),size:4};case"uint32":case"uint":return{read:C=>x.getUint32(C,T),size:4};case"float32":case"float":return{read:C=>x.getFloat32(C,T),size:4};case"float64":case"double":return{read:C=>x.getFloat64(C,T),size:8}}}for(let x=0,w=m.length;x<w;x++){const T=m[x];T.type==="list"?(T.countReader=v(A,T.countType,y),T.valueReader=v(A,T.itemType,y)):T.valueReader=v(A,T.type,y)}}function f(m,A){const y=r(),v=A.format==="binary_little_endian",x=new DataView(m,A.headerLength);let w,T=0;for(let C=0;C<A.elements.length;C++){const E=A.elements[C],I=E.properties,P=i(I);u(I,x,v);for(let B=0;B<E.count;B++){w=d(T,I),T+=w[1];const M=w[0];c(y,E.name,M,P)}}return a(y)}function h(m){let A=0,y=!0,v="";const x=[],w=new TextDecoder().decode(m.subarray(0,5)),T=/^ply\r\n/.test(w);do{const C=String.fromCharCode(m[A++]);C!==`
`&&C!=="\r"?v+=C:(v==="end_header"&&(y=!1),v!==""&&(x.push(v),v=""))}while(y&&A<m.length);return T===!0&&A++,{headerText:x.join("\r")+"\r",headerLength:A}}let g;const p=this;if(e instanceof ArrayBuffer){const m=new Uint8Array(e),{headerText:A,headerLength:y}=h(m),v=t(A,y);if(v.format==="ascii"){const x=new TextDecoder().decode(m);g=o(x,v)}else g=f(e,v)}else g=o(e,t(e));return g}}class vu{constructor(e){this.arr=e,this.i=0}empty(){return this.i>=this.arr.length}next(){return this.arr[this.i++]}}const xu=[[255,222,62],[138,119,199],[243,82,82],[16,157,123],[43,247,242],[120,84,254],[157,238,149],[80,105,17],[39,121,232],[88,149,76],[22,60,188],[243,67,171],[94,62,2],[162,192,4]];function Su(l,e){for(const t of e){const n=t.boneName,s=l.humanoid.getRawBoneNode(n),r=l.humanoid.getNormalizedBoneNode(n);t.position&&(s.position.x+=t.position.x,s.position.y+=t.position.y,s.position.z+=t.position.z),t.rotation&&(r.rotation.x=t.rotation.x*Math.PI/180,r.rotation.y=t.rotation.y*Math.PI/180,r.rotation.z=t.rotation.z*Math.PI/180),t.scale&&s.scale.set(t.scale.x,t.scale.y,t.scale.z)}}function wu(l,e){Su(l.currentVrm,e),l.currentVrm.humanoid.update()}function _u(l,e){const t=l.currentVrm.scene.children[l.skinnedMeshIndex],n=l.faceIndex?l.currentVrm.scene.children[l.faceIndex]:null;e===null?(t.material.forEach(s=>{s.colorWrite=!s.colorWrite,s.depthWrite=!s.depthWrite}),n&&(n.visible=!n.visible)):(t.material.forEach(s=>{s.colorWrite=e,s.depthWrite=e}),n&&(n.visible=e))}function Cu(l,e){const{points:t,mesh:n,capsules:s}=l;e===null?(t.visible=!t.visible,n.visible=!n.visible,s.children.forEach(r=>{r.visible=!r.visible})):(t.visible=e,n.visible=e,s.children.forEach(r=>{r.visible=e}))}function Tu(l,e){const{points:t,mesh:n,capsules:s}=e;t&&(l.remove(t),t.geometry.dispose(),t.material.dispose()),n&&(l.remove(n),n.geometry.dispose(),n.material.dispose()),s&&(l.remove(s),s.children.forEach(r=>{r.geometry.dispose(),r.material.dispose()}))}function Mu(l,e){const{points:t,mesh:n,capsules:s}=e;t&&l.add(t),n&&l.add(n),s&&l.add(s)}function Jn(l,e,t,n=1){for(let s=0;s<t;s++)e[s*4+0]=n>3?1:l[s*(4-n)+0],e[s*4+1]=n>2?1:l[s*(4-n)+1],e[s*4+2]=n>1?1:l[s*(4-n)+2],e[s*4+3]=n>0?1:l[s*(4-n)+3]}function tn(...l){const e=new wt(...l);return e.needsUpdate=!0,e}const Eu={arm:{names:["J_Bip_L_Hand","J_Bip_L_LowerArm","J_Bip_R_Hand","J_Bip_R_LowerArm"],radius:.06,scale:{x:1,z:1}},leg:{names:["J_Bip_L_LowerLeg","J_Bip_L_Foot","J_Bip_R_LowerLeg","J_Bip_R_Foot"],radius:.08,scale:{x:1,z:1}},torso:{names:["J_Bip_C_Neck","J_Bip_C_Spine","J_Bip_C_Chest","J_Bip_C_UpperChest"],radius:.03,scale:{x:6,z:4}},headTop:{names:["J_Bip_C_HeadTop_End"],radius:.06,scale:{x:1.5,z:2}},head:{names:["J_Bip_C_Head"],radius:.03,scale:{x:2,z:2}}};function bu(l){const e=l.currentVrm.scene.children[l.skinnedMeshIndex],t=new Ho({color:16711680,size:.02,opacity:.3,transparent:!0}),n=new rt({color:65280,wireframe:!0,opacity:.2,transparent:!0}),s=new rt({wireframe:!0,opacity:.5,transparent:!0}),r=new je,i=[],a=e.geometry.getAttribute("position"),c=new F;let d=new F;for(let x=0;x<a.count;x++)c.fromBufferAttribute(a,x),d=e.applyBoneTransform(x,c),d.applyMatrix4(l.currentVrm.scene.matrixWorld),i.push(d.x,d.y,d.z);r.setAttribute("position",new nt(i,3));const u=new Vo(r,t),f=new je;f.setAttribute("position",new nt(i,3));const h=e.geometry.getIndex();f.setIndex(h);const g=new Oe(f,n),p=new Je,m=[];function A(x,w=0){const T=new F().setFromMatrixPosition(x.matrixWorld);x.children.forEach(function(C){if(C.isBone){const E=new F().setFromMatrixPosition(C.matrixWorld),I=T.distanceTo(E),P=new F().addVectors(T,E).multiplyScalar(.5);let B=null;for(const M of Object.values(Eu))if(M.names.includes(C.name)){B=M;break}if(B){const[M,D,_]=xu[p.children.length],k=M<<16|D<<8|_,G=new Tl(B.radius,I-B.radius*2,1,6),O=new Oe(G,s.clone());O.material.color.setHex(k),O.scale.set(B.scale.x,1,B.scale.z),O.position.copy(P);const $=new F().subVectors(E,T).normalize(),U=new ce().setFromUnitVectors(new F(0,1,0),$);O.setRotationFromQuaternion(U),O.updateMatrixWorld();const Z=e.skeleton.bones.indexOf(C);p.add(O),m.push(Z)}A(C,w+1)}})}const y=l.currentVrm.scene.children[0].children[0];return A(y,1),{pmc:{points:u,mesh:g,capsules:p},capsuleBoneIndex:m}}/*!
 * @pixiv/three-vrm v3.4.4
 * VRM file loader for three.js.
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 */var $n=(l,e,t)=>new Promise((n,s)=>{var r=a=>{try{o(t.next(a))}catch(c){s(c)}},i=a=>{try{o(t.throw(a))}catch(c){s(c)}},o=a=>a.done?n(a.value):Promise.resolve(a.value).then(r,i);o((t=t.apply(l,e)).next())}),_e=(l,e,t)=>new Promise((n,s)=>{var r=a=>{try{o(t.next(a))}catch(c){s(c)}},i=a=>{try{o(t.throw(a))}catch(c){s(c)}},o=a=>a.done?n(a.value):Promise.resolve(a.value).then(r,i);o((t=t.apply(l,e)).next())}),wi=class extends Ze{constructor(l){super(),this.weight=0,this.isBinary=!1,this.overrideBlink="none",this.overrideLookAt="none",this.overrideMouth="none",this._binds=[],this.name=`VRMExpression_${l}`,this.expressionName=l,this.type="VRMExpression",this.visible=!1}get binds(){return this._binds}get overrideBlinkAmount(){return this.overrideBlink==="block"?0<this.outputWeight?1:0:this.overrideBlink==="blend"?this.outputWeight:0}get overrideLookAtAmount(){return this.overrideLookAt==="block"?0<this.outputWeight?1:0:this.overrideLookAt==="blend"?this.outputWeight:0}get overrideMouthAmount(){return this.overrideMouth==="block"?0<this.outputWeight?1:0:this.overrideMouth==="blend"?this.outputWeight:0}get outputWeight(){return this.isBinary?this.weight>.5?1:0:this.weight}addBind(l){this._binds.push(l)}deleteBind(l){const e=this._binds.indexOf(l);e>=0&&this._binds.splice(e,1)}applyWeight(l){var e;let t=this.outputWeight;t*=(e=l?.multiplier)!=null?e:1,this.isBinary&&t<1&&(t=0),this._binds.forEach(n=>n.applyWeight(t))}clearAppliedWeight(){this._binds.forEach(l=>l.clearAppliedWeight())}};function ca(l,e,t){var n,s;const r=l.parser.json,i=(n=r.nodes)==null?void 0:n[e];if(i==null)return console.warn(`extractPrimitivesInternal: Attempt to use nodes[${e}] of glTF but the node doesn't exist`),null;const o=i.mesh;if(o==null)return null;const a=(s=r.meshes)==null?void 0:s[o];if(a==null)return console.warn(`extractPrimitivesInternal: Attempt to use meshes[${o}] of glTF but the mesh doesn't exist`),null;const c=a.primitives.length,d=[];return t.traverse(u=>{d.length<c&&u.isMesh&&d.push(u)}),d}function _i(l,e){return _e(this,null,function*(){const t=yield l.parser.getDependency("node",e);return ca(l,e,t)})}function Ci(l){return _e(this,null,function*(){const e=yield l.parser.getDependencies("node"),t=new Map;return e.forEach((n,s)=>{const r=ca(l,s,n);r!=null&&t.set(s,r)}),t})}var _r={Aa:"aa",Ih:"ih",Ou:"ou",Ee:"ee",Oh:"oh",Blink:"blink",Happy:"happy",Angry:"angry",Sad:"sad",Relaxed:"relaxed",LookUp:"lookUp",Surprised:"surprised",LookDown:"lookDown",LookLeft:"lookLeft",LookRight:"lookRight",BlinkLeft:"blinkLeft",BlinkRight:"blinkRight",Neutral:"neutral"};function ua(l){return Math.max(Math.min(l,1),0)}var Ti=class da{constructor(){this.blinkExpressionNames=["blink","blinkLeft","blinkRight"],this.lookAtExpressionNames=["lookLeft","lookRight","lookUp","lookDown"],this.mouthExpressionNames=["aa","ee","ih","oh","ou"],this._expressions=[],this._expressionMap={}}get expressions(){return this._expressions.concat()}get expressionMap(){return Object.assign({},this._expressionMap)}get presetExpressionMap(){const e={},t=new Set(Object.values(_r));return Object.entries(this._expressionMap).forEach(([n,s])=>{t.has(n)&&(e[n]=s)}),e}get customExpressionMap(){const e={},t=new Set(Object.values(_r));return Object.entries(this._expressionMap).forEach(([n,s])=>{t.has(n)||(e[n]=s)}),e}copy(e){return this._expressions.concat().forEach(n=>{this.unregisterExpression(n)}),e._expressions.forEach(n=>{this.registerExpression(n)}),this.blinkExpressionNames=e.blinkExpressionNames.concat(),this.lookAtExpressionNames=e.lookAtExpressionNames.concat(),this.mouthExpressionNames=e.mouthExpressionNames.concat(),this}clone(){return new da().copy(this)}getExpression(e){var t;return(t=this._expressionMap[e])!=null?t:null}registerExpression(e){this._expressions.push(e),this._expressionMap[e.expressionName]=e}unregisterExpression(e){const t=this._expressions.indexOf(e);t===-1&&console.warn("VRMExpressionManager: The specified expressions is not registered"),this._expressions.splice(t,1),delete this._expressionMap[e.expressionName]}getValue(e){var t;const n=this.getExpression(e);return(t=n?.weight)!=null?t:null}setValue(e,t){const n=this.getExpression(e);n&&(n.weight=ua(t))}resetValues(){this._expressions.forEach(e=>{e.weight=0})}getExpressionTrackName(e){const t=this.getExpression(e);return t?`${t.name}.weight`:null}update(){const e=this._calculateWeightMultipliers();this._expressions.forEach(t=>{t.clearAppliedWeight()}),this._expressions.forEach(t=>{let n=1;const s=t.expressionName;this.blinkExpressionNames.indexOf(s)!==-1&&(n*=e.blink),this.lookAtExpressionNames.indexOf(s)!==-1&&(n*=e.lookAt),this.mouthExpressionNames.indexOf(s)!==-1&&(n*=e.mouth),t.applyWeight({multiplier:n})})}_calculateWeightMultipliers(){let e=1,t=1,n=1;return this._expressions.forEach(s=>{e-=s.overrideBlinkAmount,t-=s.overrideLookAtAmount,n-=s.overrideMouthAmount}),e=Math.max(0,e),t=Math.max(0,t),n=Math.max(0,n),{blink:e,lookAt:t,mouth:n}}},En={Color:"color",EmissionColor:"emissionColor",ShadeColor:"shadeColor",MatcapColor:"matcapColor",RimColor:"rimColor",OutlineColor:"outlineColor"},Iu={_Color:En.Color,_EmissionColor:En.EmissionColor,_ShadeColor:En.ShadeColor,_RimColor:En.RimColor,_OutlineColor:En.OutlineColor},Ru=new Se,ha=class fa{constructor({material:e,type:t,targetValue:n,targetAlpha:s}){this.material=e,this.type=t,this.targetValue=n,this.targetAlpha=s??1;const r=this._initColorBindState(),i=this._initAlphaBindState();this._state={color:r,alpha:i}}applyWeight(e){const{color:t,alpha:n}=this._state;if(t!=null){const{propertyName:s,deltaValue:r}=t,i=this.material[s];i?.add(Ru.copy(r).multiplyScalar(e))}if(n!=null){const{propertyName:s,deltaValue:r}=n;this.material[s]!=null&&(this.material[s]+=r*e)}}clearAppliedWeight(){const{color:e,alpha:t}=this._state;if(e!=null){const{propertyName:n,initialValue:s}=e,r=this.material[n];r?.copy(s)}if(t!=null){const{propertyName:n,initialValue:s}=t;this.material[n]!=null&&(this.material[n]=s)}}_initColorBindState(){var e,t,n;const{material:s,type:r,targetValue:i}=this,o=this._getPropertyNameMap(),a=(t=(e=o?.[r])==null?void 0:e[0])!=null?t:null;if(a==null)return console.warn(`Tried to add a material color bind to the material ${(n=s.name)!=null?n:"(no name)"}, the type ${r} but the material or the type is not supported.`),null;const d=s[a].clone(),u=new Se(i.r-d.r,i.g-d.g,i.b-d.b);return{propertyName:a,initialValue:d,deltaValue:u}}_initAlphaBindState(){var e,t,n;const{material:s,type:r,targetAlpha:i}=this,o=this._getPropertyNameMap(),a=(t=(e=o?.[r])==null?void 0:e[1])!=null?t:null;if(a==null&&i!==1)return console.warn(`Tried to add a material alpha bind to the material ${(n=s.name)!=null?n:"(no name)"}, the type ${r} but the material or the type does not support alpha.`),null;if(a==null)return null;const c=s[a],d=i-c;return{propertyName:a,initialValue:c,deltaValue:d}}_getPropertyNameMap(){var e,t;return(t=(e=Object.entries(fa._propertyNameMapMap).find(([n])=>this.material[n]===!0))==null?void 0:e[1])!=null?t:null}};ha._propertyNameMapMap={isMeshStandardMaterial:{color:["color","opacity"],emissionColor:["emissive",null]},isMeshBasicMaterial:{color:["color","opacity"]},isMToonMaterial:{color:["color","opacity"],emissionColor:["emissive",null],outlineColor:["outlineColorFactor",null],matcapColor:["matcapFactor",null],rimColor:["parametricRimColorFactor",null],shadeColor:["shadeColorFactor",null]}};var Mi=ha,Cs=class{constructor({primitives:l,index:e,weight:t}){this.primitives=l,this.index=e,this.weight=t}applyWeight(l){this.primitives.forEach(e=>{var t;((t=e.morphTargetInfluences)==null?void 0:t[this.index])!=null&&(e.morphTargetInfluences[this.index]+=this.weight*l)})}clearAppliedWeight(){this.primitives.forEach(l=>{var e;((e=l.morphTargetInfluences)==null?void 0:e[this.index])!=null&&(l.morphTargetInfluences[this.index]=0)})}},Ei=new ge,pa=class ma{constructor({material:e,scale:t,offset:n}){var s,r;this.material=e,this.scale=t,this.offset=n;const i=(s=Object.entries(ma._propertyNamesMap).find(([o])=>e[o]===!0))==null?void 0:s[1];i==null?(console.warn(`Tried to add a texture transform bind to the material ${(r=e.name)!=null?r:"(no name)"} but the material is not supported.`),this._properties=[]):(this._properties=[],i.forEach(o=>{var a;const c=(a=e[o])==null?void 0:a.clone();if(!c)return null;e[o]=c;const d=c.offset.clone(),u=c.repeat.clone(),f=n.clone().sub(d),h=t.clone().sub(u);this._properties.push({name:o,initialOffset:d,deltaOffset:f,initialScale:u,deltaScale:h})}))}applyWeight(e){this._properties.forEach(t=>{const n=this.material[t.name];n!==void 0&&(n.offset.add(Ei.copy(t.deltaOffset).multiplyScalar(e)),n.repeat.add(Ei.copy(t.deltaScale).multiplyScalar(e)))})}clearAppliedWeight(){this._properties.forEach(e=>{const t=this.material[e.name];t!==void 0&&(t.offset.copy(e.initialOffset),t.repeat.copy(e.initialScale))})}};pa._propertyNamesMap={isMeshStandardMaterial:["map","emissiveMap","bumpMap","normalMap","displacementMap","roughnessMap","metalnessMap","alphaMap"],isMeshBasicMaterial:["map","specularMap","alphaMap"],isMToonMaterial:["map","normalMap","emissiveMap","shadeMultiplyTexture","rimMultiplyTexture","outlineWidthMultiplyTexture","uvAnimationMaskTexture"]};var bi=pa,Bu=new Set(["1.0","1.0-beta"]),ga=class Aa{get name(){return"VRMExpressionLoaderPlugin"}constructor(e){this.parser=e}afterRoot(e){return _e(this,null,function*(){e.userData.vrmExpressionManager=yield this._import(e)})}_import(e){return _e(this,null,function*(){const t=yield this._v1Import(e);if(t)return t;const n=yield this._v0Import(e);return n||null})}_v1Import(e){return _e(this,null,function*(){var t,n;const s=this.parser.json;if(!(((t=s.extensionsUsed)==null?void 0:t.indexOf("VRMC_vrm"))!==-1))return null;const i=(n=s.extensions)==null?void 0:n.VRMC_vrm;if(!i)return null;const o=i.specVersion;if(!Bu.has(o))return console.warn(`VRMExpressionLoaderPlugin: Unknown VRMC_vrm specVersion "${o}"`),null;const a=i.expressions;if(!a)return null;const c=new Set(Object.values(_r)),d=new Map;a.preset!=null&&Object.entries(a.preset).forEach(([f,h])=>{if(h!=null){if(!c.has(f)){console.warn(`VRMExpressionLoaderPlugin: Unknown preset name "${f}" detected. Ignoring the expression`);return}d.set(f,h)}}),a.custom!=null&&Object.entries(a.custom).forEach(([f,h])=>{if(c.has(f)){console.warn(`VRMExpressionLoaderPlugin: Custom expression cannot have preset name "${f}". Ignoring the expression`);return}d.set(f,h)});const u=new Ti;return yield Promise.all(Array.from(d.entries()).map(f=>_e(this,[f],function*([h,g]){var p,m,A,y,v,x,w;const T=new wi(h);if(e.scene.add(T),T.isBinary=(p=g.isBinary)!=null?p:!1,T.overrideBlink=(m=g.overrideBlink)!=null?m:"none",T.overrideLookAt=(A=g.overrideLookAt)!=null?A:"none",T.overrideMouth=(y=g.overrideMouth)!=null?y:"none",(v=g.morphTargetBinds)==null||v.forEach(C=>_e(this,null,function*(){var E;if(C.node===void 0||C.index===void 0)return;const I=yield _i(e,C.node),P=C.index;if(!I.every(B=>Array.isArray(B.morphTargetInfluences)&&P<B.morphTargetInfluences.length)){console.warn(`VRMExpressionLoaderPlugin: ${g.name} attempts to index morph #${P} but not found.`);return}T.addBind(new Cs({primitives:I,index:P,weight:(E=C.weight)!=null?E:1}))})),g.materialColorBinds||g.textureTransformBinds){const C=[];e.scene.traverse(E=>{const I=E.material;I&&(Array.isArray(I)?C.push(...I):C.push(I))}),(x=g.materialColorBinds)==null||x.forEach(E=>_e(this,null,function*(){C.filter(P=>{var B;const M=(B=this.parser.associations.get(P))==null?void 0:B.materials;return E.material===M}).forEach(P=>{T.addBind(new Mi({material:P,type:E.type,targetValue:new Se().fromArray(E.targetValue),targetAlpha:E.targetValue[3]}))})})),(w=g.textureTransformBinds)==null||w.forEach(E=>_e(this,null,function*(){C.filter(P=>{var B;const M=(B=this.parser.associations.get(P))==null?void 0:B.materials;return E.material===M}).forEach(P=>{var B,M;T.addBind(new bi({material:P,offset:new ge().fromArray((B=E.offset)!=null?B:[0,0]),scale:new ge().fromArray((M=E.scale)!=null?M:[1,1])}))})}))}u.registerExpression(T)}))),u})}_v0Import(e){return _e(this,null,function*(){var t;const n=this.parser.json,s=(t=n.extensions)==null?void 0:t.VRM;if(!s)return null;const r=s.blendShapeMaster;if(!r)return null;const i=new Ti,o=r.blendShapeGroups;if(!o)return i;const a=new Set;return yield Promise.all(o.map(c=>_e(this,null,function*(){var d;const u=c.presetName,f=u!=null&&Aa.v0v1PresetNameMap[u]||null,h=f??c.name;if(h==null){console.warn("VRMExpressionLoaderPlugin: One of custom expressions has no name. Ignoring the expression");return}if(a.has(h)){console.warn(`VRMExpressionLoaderPlugin: An expression preset ${u} has duplicated entries. Ignoring the expression`);return}a.add(h);const g=new wi(h);e.scene.add(g),g.isBinary=(d=c.isBinary)!=null?d:!1,c.binds&&c.binds.forEach(m=>_e(this,null,function*(){var A;if(m.mesh===void 0||m.index===void 0)return;const y=[];(A=n.nodes)==null||A.forEach((x,w)=>{x.mesh===m.mesh&&y.push(w)});const v=m.index;yield Promise.all(y.map(x=>_e(this,null,function*(){var w;const T=yield _i(e,x);if(!T.every(C=>Array.isArray(C.morphTargetInfluences)&&v<C.morphTargetInfluences.length)){console.warn(`VRMExpressionLoaderPlugin: ${c.name} attempts to index ${v}th morph but not found.`);return}g.addBind(new Cs({primitives:T,index:v,weight:.01*((w=m.weight)!=null?w:100)}))})))}));const p=c.materialValues;p&&p.length!==0&&p.forEach(m=>{if(m.materialName===void 0||m.propertyName===void 0||m.targetValue===void 0)return;const A=[];e.scene.traverse(v=>{if(v.material){const x=v.material;Array.isArray(x)?A.push(...x.filter(w=>(w.name===m.materialName||w.name===m.materialName+" (Outline)")&&A.indexOf(w)===-1)):x.name===m.materialName&&A.indexOf(x)===-1&&A.push(x)}});const y=m.propertyName;A.forEach(v=>{if(y==="_MainTex_ST"){const w=new ge(m.targetValue[0],m.targetValue[1]),T=new ge(m.targetValue[2],m.targetValue[3]);T.y=1-T.y-w.y,g.addBind(new bi({material:v,scale:w,offset:T}));return}const x=Iu[y];if(x){g.addBind(new Mi({material:v,type:x,targetValue:new Se().fromArray(m.targetValue),targetAlpha:m.targetValue[3]}));return}console.warn(y+" is not supported")})}),i.registerExpression(g)}))),i})}};ga.v0v1PresetNameMap={a:"aa",e:"ee",i:"ih",o:"oh",u:"ou",blink:"blink",joy:"happy",angry:"angry",sorrow:"sad",fun:"relaxed",lookup:"lookUp",lookdown:"lookDown",lookleft:"lookLeft",lookright:"lookRight",blink_l:"blinkLeft",blink_r:"blinkRight",neutral:"neutral"};var Pu=ga,kr=class cn{constructor(e,t){this._firstPersonOnlyLayer=cn.DEFAULT_FIRSTPERSON_ONLY_LAYER,this._thirdPersonOnlyLayer=cn.DEFAULT_THIRDPERSON_ONLY_LAYER,this._initializedLayers=!1,this.humanoid=e,this.meshAnnotations=t}copy(e){if(this.humanoid!==e.humanoid)throw new Error("VRMFirstPerson: humanoid must be same in order to copy");return this.meshAnnotations=e.meshAnnotations.map(t=>({meshes:t.meshes.concat(),type:t.type})),this}clone(){return new cn(this.humanoid,this.meshAnnotations).copy(this)}get firstPersonOnlyLayer(){return this._firstPersonOnlyLayer}get thirdPersonOnlyLayer(){return this._thirdPersonOnlyLayer}setup({firstPersonOnlyLayer:e=cn.DEFAULT_FIRSTPERSON_ONLY_LAYER,thirdPersonOnlyLayer:t=cn.DEFAULT_THIRDPERSON_ONLY_LAYER}={}){this._initializedLayers||(this._firstPersonOnlyLayer=e,this._thirdPersonOnlyLayer=t,this.meshAnnotations.forEach(n=>{n.meshes.forEach(s=>{n.type==="firstPersonOnly"?(s.layers.set(this._firstPersonOnlyLayer),s.traverse(r=>r.layers.set(this._firstPersonOnlyLayer))):n.type==="thirdPersonOnly"?(s.layers.set(this._thirdPersonOnlyLayer),s.traverse(r=>r.layers.set(this._thirdPersonOnlyLayer))):n.type==="auto"&&this._createHeadlessModel(s)})}),this._initializedLayers=!0)}_excludeTriangles(e,t,n,s){let r=0;if(t!=null&&t.length>0)for(let i=0;i<e.length;i+=3){const o=e[i],a=e[i+1],c=e[i+2],d=t[o],u=n[o];if(d[0]>0&&s.includes(u[0])||d[1]>0&&s.includes(u[1])||d[2]>0&&s.includes(u[2])||d[3]>0&&s.includes(u[3]))continue;const f=t[a],h=n[a];if(f[0]>0&&s.includes(h[0])||f[1]>0&&s.includes(h[1])||f[2]>0&&s.includes(h[2])||f[3]>0&&s.includes(h[3]))continue;const g=t[c],p=n[c];g[0]>0&&s.includes(p[0])||g[1]>0&&s.includes(p[1])||g[2]>0&&s.includes(p[2])||g[3]>0&&s.includes(p[3])||(e[r++]=o,e[r++]=a,e[r++]=c)}return r}_createErasedMesh(e,t){const n=new Dr(e.geometry.clone(),e.material);n.name=`${e.name}(erase)`,n.frustumCulled=e.frustumCulled,n.layers.set(this._firstPersonOnlyLayer);const s=n.geometry,r=s.getAttribute("skinIndex"),i=r instanceof ci?[]:r.array,o=[];for(let p=0;p<i.length;p+=4)o.push([i[p],i[p+1],i[p+2],i[p+3]]);const a=s.getAttribute("skinWeight"),c=a instanceof ci?[]:a.array,d=[];for(let p=0;p<c.length;p+=4)d.push([c[p],c[p+1],c[p+2],c[p+3]]);const u=s.getIndex();if(!u)throw new Error("The geometry doesn't have an index buffer");const f=Array.from(u.array),h=this._excludeTriangles(f,d,o,t),g=[];for(let p=0;p<h;p++)g[p]=f[p];return s.setIndex(g),e.onBeforeRender&&(n.onBeforeRender=e.onBeforeRender),n.bind(new Cn(e.skeleton.bones,e.skeleton.boneInverses),new he),n}_createHeadlessModelForSkinnedMesh(e,t){const n=[];if(t.skeleton.bones.forEach((r,i)=>{this._isEraseTarget(r)&&n.push(i)}),!n.length){t.layers.enable(this._thirdPersonOnlyLayer),t.layers.enable(this._firstPersonOnlyLayer);return}t.layers.set(this._thirdPersonOnlyLayer);const s=this._createErasedMesh(t,n);e.add(s)}_createHeadlessModel(e){if(e.type==="Group")if(e.layers.set(this._thirdPersonOnlyLayer),this._isEraseTarget(e))e.traverse(t=>t.layers.set(this._thirdPersonOnlyLayer));else{const t=new Je;t.name=`_headless_${e.name}`,t.layers.set(this._firstPersonOnlyLayer),e.parent.add(t),e.children.filter(n=>n.type==="SkinnedMesh").forEach(n=>{const s=n;this._createHeadlessModelForSkinnedMesh(t,s)})}else if(e.type==="SkinnedMesh"){const t=e;this._createHeadlessModelForSkinnedMesh(e.parent,t)}else this._isEraseTarget(e)&&(e.layers.set(this._thirdPersonOnlyLayer),e.traverse(t=>t.layers.set(this._thirdPersonOnlyLayer)))}_isEraseTarget(e){return e===this.humanoid.getRawBoneNode("head")?!0:e.parent?this._isEraseTarget(e.parent):!1}};kr.DEFAULT_FIRSTPERSON_ONLY_LAYER=9;kr.DEFAULT_THIRDPERSON_ONLY_LAYER=10;var Ii=kr,Du=new Set(["1.0","1.0-beta"]),Fu=class{get name(){return"VRMFirstPersonLoaderPlugin"}constructor(l){this.parser=l}afterRoot(l){return _e(this,null,function*(){const e=l.userData.vrmHumanoid;if(e!==null){if(e===void 0)throw new Error("VRMFirstPersonLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");l.userData.vrmFirstPerson=yield this._import(l,e)}})}_import(l,e){return _e(this,null,function*(){if(e==null)return null;const t=yield this._v1Import(l,e);if(t)return t;const n=yield this._v0Import(l,e);return n||null})}_v1Import(l,e){return _e(this,null,function*(){var t,n;const s=this.parser.json;if(!(((t=s.extensionsUsed)==null?void 0:t.indexOf("VRMC_vrm"))!==-1))return null;const i=(n=s.extensions)==null?void 0:n.VRMC_vrm;if(!i)return null;const o=i.specVersion;if(!Du.has(o))return console.warn(`VRMFirstPersonLoaderPlugin: Unknown VRMC_vrm specVersion "${o}"`),null;const a=i.firstPerson,c=[],d=yield Ci(l);return Array.from(d.entries()).forEach(([u,f])=>{var h,g;const p=(h=a?.meshAnnotations)==null?void 0:h.find(m=>m.node===u);c.push({meshes:f,type:(g=p?.type)!=null?g:"auto"})}),new Ii(e,c)})}_v0Import(l,e){return _e(this,null,function*(){var t;const n=this.parser.json,s=(t=n.extensions)==null?void 0:t.VRM;if(!s)return null;const r=s.firstPerson;if(!r)return null;const i=[],o=yield Ci(l);return Array.from(o.entries()).forEach(([a,c])=>{const d=n.nodes[a],u=r.meshAnnotations?r.meshAnnotations.find(f=>f.mesh===d.mesh):void 0;i.push({meshes:c,type:this._convertV0FlagToV1Type(u?.firstPersonFlag)})}),new Ii(e,i)})}_convertV0FlagToV1Type(l){return l==="FirstPersonOnly"?"firstPersonOnly":l==="ThirdPersonOnly"?"thirdPersonOnly":l==="Both"?"both":"auto"}},Ri=new F,Bi=new F,Lu=new ce,Pi=class extends Je{constructor(l){super(),this.vrmHumanoid=l,this._boneAxesMap=new Map,Object.values(l.humanBones).forEach(e=>{const t=new Qo(1);t.matrixAutoUpdate=!1,t.material.depthTest=!1,t.material.depthWrite=!1,this.add(t),this._boneAxesMap.set(e,t)})}dispose(){Array.from(this._boneAxesMap.values()).forEach(l=>{l.geometry.dispose(),l.material.dispose()})}updateMatrixWorld(l){Array.from(this._boneAxesMap.entries()).forEach(([e,t])=>{e.node.updateWorldMatrix(!0,!1),e.node.matrixWorld.decompose(Ri,Lu,Bi);const n=Ri.set(.1,.1,.1).divide(Bi);t.matrix.copy(e.node.matrixWorld).scale(n)}),super.updateMatrixWorld(l)}},Qs=["hips","spine","chest","upperChest","neck","head","leftEye","rightEye","jaw","leftUpperLeg","leftLowerLeg","leftFoot","leftToes","rightUpperLeg","rightLowerLeg","rightFoot","rightToes","leftShoulder","leftUpperArm","leftLowerArm","leftHand","rightShoulder","rightUpperArm","rightLowerArm","rightHand","leftThumbMetacarpal","leftThumbProximal","leftThumbDistal","leftIndexProximal","leftIndexIntermediate","leftIndexDistal","leftMiddleProximal","leftMiddleIntermediate","leftMiddleDistal","leftRingProximal","leftRingIntermediate","leftRingDistal","leftLittleProximal","leftLittleIntermediate","leftLittleDistal","rightThumbMetacarpal","rightThumbProximal","rightThumbDistal","rightIndexProximal","rightIndexIntermediate","rightIndexDistal","rightMiddleProximal","rightMiddleIntermediate","rightMiddleDistal","rightRingProximal","rightRingIntermediate","rightRingDistal","rightLittleProximal","rightLittleIntermediate","rightLittleDistal"],ku={hips:null,spine:"hips",chest:"spine",upperChest:"chest",neck:"upperChest",head:"neck",leftEye:"head",rightEye:"head",jaw:"head",leftUpperLeg:"hips",leftLowerLeg:"leftUpperLeg",leftFoot:"leftLowerLeg",leftToes:"leftFoot",rightUpperLeg:"hips",rightLowerLeg:"rightUpperLeg",rightFoot:"rightLowerLeg",rightToes:"rightFoot",leftShoulder:"upperChest",leftUpperArm:"leftShoulder",leftLowerArm:"leftUpperArm",leftHand:"leftLowerArm",rightShoulder:"upperChest",rightUpperArm:"rightShoulder",rightLowerArm:"rightUpperArm",rightHand:"rightLowerArm",leftThumbMetacarpal:"leftHand",leftThumbProximal:"leftThumbMetacarpal",leftThumbDistal:"leftThumbProximal",leftIndexProximal:"leftHand",leftIndexIntermediate:"leftIndexProximal",leftIndexDistal:"leftIndexIntermediate",leftMiddleProximal:"leftHand",leftMiddleIntermediate:"leftMiddleProximal",leftMiddleDistal:"leftMiddleIntermediate",leftRingProximal:"leftHand",leftRingIntermediate:"leftRingProximal",leftRingDistal:"leftRingIntermediate",leftLittleProximal:"leftHand",leftLittleIntermediate:"leftLittleProximal",leftLittleDistal:"leftLittleIntermediate",rightThumbMetacarpal:"rightHand",rightThumbProximal:"rightThumbMetacarpal",rightThumbDistal:"rightThumbProximal",rightIndexProximal:"rightHand",rightIndexIntermediate:"rightIndexProximal",rightIndexDistal:"rightIndexIntermediate",rightMiddleProximal:"rightHand",rightMiddleIntermediate:"rightMiddleProximal",rightMiddleDistal:"rightMiddleIntermediate",rightRingProximal:"rightHand",rightRingIntermediate:"rightRingProximal",rightRingDistal:"rightRingIntermediate",rightLittleProximal:"rightHand",rightLittleIntermediate:"rightLittleProximal",rightLittleDistal:"rightLittleIntermediate"};function ya(l){return l.invert?l.invert():l.inverse(),l}var Vt=new F,Wt=new ce,Cr=class{constructor(l){this.humanBones=l,this.restPose=this.getAbsolutePose()}getAbsolutePose(){const l={};return Object.keys(this.humanBones).forEach(e=>{const t=e,n=this.getBoneNode(t);n&&(Vt.copy(n.position),Wt.copy(n.quaternion),l[t]={position:Vt.toArray(),rotation:Wt.toArray()})}),l}getPose(){const l={};return Object.keys(this.humanBones).forEach(e=>{const t=e,n=this.getBoneNode(t);if(!n)return;Vt.set(0,0,0),Wt.identity();const s=this.restPose[t];s?.position&&Vt.fromArray(s.position).negate(),s?.rotation&&ya(Wt.fromArray(s.rotation)),Vt.add(n.position),Wt.premultiply(n.quaternion),l[t]={position:Vt.toArray(),rotation:Wt.toArray()}}),l}setPose(l){Object.entries(l).forEach(([e,t])=>{const n=e,s=this.getBoneNode(n);if(!s)return;const r=this.restPose[n];r&&(t?.position&&(s.position.fromArray(t.position),r.position&&s.position.add(Vt.fromArray(r.position))),t?.rotation&&(s.quaternion.fromArray(t.rotation),r.rotation&&s.quaternion.multiply(Wt.fromArray(r.rotation))))})}resetPose(){Object.entries(this.restPose).forEach(([l,e])=>{const t=this.getBoneNode(l);t&&(e?.position&&t.position.fromArray(e.position),e?.rotation&&t.quaternion.fromArray(e.rotation))})}getBone(l){var e;return(e=this.humanBones[l])!=null?e:void 0}getBoneNode(l){var e,t;return(t=(e=this.humanBones[l])==null?void 0:e.node)!=null?t:null}},Gs=new F,Ou=new ce,Uu=new F,Di=class va extends Cr{static _setupTransforms(e){const t=new Ze;t.name="VRMHumanoidRig";const n={},s={},r={};Qs.forEach(o=>{var a;const c=e.getBoneNode(o);if(c){const d=new F,u=new ce;c.updateWorldMatrix(!0,!1),c.matrixWorld.decompose(d,u,Gs),n[o]=d,s[o]=c.quaternion.clone();const f=new ce;(a=c.parent)==null||a.matrixWorld.decompose(Gs,f,Gs),r[o]=f}});const i={};return Qs.forEach(o=>{var a;const c=e.getBoneNode(o);if(c){const d=n[o];let u=o,f;for(;f==null&&(u=ku[u],u!=null);)f=n[u];const h=new Ze;h.name="Normalized_"+c.name,(u?(a=i[u])==null?void 0:a.node:t).add(h),h.position.copy(d),f&&h.position.sub(f),i[o]={node:h}}}),{rigBones:i,root:t,parentWorldRotations:r,boneRotations:s}}constructor(e){const{rigBones:t,root:n,parentWorldRotations:s,boneRotations:r}=va._setupTransforms(e);super(t),this.original=e,this.root=n,this._parentWorldRotations=s,this._boneRotations=r}update(){Qs.forEach(e=>{const t=this.original.getBoneNode(e);if(t!=null){const n=this.getBoneNode(e),s=this._parentWorldRotations[e],r=Ou.copy(s).invert(),i=this._boneRotations[e];if(t.quaternion.copy(n.quaternion).multiply(s).premultiply(r).multiply(i),e==="hips"){const o=n.getWorldPosition(Uu);t.parent.updateWorldMatrix(!0,!1);const a=t.parent.matrixWorld,c=o.applyMatrix4(a.invert());t.position.copy(c)}}})}},Fi=class xa{get restPose(){return console.warn("VRMHumanoid: restPose is deprecated. Use either rawRestPose or normalizedRestPose instead."),this.rawRestPose}get rawRestPose(){return this._rawHumanBones.restPose}get normalizedRestPose(){return this._normalizedHumanBones.restPose}get humanBones(){return this._rawHumanBones.humanBones}get rawHumanBones(){return this._rawHumanBones.humanBones}get normalizedHumanBones(){return this._normalizedHumanBones.humanBones}get normalizedHumanBonesRoot(){return this._normalizedHumanBones.root}constructor(e,t){var n;this.autoUpdateHumanBones=(n=t?.autoUpdateHumanBones)!=null?n:!0,this._rawHumanBones=new Cr(e),this._normalizedHumanBones=new Di(this._rawHumanBones)}copy(e){return this.autoUpdateHumanBones=e.autoUpdateHumanBones,this._rawHumanBones=new Cr(e.humanBones),this._normalizedHumanBones=new Di(this._rawHumanBones),this}clone(){return new xa(this.humanBones,{autoUpdateHumanBones:this.autoUpdateHumanBones}).copy(this)}getAbsolutePose(){return console.warn("VRMHumanoid: getAbsolutePose() is deprecated. Use either getRawAbsolutePose() or getNormalizedAbsolutePose() instead."),this.getRawAbsolutePose()}getRawAbsolutePose(){return this._rawHumanBones.getAbsolutePose()}getNormalizedAbsolutePose(){return this._normalizedHumanBones.getAbsolutePose()}getPose(){return console.warn("VRMHumanoid: getPose() is deprecated. Use either getRawPose() or getNormalizedPose() instead."),this.getRawPose()}getRawPose(){return this._rawHumanBones.getPose()}getNormalizedPose(){return this._normalizedHumanBones.getPose()}setPose(e){return console.warn("VRMHumanoid: setPose() is deprecated. Use either setRawPose() or setNormalizedPose() instead."),this.setRawPose(e)}setRawPose(e){return this._rawHumanBones.setPose(e)}setNormalizedPose(e){return this._normalizedHumanBones.setPose(e)}resetPose(){return console.warn("VRMHumanoid: resetPose() is deprecated. Use either resetRawPose() or resetNormalizedPose() instead."),this.resetRawPose()}resetRawPose(){return this._rawHumanBones.resetPose()}resetNormalizedPose(){return this._normalizedHumanBones.resetPose()}getBone(e){return console.warn("VRMHumanoid: getBone() is deprecated. Use either getRawBone() or getNormalizedBone() instead."),this.getRawBone(e)}getRawBone(e){return this._rawHumanBones.getBone(e)}getNormalizedBone(e){return this._normalizedHumanBones.getBone(e)}getBoneNode(e){return console.warn("VRMHumanoid: getBoneNode() is deprecated. Use either getRawBoneNode() or getNormalizedBoneNode() instead."),this.getRawBoneNode(e)}getRawBoneNode(e){return this._rawHumanBones.getBoneNode(e)}getNormalizedBoneNode(e){return this._normalizedHumanBones.getBoneNode(e)}update(){this.autoUpdateHumanBones&&this._normalizedHumanBones.update()}},Nu={Hips:"hips",Spine:"spine",Head:"head",LeftUpperLeg:"leftUpperLeg",LeftLowerLeg:"leftLowerLeg",LeftFoot:"leftFoot",RightUpperLeg:"rightUpperLeg",RightLowerLeg:"rightLowerLeg",RightFoot:"rightFoot",LeftUpperArm:"leftUpperArm",LeftLowerArm:"leftLowerArm",LeftHand:"leftHand",RightUpperArm:"rightUpperArm",RightLowerArm:"rightLowerArm",RightHand:"rightHand"},zu=new Set(["1.0","1.0-beta"]),Li={leftThumbProximal:"leftThumbMetacarpal",leftThumbIntermediate:"leftThumbProximal",rightThumbProximal:"rightThumbMetacarpal",rightThumbIntermediate:"rightThumbProximal"},Hu=class{get name(){return"VRMHumanoidLoaderPlugin"}constructor(l,e){this.parser=l,this.helperRoot=e?.helperRoot,this.autoUpdateHumanBones=e?.autoUpdateHumanBones}afterRoot(l){return _e(this,null,function*(){l.userData.vrmHumanoid=yield this._import(l)})}_import(l){return _e(this,null,function*(){const e=yield this._v1Import(l);if(e)return e;const t=yield this._v0Import(l);return t||null})}_v1Import(l){return _e(this,null,function*(){var e,t;const n=this.parser.json;if(!(((e=n.extensionsUsed)==null?void 0:e.indexOf("VRMC_vrm"))!==-1))return null;const r=(t=n.extensions)==null?void 0:t.VRMC_vrm;if(!r)return null;const i=r.specVersion;if(!zu.has(i))return console.warn(`VRMHumanoidLoaderPlugin: Unknown VRMC_vrm specVersion "${i}"`),null;const o=r.humanoid;if(!o)return null;const a=o.humanBones.leftThumbIntermediate!=null||o.humanBones.rightThumbIntermediate!=null,c={};o.humanBones!=null&&(yield Promise.all(Object.entries(o.humanBones).map(u=>_e(this,[u],function*([f,h]){let g=f;const p=h.node;if(a){const A=Li[g];A!=null&&(g=A)}const m=yield this.parser.getDependency("node",p);if(m==null){console.warn(`A glTF node bound to the humanoid bone ${g} (index = ${p}) does not exist`);return}c[g]={node:m}}))));const d=new Fi(this._ensureRequiredBonesExist(c),{autoUpdateHumanBones:this.autoUpdateHumanBones});if(l.scene.add(d.normalizedHumanBonesRoot),this.helperRoot){const u=new Pi(d);this.helperRoot.add(u),u.renderOrder=this.helperRoot.renderOrder}return d})}_v0Import(l){return _e(this,null,function*(){var e;const n=(e=this.parser.json.extensions)==null?void 0:e.VRM;if(!n)return null;const s=n.humanoid;if(!s)return null;const r={};s.humanBones!=null&&(yield Promise.all(s.humanBones.map(o=>_e(this,null,function*(){const a=o.bone,c=o.node;if(a==null||c==null)return;const d=yield this.parser.getDependency("node",c);if(d==null){console.warn(`A glTF node bound to the humanoid bone ${a} (index = ${c}) does not exist`);return}const u=Li[a],f=u??a;if(r[f]!=null){console.warn(`Multiple bone entries for ${f} detected (index = ${c}), ignoring duplicated entries.`);return}r[f]={node:d}}))));const i=new Fi(this._ensureRequiredBonesExist(r),{autoUpdateHumanBones:this.autoUpdateHumanBones});if(l.scene.add(i.normalizedHumanBonesRoot),this.helperRoot){const o=new Pi(i);this.helperRoot.add(o),o.renderOrder=this.helperRoot.renderOrder}return i})}_ensureRequiredBonesExist(l){const e=Object.values(Nu).filter(t=>l[t]==null);if(e.length>0)throw new Error(`VRMHumanoidLoaderPlugin: These humanoid bones are required but not exist: ${e.join(", ")}`);return l}},ki=class extends je{constructor(){super(),this._currentTheta=0,this._currentRadius=0,this.theta=0,this.radius=0,this._currentTheta=0,this._currentRadius=0,this._attrPos=new He(new Float32Array(65*3),3),this.setAttribute("position",this._attrPos),this._attrIndex=new He(new Uint16Array(3*63),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let l=!1;this._currentTheta!==this.theta&&(this._currentTheta=this.theta,l=!0),this._currentRadius!==this.radius&&(this._currentRadius=this.radius,l=!0),l&&this._buildPosition()}_buildPosition(){this._attrPos.setXYZ(0,0,0,0);for(let l=0;l<64;l++){const e=l/63*this._currentTheta;this._attrPos.setXYZ(l+1,this._currentRadius*Math.sin(e),0,this._currentRadius*Math.cos(e))}this._attrPos.needsUpdate=!0}_buildIndex(){for(let l=0;l<63;l++)this._attrIndex.setXYZ(l*3,0,l+1,l+2);this._attrIndex.needsUpdate=!0}},Vu=class extends je{constructor(){super(),this.radius=0,this._currentRadius=0,this.tail=new F,this._currentTail=new F,this._attrPos=new He(new Float32Array(294),3),this.setAttribute("position",this._attrPos),this._attrIndex=new He(new Uint16Array(194),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let l=!1;this._currentRadius!==this.radius&&(this._currentRadius=this.radius,l=!0),this._currentTail.equals(this.tail)||(this._currentTail.copy(this.tail),l=!0),l&&this._buildPosition()}_buildPosition(){for(let l=0;l<32;l++){const e=l/16*Math.PI;this._attrPos.setXYZ(l,Math.cos(e),Math.sin(e),0),this._attrPos.setXYZ(32+l,0,Math.cos(e),Math.sin(e)),this._attrPos.setXYZ(64+l,Math.sin(e),0,Math.cos(e))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.setXYZ(96,0,0,0),this._attrPos.setXYZ(97,this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let l=0;l<32;l++){const e=(l+1)%32;this._attrIndex.setXY(l*2,l,e),this._attrIndex.setXY(64+l*2,32+l,32+e),this._attrIndex.setXY(128+l*2,64+l,64+e)}this._attrIndex.setXY(192,96,97),this._attrIndex.needsUpdate=!0}},es=new ce,Oi=new ce,bn=new F,Ui=new F,Ni=Math.sqrt(2)/2,Wu=new ce(0,0,-Ni,Ni),ju=new F(0,1,0),Qu=class extends Je{constructor(l){super(),this.matrixAutoUpdate=!1,this.vrmLookAt=l;{const e=new ki;e.radius=.5;const t=new rt({color:65280,transparent:!0,opacity:.5,side:Sn,depthTest:!1,depthWrite:!1});this._meshPitch=new Oe(e,t),this.add(this._meshPitch)}{const e=new ki;e.radius=.5;const t=new rt({color:16711680,transparent:!0,opacity:.5,side:Sn,depthTest:!1,depthWrite:!1});this._meshYaw=new Oe(e,t),this.add(this._meshYaw)}{const e=new Vu;e.radius=.1;const t=new _n({color:16777215,depthTest:!1,depthWrite:!1});this._lineTarget=new Ds(e,t),this._lineTarget.frustumCulled=!1,this.add(this._lineTarget)}}dispose(){this._meshYaw.geometry.dispose(),this._meshYaw.material.dispose(),this._meshPitch.geometry.dispose(),this._meshPitch.material.dispose(),this._lineTarget.geometry.dispose(),this._lineTarget.material.dispose()}updateMatrixWorld(l){const e=Ae.DEG2RAD*this.vrmLookAt.yaw;this._meshYaw.geometry.theta=e,this._meshYaw.geometry.update();const t=Ae.DEG2RAD*this.vrmLookAt.pitch;this._meshPitch.geometry.theta=t,this._meshPitch.geometry.update(),this.vrmLookAt.getLookAtWorldPosition(bn),this.vrmLookAt.getLookAtWorldQuaternion(es),es.multiply(this.vrmLookAt.getFaceFrontQuaternion(Oi)),this._meshYaw.position.copy(bn),this._meshYaw.quaternion.copy(es),this._meshPitch.position.copy(bn),this._meshPitch.quaternion.copy(es),this._meshPitch.quaternion.multiply(Oi.setFromAxisAngle(ju,e)),this._meshPitch.quaternion.multiply(Wu);const{target:n,autoUpdate:s}=this.vrmLookAt;n!=null&&s&&(n.getWorldPosition(Ui).sub(bn),this._lineTarget.geometry.tail.copy(Ui),this._lineTarget.geometry.update(),this._lineTarget.position.copy(bn)),super.updateMatrixWorld(l)}},Gu=new F,qu=new F;function Tr(l,e){return l.matrixWorld.decompose(Gu,e,qu),e}function ps(l){return[Math.atan2(-l.z,l.x),Math.atan2(l.y,Math.sqrt(l.x*l.x+l.z*l.z))]}function zi(l){const e=Math.round(l/2/Math.PI);return l-2*Math.PI*e}var Hi=new F(0,0,1),Xu=new F,Ku=new F,Yu=new F,Zu=new ce,qs=new ce,Vi=new ce,Ju=new ce,Xs=new at,Sa=class wa{constructor(e,t){this.offsetFromHeadBone=new F,this.autoUpdate=!0,this.faceFront=new F(0,0,1),this.humanoid=e,this.applier=t,this._yaw=0,this._pitch=0,this._needsUpdate=!0,this._restHeadWorldQuaternion=this.getLookAtWorldQuaternion(new ce)}get yaw(){return this._yaw}set yaw(e){this._yaw=e,this._needsUpdate=!0}get pitch(){return this._pitch}set pitch(e){this._pitch=e,this._needsUpdate=!0}get euler(){return console.warn("VRMLookAt: euler is deprecated. use getEuler() instead."),this.getEuler(new at)}getEuler(e){return e.set(Ae.DEG2RAD*this._pitch,Ae.DEG2RAD*this._yaw,0,"YXZ")}copy(e){if(this.humanoid!==e.humanoid)throw new Error("VRMLookAt: humanoid must be same in order to copy");return this.offsetFromHeadBone.copy(e.offsetFromHeadBone),this.applier=e.applier,this.autoUpdate=e.autoUpdate,this.target=e.target,this.faceFront.copy(e.faceFront),this}clone(){return new wa(this.humanoid,this.applier).copy(this)}reset(){this._yaw=0,this._pitch=0,this._needsUpdate=!0}getLookAtWorldPosition(e){const t=this.humanoid.getRawBoneNode("head");return e.copy(this.offsetFromHeadBone).applyMatrix4(t.matrixWorld)}getLookAtWorldQuaternion(e){const t=this.humanoid.getRawBoneNode("head");return Tr(t,e)}getFaceFrontQuaternion(e){if(this.faceFront.distanceToSquared(Hi)<.01)return e.copy(this._restHeadWorldQuaternion).invert();const[t,n]=ps(this.faceFront);return Xs.set(0,.5*Math.PI+t,n,"YZX"),e.setFromEuler(Xs).premultiply(Ju.copy(this._restHeadWorldQuaternion).invert())}getLookAtWorldDirection(e){return this.getLookAtWorldQuaternion(qs),this.getFaceFrontQuaternion(Vi),e.copy(Hi).applyQuaternion(qs).applyQuaternion(Vi).applyEuler(this.getEuler(Xs))}lookAt(e){const t=Zu.copy(this._restHeadWorldQuaternion).multiply(ya(this.getLookAtWorldQuaternion(qs))),n=this.getLookAtWorldPosition(Ku),s=Yu.copy(e).sub(n).applyQuaternion(t).normalize(),[r,i]=ps(this.faceFront),[o,a]=ps(s),c=zi(o-r),d=zi(i-a);this._yaw=Ae.RAD2DEG*c,this._pitch=Ae.RAD2DEG*d,this._needsUpdate=!0}update(e){this.target!=null&&this.autoUpdate&&this.lookAt(this.target.getWorldPosition(Xu)),this._needsUpdate&&(this._needsUpdate=!1,this.applier.applyYawPitch(this._yaw,this._pitch))}};Sa.EULER_ORDER="YXZ";var $u=Sa,ed=new F(0,0,1),vt=new ce,nn=new ce,dt=new at(0,0,0,"YXZ"),ms=class{constructor(l,e,t,n,s){this.humanoid=l,this.rangeMapHorizontalInner=e,this.rangeMapHorizontalOuter=t,this.rangeMapVerticalDown=n,this.rangeMapVerticalUp=s,this.faceFront=new F(0,0,1),this._restQuatLeftEye=new ce,this._restQuatRightEye=new ce,this._restLeftEyeParentWorldQuat=new ce,this._restRightEyeParentWorldQuat=new ce;const r=this.humanoid.getRawBoneNode("leftEye"),i=this.humanoid.getRawBoneNode("rightEye");r&&(this._restQuatLeftEye.copy(r.quaternion),Tr(r.parent,this._restLeftEyeParentWorldQuat)),i&&(this._restQuatRightEye.copy(i.quaternion),Tr(i.parent,this._restRightEyeParentWorldQuat))}applyYawPitch(l,e){const t=this.humanoid.getRawBoneNode("leftEye"),n=this.humanoid.getRawBoneNode("rightEye"),s=this.humanoid.getNormalizedBoneNode("leftEye"),r=this.humanoid.getNormalizedBoneNode("rightEye");t&&(e<0?dt.x=-Ae.DEG2RAD*this.rangeMapVerticalDown.map(-e):dt.x=Ae.DEG2RAD*this.rangeMapVerticalUp.map(e),l<0?dt.y=-Ae.DEG2RAD*this.rangeMapHorizontalInner.map(-l):dt.y=Ae.DEG2RAD*this.rangeMapHorizontalOuter.map(l),vt.setFromEuler(dt),this._getWorldFaceFrontQuat(nn),s.quaternion.copy(nn).multiply(vt).multiply(nn.invert()),vt.copy(this._restLeftEyeParentWorldQuat),t.quaternion.copy(s.quaternion).multiply(vt).premultiply(vt.invert()).multiply(this._restQuatLeftEye)),n&&(e<0?dt.x=-Ae.DEG2RAD*this.rangeMapVerticalDown.map(-e):dt.x=Ae.DEG2RAD*this.rangeMapVerticalUp.map(e),l<0?dt.y=-Ae.DEG2RAD*this.rangeMapHorizontalOuter.map(-l):dt.y=Ae.DEG2RAD*this.rangeMapHorizontalInner.map(l),vt.setFromEuler(dt),this._getWorldFaceFrontQuat(nn),r.quaternion.copy(nn).multiply(vt).multiply(nn.invert()),vt.copy(this._restRightEyeParentWorldQuat),n.quaternion.copy(r.quaternion).multiply(vt).premultiply(vt.invert()).multiply(this._restQuatRightEye))}lookAt(l){console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");const e=Ae.RAD2DEG*l.y,t=Ae.RAD2DEG*l.x;this.applyYawPitch(e,t)}_getWorldFaceFrontQuat(l){if(this.faceFront.distanceToSquared(ed)<.01)return l.identity();const[e,t]=ps(this.faceFront);return dt.set(0,.5*Math.PI+e,t,"YZX"),l.setFromEuler(dt)}};ms.type="bone";var Mr=class{constructor(l,e,t,n,s){this.expressions=l,this.rangeMapHorizontalInner=e,this.rangeMapHorizontalOuter=t,this.rangeMapVerticalDown=n,this.rangeMapVerticalUp=s}applyYawPitch(l,e){e<0?(this.expressions.setValue("lookDown",0),this.expressions.setValue("lookUp",this.rangeMapVerticalUp.map(-e))):(this.expressions.setValue("lookUp",0),this.expressions.setValue("lookDown",this.rangeMapVerticalDown.map(e))),l<0?(this.expressions.setValue("lookLeft",0),this.expressions.setValue("lookRight",this.rangeMapHorizontalOuter.map(-l))):(this.expressions.setValue("lookRight",0),this.expressions.setValue("lookLeft",this.rangeMapHorizontalOuter.map(l)))}lookAt(l){console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");const e=Ae.RAD2DEG*l.y,t=Ae.RAD2DEG*l.x;this.applyYawPitch(e,t)}};Mr.type="expression";var Wi=class{constructor(l,e){this.inputMaxValue=l,this.outputScale=e}map(l){return this.outputScale*ua(l/this.inputMaxValue)}},td=new Set(["1.0","1.0-beta"]),ts=.01,nd=class{get name(){return"VRMLookAtLoaderPlugin"}constructor(l,e){this.parser=l,this.helperRoot=e?.helperRoot}afterRoot(l){return _e(this,null,function*(){const e=l.userData.vrmHumanoid;if(e===null)return;if(e===void 0)throw new Error("VRMLookAtLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");const t=l.userData.vrmExpressionManager;if(t!==null){if(t===void 0)throw new Error("VRMLookAtLoaderPlugin: vrmExpressionManager is undefined. VRMExpressionLoaderPlugin have to be used first");l.userData.vrmLookAt=yield this._import(l,e,t)}})}_import(l,e,t){return _e(this,null,function*(){if(e==null||t==null)return null;const n=yield this._v1Import(l,e,t);if(n)return n;const s=yield this._v0Import(l,e,t);return s||null})}_v1Import(l,e,t){return _e(this,null,function*(){var n,s,r;const i=this.parser.json;if(!(((n=i.extensionsUsed)==null?void 0:n.indexOf("VRMC_vrm"))!==-1))return null;const a=(s=i.extensions)==null?void 0:s.VRMC_vrm;if(!a)return null;const c=a.specVersion;if(!td.has(c))return console.warn(`VRMLookAtLoaderPlugin: Unknown VRMC_vrm specVersion "${c}"`),null;const d=a.lookAt;if(!d)return null;const u=d.type==="expression"?1:10,f=this._v1ImportRangeMap(d.rangeMapHorizontalInner,u),h=this._v1ImportRangeMap(d.rangeMapHorizontalOuter,u),g=this._v1ImportRangeMap(d.rangeMapVerticalDown,u),p=this._v1ImportRangeMap(d.rangeMapVerticalUp,u);let m;d.type==="expression"?m=new Mr(t,f,h,g,p):m=new ms(e,f,h,g,p);const A=this._importLookAt(e,m);return A.offsetFromHeadBone.fromArray((r=d.offsetFromHeadBone)!=null?r:[0,.06,0]),A})}_v1ImportRangeMap(l,e){var t,n;let s=(t=l?.inputMaxValue)!=null?t:90;const r=(n=l?.outputScale)!=null?n:e;return s<ts&&(console.warn("VRMLookAtLoaderPlugin: inputMaxValue of a range map is too small. Consider reviewing the range map!"),s=ts),new Wi(s,r)}_v0Import(l,e,t){return _e(this,null,function*(){var n,s,r,i;const a=(n=this.parser.json.extensions)==null?void 0:n.VRM;if(!a)return null;const c=a.firstPerson;if(!c)return null;const d=c.lookAtTypeName==="BlendShape"?1:10,u=this._v0ImportDegreeMap(c.lookAtHorizontalInner,d),f=this._v0ImportDegreeMap(c.lookAtHorizontalOuter,d),h=this._v0ImportDegreeMap(c.lookAtVerticalDown,d),g=this._v0ImportDegreeMap(c.lookAtVerticalUp,d);let p;c.lookAtTypeName==="BlendShape"?p=new Mr(t,u,f,h,g):p=new ms(e,u,f,h,g);const m=this._importLookAt(e,p);return c.firstPersonBoneOffset?m.offsetFromHeadBone.set((s=c.firstPersonBoneOffset.x)!=null?s:0,(r=c.firstPersonBoneOffset.y)!=null?r:.06,-((i=c.firstPersonBoneOffset.z)!=null?i:0)):m.offsetFromHeadBone.set(0,.06,0),m.faceFront.set(0,0,-1),p instanceof ms&&p.faceFront.set(0,0,-1),m})}_v0ImportDegreeMap(l,e){var t,n;const s=l?.curve;JSON.stringify(s)!=="[0,0,0,1,1,1,1,0]"&&console.warn("Curves of LookAtDegreeMap defined in VRM 0.0 are not supported");let r=(t=l?.xRange)!=null?t:90;const i=(n=l?.yRange)!=null?n:e;return r<ts&&(console.warn("VRMLookAtLoaderPlugin: xRange of a degree map is too small. Consider reviewing the degree map!"),r=ts),new Wi(r,i)}_importLookAt(l,e){const t=new $u(l,e);if(this.helperRoot){const n=new Qu(t);this.helperRoot.add(n),n.renderOrder=this.helperRoot.renderOrder}return t}};function sd(l,e){return typeof l!="string"||l===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(l)&&(e=e.replace(/(^https?:\/\/[^/]+).*/i,"$1")),/^(https?:)?\/\//i.test(l)||/^data:.*,.*$/i.test(l)||/^blob:.*$/i.test(l)?l:e+l)}var rd=new Set(["1.0","1.0-beta"]),id=class{get name(){return"VRMMetaLoaderPlugin"}constructor(l,e){var t,n,s;this.parser=l,this.needThumbnailImage=(t=e?.needThumbnailImage)!=null?t:!1,this.acceptLicenseUrls=(n=e?.acceptLicenseUrls)!=null?n:["https://vrm.dev/licenses/1.0/"],this.acceptV0Meta=(s=e?.acceptV0Meta)!=null?s:!0}afterRoot(l){return _e(this,null,function*(){l.userData.vrmMeta=yield this._import(l)})}_import(l){return _e(this,null,function*(){const e=yield this._v1Import(l);if(e!=null)return e;const t=yield this._v0Import(l);return t??null})}_v1Import(l){return _e(this,null,function*(){var e,t,n;const s=this.parser.json;if(!(((e=s.extensionsUsed)==null?void 0:e.indexOf("VRMC_vrm"))!==-1))return null;const i=(t=s.extensions)==null?void 0:t.VRMC_vrm;if(i==null)return null;const o=i.specVersion;if(!rd.has(o))return console.warn(`VRMMetaLoaderPlugin: Unknown VRMC_vrm specVersion "${o}"`),null;const a=i.meta;if(!a)return null;const c=a.licenseUrl;if(!new Set(this.acceptLicenseUrls).has(c))throw new Error(`VRMMetaLoaderPlugin: The license url "${c}" is not accepted`);let u;return this.needThumbnailImage&&a.thumbnailImage!=null&&(u=(n=yield this._extractGLTFImage(a.thumbnailImage))!=null?n:void 0),{metaVersion:"1",name:a.name,version:a.version,authors:a.authors,copyrightInformation:a.copyrightInformation,contactInformation:a.contactInformation,references:a.references,thirdPartyLicenses:a.thirdPartyLicenses,thumbnailImage:u,licenseUrl:a.licenseUrl,avatarPermission:a.avatarPermission,allowExcessivelyViolentUsage:a.allowExcessivelyViolentUsage,allowExcessivelySexualUsage:a.allowExcessivelySexualUsage,commercialUsage:a.commercialUsage,allowPoliticalOrReligiousUsage:a.allowPoliticalOrReligiousUsage,allowAntisocialOrHateUsage:a.allowAntisocialOrHateUsage,creditNotation:a.creditNotation,allowRedistribution:a.allowRedistribution,modification:a.modification,otherLicenseUrl:a.otherLicenseUrl}})}_v0Import(l){return _e(this,null,function*(){var e;const n=(e=this.parser.json.extensions)==null?void 0:e.VRM;if(!n)return null;const s=n.meta;if(!s)return null;if(!this.acceptV0Meta)throw new Error("VRMMetaLoaderPlugin: Attempted to load VRM0.0 meta but acceptV0Meta is false");let r;return this.needThumbnailImage&&s.texture!=null&&s.texture!==-1&&(r=yield this.parser.getDependency("texture",s.texture)),{metaVersion:"0",allowedUserName:s.allowedUserName,author:s.author,commercialUssageName:s.commercialUssageName,contactInformation:s.contactInformation,licenseName:s.licenseName,otherLicenseUrl:s.otherLicenseUrl,otherPermissionUrl:s.otherPermissionUrl,reference:s.reference,sexualUssageName:s.sexualUssageName,texture:r??void 0,title:s.title,version:s.version,violentUssageName:s.violentUssageName}})}_extractGLTFImage(l){return _e(this,null,function*(){var e;const n=(e=this.parser.json.images)==null?void 0:e[l];if(n==null)return console.warn(`VRMMetaLoaderPlugin: Attempt to use images[${l}] of glTF as a thumbnail but the image doesn't exist`),null;let s=n.uri;if(n.bufferView!=null){const i=yield this.parser.getDependency("bufferView",n.bufferView),o=new Blob([i],{type:n.mimeType});s=URL.createObjectURL(o)}return s==null?(console.warn(`VRMMetaLoaderPlugin: Attempt to use images[${l}] of glTF as a thumbnail but the image couldn't load properly`),null):yield new Ml().loadAsync(sd(s,this.parser.options.path)).catch(i=>(console.error(i),console.warn("VRMMetaLoaderPlugin: Failed to load a thumbnail image"),null))})}},od=class{constructor(l){this.scene=l.scene,this.meta=l.meta,this.humanoid=l.humanoid,this.expressionManager=l.expressionManager,this.firstPerson=l.firstPerson,this.lookAt=l.lookAt}update(l){this.humanoid.update(),this.lookAt&&this.lookAt.update(l),this.expressionManager&&this.expressionManager.update()}},ad=class extends od{constructor(l){super(l),this.materials=l.materials,this.springBoneManager=l.springBoneManager,this.nodeConstraintManager=l.nodeConstraintManager}update(l){super.update(l),this.nodeConstraintManager&&this.nodeConstraintManager.update(),this.springBoneManager&&this.springBoneManager.update(l),this.materials&&this.materials.forEach(e=>{e.update&&e.update(l)})}},ld=Object.defineProperty,ji=Object.getOwnPropertySymbols,cd=Object.prototype.hasOwnProperty,ud=Object.prototype.propertyIsEnumerable,Qi=(l,e,t)=>e in l?ld(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t,Gi=(l,e)=>{for(var t in e||(e={}))cd.call(e,t)&&Qi(l,t,e[t]);if(ji)for(var t of ji(e))ud.call(e,t)&&Qi(l,t,e[t]);return l},Gt=(l,e,t)=>new Promise((n,s)=>{var r=a=>{try{o(t.next(a))}catch(c){s(c)}},i=a=>{try{o(t.throw(a))}catch(c){s(c)}},o=a=>a.done?n(a.value):Promise.resolve(a.value).then(r,i);o((t=t.apply(l,e)).next())}),dd={"":3e3,srgb:3001};function hd(l,e){parseInt(ws,10)>=152?l.colorSpace=e:l.encoding=dd[e]}var fd=class{get pending(){return Promise.all(this._pendings)}constructor(l,e){this._parser=l,this._materialParams=e,this._pendings=[]}assignPrimitive(l,e){e!=null&&(this._materialParams[l]=e)}assignColor(l,e,t){if(e!=null){const n=new Se().fromArray(e);t&&n.convertSRGBToLinear(),this._materialParams[l]=n}}assignTexture(l,e,t){return Gt(this,null,function*(){const n=(()=>Gt(this,null,function*(){e!=null&&(yield this._parser.assignTexture(this._materialParams,l,e),t&&hd(this._materialParams[l],"srgb"))}))();return this._pendings.push(n),n})}assignTextureByIndex(l,e,t){return Gt(this,null,function*(){return this.assignTexture(l,e!=null?{index:e}:void 0,t)})}},pd=`// #define PHONG

varying vec3 vViewPosition;

#ifndef FLAT_SHADED
  varying vec3 vNormal;
#endif

#include <common>

// #include <uv_pars_vertex>
#ifdef MTOON_USE_UV
  varying vec2 vUv;

  // COMPAT: pre-r151 uses a common uvTransform
  #if THREE_VRM_THREE_REVISION < 151
    uniform mat3 uvTransform;
  #endif
#endif

// #include <uv2_pars_vertex>
// COMAPT: pre-r151 uses uv2 for lightMap and aoMap
#if THREE_VRM_THREE_REVISION < 151
  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    attribute vec2 uv2;
    varying vec2 vUv2;
    uniform mat3 uv2Transform;
  #endif
#endif

// #include <displacementmap_pars_vertex>
// #include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE
  uniform sampler2D outlineWidthMultiplyTexture;
  uniform mat3 outlineWidthMultiplyTextureUvTransform;
#endif

uniform float outlineWidthFactor;

void main() {

  // #include <uv_vertex>
  #ifdef MTOON_USE_UV
    // COMPAT: pre-r151 uses a common uvTransform
    #if THREE_VRM_THREE_REVISION >= 151
      vUv = uv;
    #else
      vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
    #endif
  #endif

  // #include <uv2_vertex>
  // COMAPT: pre-r151 uses uv2 for lightMap and aoMap
  #if THREE_VRM_THREE_REVISION < 151
    #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
      vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
    #endif
  #endif

  #include <color_vertex>

  #include <beginnormal_vertex>
  #include <morphnormal_vertex>
  #include <skinbase_vertex>
  #include <skinnormal_vertex>

  // we need this to compute the outline properly
  objectNormal = normalize( objectNormal );

  #include <defaultnormal_vertex>

  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED
    vNormal = normalize( transformedNormal );
  #endif

  #include <begin_vertex>

  #include <morphtarget_vertex>
  #include <skinning_vertex>
  // #include <displacementmap_vertex>
  #include <project_vertex>
  #include <logdepthbuf_vertex>
  #include <clipping_planes_vertex>

  vViewPosition = - mvPosition.xyz;

  #ifdef OUTLINE
    float worldNormalLength = length( transformedNormal );
    vec3 outlineOffset = outlineWidthFactor * worldNormalLength * objectNormal;

    #ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE
      vec2 outlineWidthMultiplyTextureUv = ( outlineWidthMultiplyTextureUvTransform * vec3( vUv, 1 ) ).xy;
      float outlineTex = texture2D( outlineWidthMultiplyTexture, outlineWidthMultiplyTextureUv ).g;
      outlineOffset *= outlineTex;
    #endif

    #ifdef OUTLINE_WIDTH_SCREEN
      outlineOffset *= vViewPosition.z / projectionMatrix[ 1 ].y;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );

    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic
  #endif

  #include <worldpos_vertex>
  // #include <envmap_vertex>
  #include <shadowmap_vertex>
  #include <fog_vertex>

}`,md=`// #define PHONG

uniform vec3 litFactor;

uniform float opacity;

uniform vec3 shadeColorFactor;
#ifdef USE_SHADEMULTIPLYTEXTURE
  uniform sampler2D shadeMultiplyTexture;
  uniform mat3 shadeMultiplyTextureUvTransform;
#endif

uniform float shadingShiftFactor;
uniform float shadingToonyFactor;

#ifdef USE_SHADINGSHIFTTEXTURE
  uniform sampler2D shadingShiftTexture;
  uniform mat3 shadingShiftTextureUvTransform;
  uniform float shadingShiftTextureScale;
#endif

uniform float giEqualizationFactor;

uniform vec3 parametricRimColorFactor;
#ifdef USE_RIMMULTIPLYTEXTURE
  uniform sampler2D rimMultiplyTexture;
  uniform mat3 rimMultiplyTextureUvTransform;
#endif
uniform float rimLightingMixFactor;
uniform float parametricRimFresnelPowerFactor;
uniform float parametricRimLiftFactor;

#ifdef USE_MATCAPTEXTURE
  uniform vec3 matcapFactor;
  uniform sampler2D matcapTexture;
  uniform mat3 matcapTextureUvTransform;
#endif

uniform vec3 emissive;
uniform float emissiveIntensity;

uniform vec3 outlineColorFactor;
uniform float outlineLightingMixFactor;

#ifdef USE_UVANIMATIONMASKTEXTURE
  uniform sampler2D uvAnimationMaskTexture;
  uniform mat3 uvAnimationMaskTextureUvTransform;
#endif

uniform float uvAnimationScrollXOffset;
uniform float uvAnimationScrollYOffset;
uniform float uvAnimationRotationPhase;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>

// #include <uv_pars_fragment>
#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )
  varying vec2 vUv;
#endif

// #include <uv2_pars_fragment>
// COMAPT: pre-r151 uses uv2 for lightMap and aoMap
#if THREE_VRM_THREE_REVISION < 151
  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    varying vec2 vUv2;
  #endif
#endif

#include <map_pars_fragment>

#ifdef USE_MAP
  uniform mat3 mapUvTransform;
#endif

// #include <alphamap_pars_fragment>

#include <alphatest_pars_fragment>

#include <aomap_pars_fragment>
// #include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>

#ifdef USE_EMISSIVEMAP
  uniform mat3 emissiveMapUvTransform;
#endif

// #include <envmap_common_pars_fragment>
// #include <envmap_pars_fragment>
// #include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>

// #include <bsdfs>
// COMPAT: pre-r151 doesn't have BRDF_Lambert in <common>
#if THREE_VRM_THREE_REVISION < 151
  vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
    return RECIPROCAL_PI * diffuseColor;
  }
#endif

#include <lights_pars_begin>

#include <normal_pars_fragment>

// #include <lights_phong_pars_fragment>
varying vec3 vViewPosition;

struct MToonMaterial {
  vec3 diffuseColor;
  vec3 shadeColor;
  float shadingShift;
};

float linearstep( float a, float b, float t ) {
  return clamp( ( t - a ) / ( b - a ), 0.0, 1.0 );
}

/**
 * Convert NdotL into toon shading factor using shadingShift and shadingToony
 */
float getShading(
  const in float dotNL,
  const in float shadow,
  const in float shadingShift
) {
  float shading = dotNL;
  shading = shading + shadingShift;
  shading = linearstep( -1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading );
  shading *= shadow;
  return shading;
}

/**
 * Mix diffuseColor and shadeColor using shading factor and light color
 */
vec3 getDiffuse(
  const in MToonMaterial material,
  const in float shading,
  in vec3 lightColor
) {
  #ifdef DEBUG_LITSHADERATE
    return vec3( BRDF_Lambert( shading * lightColor ) );
  #endif

  vec3 col = lightColor * BRDF_Lambert( mix( material.shadeColor, material.diffuseColor, shading ) );

  // The "comment out if you want to PBR absolutely" line
  #ifdef V0_COMPAT_SHADE
    col = min( col, material.diffuseColor );
  #endif

  return col;
}

// COMPAT: pre-r156 uses a struct GeometricContext
#if THREE_VRM_THREE_REVISION >= 157
  void RE_Direct_MToon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {
    float dotNL = clamp( dot( geometryNormal, directLight.direction ), -1.0, 1.0 );
    vec3 irradiance = directLight.color;

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;

    irradiance *= dotNL;

    float shading = getShading( dotNL, shadow, material.shadingShift );

    // toon shaded diffuse
    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );
  }

  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {
    // indirect diffuse will use diffuseColor, no shadeColor involved
    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;
  }
#else
  void RE_Direct_MToon( const in IncidentLight directLight, const in GeometricContext geometry, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {
    float dotNL = clamp( dot( geometry.normal, directLight.direction ), -1.0, 1.0 );
    vec3 irradiance = directLight.color;

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;

    irradiance *= dotNL;

    float shading = getShading( dotNL, shadow, material.shadingShift );

    // toon shaded diffuse
    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );
  }

  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in GeometricContext geometry, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {
    // indirect diffuse will use diffuseColor, no shadeColor involved
    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;
  }
#endif

#define RE_Direct RE_Direct_MToon
#define RE_IndirectDiffuse RE_IndirectDiffuse_MToon
#define Material_LightProbeLOD( material ) (0)

#include <shadowmap_pars_fragment>
// #include <bumpmap_pars_fragment>

// #include <normalmap_pars_fragment>
#ifdef USE_NORMALMAP

  uniform sampler2D normalMap;
  uniform mat3 normalMapUvTransform;
  uniform vec2 normalScale;

#endif

// COMPAT: pre-r151
// USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151
#if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )

  uniform mat3 normalMatrix;

#endif

// COMPAT: pre-r151
// USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( TANGENTSPACE_NORMALMAP ) )

  // Per-Pixel Tangent Space Normal Mapping
  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

  // three-vrm specific change: it requires \`uv\` as an input in order to support uv scrolls

  // Temporary compat against shader change @ Three.js r126, r151
  #if THREE_VRM_THREE_REVISION >= 151

    mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {

      vec3 q0 = dFdx( eye_pos.xyz );
      vec3 q1 = dFdy( eye_pos.xyz );
      vec2 st0 = dFdx( uv.st );
      vec2 st1 = dFdy( uv.st );

      vec3 N = surf_norm;

      vec3 q1perp = cross( q1, N );
      vec3 q0perp = cross( N, q0 );

      vec3 T = q1perp * st0.x + q0perp * st1.x;
      vec3 B = q1perp * st0.y + q0perp * st1.y;

      float det = max( dot( T, T ), dot( B, B ) );
      float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );

      return mat3( T * scale, B * scale, N );

    }

  #else

    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {

      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
      vec2 st0 = dFdx( uv.st );
      vec2 st1 = dFdy( uv.st );

      vec3 N = normalize( surf_norm );

      vec3 q1perp = cross( q1, N );
      vec3 q0perp = cross( N, q0 );

      vec3 T = q1perp * st0.x + q0perp * st1.x;
      vec3 B = q1perp * st0.y + q0perp * st1.y;

      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0
      // TODO: Is this still required? Or shall I make a PR about it?
      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {
        return surf_norm;
      }

      float det = max( dot( T, T ), dot( B, B ) );
      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );

      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );

    }

  #endif

#endif

// #include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

// == post correction ==========================================================
void postCorrection() {
  #include <tonemapping_fragment>
  #include <colorspace_fragment>
  #include <fog_fragment>
  #include <premultiplied_alpha_fragment>
  #include <dithering_fragment>
}

// == main procedure ===========================================================
void main() {
  #include <clipping_planes_fragment>

  vec2 uv = vec2(0.5, 0.5);

  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )
    uv = vUv;

    float uvAnimMask = 1.0;
    #ifdef USE_UVANIMATIONMASKTEXTURE
      vec2 uvAnimationMaskTextureUv = ( uvAnimationMaskTextureUvTransform * vec3( uv, 1 ) ).xy;
      uvAnimMask = texture2D( uvAnimationMaskTexture, uvAnimationMaskTextureUv ).b;
    #endif

    float uvRotCos = cos( uvAnimationRotationPhase * uvAnimMask );
    float uvRotSin = sin( uvAnimationRotationPhase * uvAnimMask );
    uv = mat2( uvRotCos, -uvRotSin, uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;
    uv = uv + vec2( uvAnimationScrollXOffset, uvAnimationScrollYOffset ) * uvAnimMask;
  #endif

  #ifdef DEBUG_UV
    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )
      gl_FragColor = vec4( uv, 0.0, 1.0 );
    #endif
    return;
  #endif

  vec4 diffuseColor = vec4( litFactor, opacity );
  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
  vec3 totalEmissiveRadiance = emissive * emissiveIntensity;

  #include <logdepthbuf_fragment>

  // #include <map_fragment>
  #ifdef USE_MAP
    vec2 mapUv = ( mapUvTransform * vec3( uv, 1 ) ).xy;
    vec4 sampledDiffuseColor = texture2D( map, mapUv );
    #ifdef DECODE_VIDEO_TEXTURE
      sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
    #endif
    diffuseColor *= sampledDiffuseColor;
  #endif

  // #include <color_fragment>
  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )
    diffuseColor.rgb *= vColor;
  #endif

  // #include <alphamap_fragment>

  #include <alphatest_fragment>

  // #include <specularmap_fragment>

  // #include <normal_fragment_begin>
  float faceDirection = gl_FrontFacing ? 1.0 : -1.0;

  #ifdef FLAT_SHADED

    vec3 fdx = dFdx( vViewPosition );
    vec3 fdy = dFdy( vViewPosition );
    vec3 normal = normalize( cross( fdx, fdy ) );

  #else

    vec3 normal = normalize( vNormal );

    #ifdef DOUBLE_SIDED

      normal *= faceDirection;

    #endif

  #endif

  #ifdef USE_NORMALMAP

    vec2 normalMapUv = ( normalMapUvTransform * vec3( uv, 1 ) ).xy;

  #endif

  #ifdef USE_NORMALMAP_TANGENTSPACE

    #ifdef USE_TANGENT

      mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

    #else

      mat3 tbn = getTangentFrame( - vViewPosition, normal, normalMapUv );

    #endif

    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

      tbn[0] *= faceDirection;
      tbn[1] *= faceDirection;

    #endif

  #endif

  #ifdef USE_CLEARCOAT_NORMALMAP

    #ifdef USE_TANGENT

      mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

    #else

      mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );

    #endif

    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

      tbn2[0] *= faceDirection;
      tbn2[1] *= faceDirection;

    #endif

  #endif

  // non perturbed normal for clearcoat among others

  vec3 nonPerturbedNormal = normal;

  #ifdef OUTLINE
    normal *= -1.0;
  #endif

  // #include <normal_fragment_maps>

  // COMPAT: pre-r151
  // USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151
  #if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )

    normal = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

    #ifdef FLIP_SIDED

      normal = - normal;

    #endif

    #ifdef DOUBLE_SIDED

      normal = normal * faceDirection;

    #endif

    normal = normalize( normalMatrix * normal );

  // COMPAT: pre-r151
  // USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151
  #elif defined( USE_NORMALMAP_TANGENTSPACE ) || defined( TANGENTSPACE_NORMALMAP )

    vec3 mapN = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0;
    mapN.xy *= normalScale;

    // COMPAT: pre-r151
    #if THREE_VRM_THREE_REVISION >= 151 || defined( USE_TANGENT )

      normal = normalize( tbn * mapN );

    #else

      normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );

    #endif

  #endif

  // #include <emissivemap_fragment>
  #ifdef USE_EMISSIVEMAP
    vec2 emissiveMapUv = ( emissiveMapUvTransform * vec3( uv, 1 ) ).xy;
    totalEmissiveRadiance *= texture2D( emissiveMap, emissiveMapUv ).rgb;
  #endif

  #ifdef DEBUG_NORMAL
    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );
    return;
  #endif

  // -- MToon: lighting --------------------------------------------------------
  // accumulation
  // #include <lights_phong_fragment>
  MToonMaterial material;

  material.diffuseColor = diffuseColor.rgb;

  material.shadeColor = shadeColorFactor;
  #ifdef USE_SHADEMULTIPLYTEXTURE
    vec2 shadeMultiplyTextureUv = ( shadeMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;
    material.shadeColor *= texture2D( shadeMultiplyTexture, shadeMultiplyTextureUv ).rgb;
  #endif

  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )
    material.shadeColor.rgb *= vColor;
  #endif

  material.shadingShift = shadingShiftFactor;
  #ifdef USE_SHADINGSHIFTTEXTURE
    vec2 shadingShiftTextureUv = ( shadingShiftTextureUvTransform * vec3( uv, 1 ) ).xy;
    material.shadingShift += texture2D( shadingShiftTexture, shadingShiftTextureUv ).r * shadingShiftTextureScale;
  #endif

  // #include <lights_fragment_begin>

  // MToon Specific changes:
  // Since we want to take shadows into account of shading instead of irradiance,
  // we had to modify the codes that multiplies the results of shadowmap into color of direct lights.

  // COMPAT: pre-r156 uses a struct GeometricContext
  #if THREE_VRM_THREE_REVISION >= 157
    vec3 geometryPosition = - vViewPosition;
    vec3 geometryNormal = normal;
    vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

    vec3 geometryClearcoatNormal;

    #ifdef USE_CLEARCOAT

      geometryClearcoatNormal = clearcoatNormal;

    #endif
  #else
    GeometricContext geometry;

    geometry.position = - vViewPosition;
    geometry.normal = normal;
    geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

    #ifdef USE_CLEARCOAT

      geometry.clearcoatNormal = clearcoatNormal;

    #endif
  #endif

  IncidentLight directLight;

  // since these variables will be used in unrolled loop, we have to define in prior
  float shadow;

  #if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

    PointLight pointLight;
    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
    PointLightShadow pointLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

      pointLight = pointLights[ i ];

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        getPointLightInfo( pointLight, geometryPosition, directLight );
      #else
        getPointLightInfo( pointLight, geometry, directLight );
      #endif

      shadow = 1.0;
      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
      pointLightShadow = pointLightShadows[ i ];
      // COMPAT: pre-r166
      // r166 introduced shadowIntensity
      #if THREE_VRM_THREE_REVISION >= 166
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
      #else
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
      #endif
      #endif

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );
      #else
        RE_Direct( directLight, geometry, material, shadow, reflectedLight );
      #endif

    }
    #pragma unroll_loop_end

  #endif

  #if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

    SpotLight spotLight;
    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
    SpotLightShadow spotLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

      spotLight = spotLights[ i ];

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        getSpotLightInfo( spotLight, geometryPosition, directLight );
      #else
        getSpotLightInfo( spotLight, geometry, directLight );
      #endif

      shadow = 1.0;
      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
      spotLightShadow = spotLightShadows[ i ];
      // COMPAT: pre-r166
      // r166 introduced shadowIntensity
      #if THREE_VRM_THREE_REVISION >= 166
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
      #else
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
      #endif
      #endif

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );
      #else
        RE_Direct( directLight, geometry, material, shadow, reflectedLight );
      #endif

    }
    #pragma unroll_loop_end

  #endif

  #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

    DirectionalLight directionalLight;
    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
    DirectionalLightShadow directionalLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

      directionalLight = directionalLights[ i ];

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        getDirectionalLightInfo( directionalLight, directLight );
      #else
        getDirectionalLightInfo( directionalLight, geometry, directLight );
      #endif

      shadow = 1.0;
      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
      directionalLightShadow = directionalLightShadows[ i ];
      // COMPAT: pre-r166
      // r166 introduced shadowIntensity
      #if THREE_VRM_THREE_REVISION >= 166
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
      #else
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
      #endif
      #endif

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );
      #else
        RE_Direct( directLight, geometry, material, shadow, reflectedLight );
      #endif

    }
    #pragma unroll_loop_end

  #endif

  // #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

  //   RectAreaLight rectAreaLight;

  //   #pragma unroll_loop_start
  //   for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

  //     rectAreaLight = rectAreaLights[ i ];
  //     RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

  //   }
  //   #pragma unroll_loop_end

  // #endif

  #if defined( RE_IndirectDiffuse )

    vec3 iblIrradiance = vec3( 0.0 );

    vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

    // COMPAT: pre-r156 uses a struct GeometricContext
    // COMPAT: pre-r156 doesn't have a define USE_LIGHT_PROBES
    #if THREE_VRM_THREE_REVISION >= 157
      #if defined( USE_LIGHT_PROBES )
        irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
      #endif
    #else
      irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
    #endif

    #if ( NUM_HEMI_LIGHTS > 0 )

      #pragma unroll_loop_start
      for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

        // COMPAT: pre-r156 uses a struct GeometricContext
        #if THREE_VRM_THREE_REVISION >= 157
          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
        #else
          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
        #endif

      }
      #pragma unroll_loop_end

    #endif

  #endif

  // #if defined( RE_IndirectSpecular )

  //   vec3 radiance = vec3( 0.0 );
  //   vec3 clearcoatRadiance = vec3( 0.0 );

  // #endif

  #include <lights_fragment_maps>
  #include <lights_fragment_end>

  // modulation
  #include <aomap_fragment>

  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;

  #ifdef DEBUG_LITSHADERATE
    gl_FragColor = vec4( col, diffuseColor.a );
    postCorrection();
    return;
  #endif

  // -- MToon: rim lighting -----------------------------------------
  vec3 viewDir = normalize( vViewPosition );

  #ifndef PHYSICALLY_CORRECT_LIGHTS
    reflectedLight.directSpecular /= PI;
  #endif
  vec3 rimMix = mix( vec3( 1.0 ), reflectedLight.directSpecular, 1.0 );

  vec3 rim = parametricRimColorFactor * pow( saturate( 1.0 - dot( viewDir, normal ) + parametricRimLiftFactor ), parametricRimFresnelPowerFactor );

  #ifdef USE_MATCAPTEXTURE
    {
      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );
      vec3 y = cross( viewDir, x ); // guaranteed to be normalized
      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );
      sphereUv = ( matcapTextureUvTransform * vec3( sphereUv, 1 ) ).xy;
      vec3 matcap = texture2D( matcapTexture, sphereUv ).rgb;
      rim += matcapFactor * matcap;
    }
  #endif

  #ifdef USE_RIMMULTIPLYTEXTURE
    vec2 rimMultiplyTextureUv = ( rimMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;
    rim *= texture2D( rimMultiplyTexture, rimMultiplyTextureUv ).rgb;
  #endif

  col += rimMix * rim;

  // -- MToon: Emission --------------------------------------------------------
  col += totalEmissiveRadiance;

  // #include <envmap_fragment>

  // -- Almost done! -----------------------------------------------------------
  #if defined( OUTLINE )
    col = outlineColorFactor.rgb * mix( vec3( 1.0 ), col, outlineLightingMixFactor );
  #endif

  #ifdef OPAQUE
    diffuseColor.a = 1.0;
  #endif

  gl_FragColor = vec4( col, diffuseColor.a );
  postCorrection();
}
`,gd={None:"none",Normal:"normal",LitShadeRate:"litShadeRate",UV:"uv"},qi={None:"none",WorldCoordinates:"worldCoordinates",ScreenCoordinates:"screenCoordinates"},Ad={3e3:"",3001:"srgb"};function Ks(l){return parseInt(ws,10)>=152?l.colorSpace:Ad[l.encoding]}var yd=class extends mn{constructor(l={}){var e;super({vertexShader:pd,fragmentShader:md}),this.uvAnimationScrollXSpeedFactor=0,this.uvAnimationScrollYSpeedFactor=0,this.uvAnimationRotationSpeedFactor=0,this.fog=!0,this.normalMapType=El,this._ignoreVertexColor=!0,this._v0CompatShade=!1,this._debugMode=gd.None,this._outlineWidthMode=qi.None,this._isOutline=!1,l.transparentWithZWrite&&(l.depthWrite=!0),delete l.transparentWithZWrite,l.fog=!0,l.lights=!0,l.clipping=!0,this.uniforms=bl.merge([Tn.common,Tn.normalmap,Tn.emissivemap,Tn.fog,Tn.lights,{litFactor:{value:new Se(1,1,1)},mapUvTransform:{value:new We},colorAlpha:{value:1},normalMapUvTransform:{value:new We},shadeColorFactor:{value:new Se(0,0,0)},shadeMultiplyTexture:{value:null},shadeMultiplyTextureUvTransform:{value:new We},shadingShiftFactor:{value:0},shadingShiftTexture:{value:null},shadingShiftTextureUvTransform:{value:new We},shadingShiftTextureScale:{value:1},shadingToonyFactor:{value:.9},giEqualizationFactor:{value:.9},matcapFactor:{value:new Se(1,1,1)},matcapTexture:{value:null},matcapTextureUvTransform:{value:new We},parametricRimColorFactor:{value:new Se(0,0,0)},rimMultiplyTexture:{value:null},rimMultiplyTextureUvTransform:{value:new We},rimLightingMixFactor:{value:1},parametricRimFresnelPowerFactor:{value:5},parametricRimLiftFactor:{value:0},emissive:{value:new Se(0,0,0)},emissiveIntensity:{value:1},emissiveMapUvTransform:{value:new We},outlineWidthMultiplyTexture:{value:null},outlineWidthMultiplyTextureUvTransform:{value:new We},outlineWidthFactor:{value:0},outlineColorFactor:{value:new Se(0,0,0)},outlineLightingMixFactor:{value:1},uvAnimationMaskTexture:{value:null},uvAnimationMaskTextureUvTransform:{value:new We},uvAnimationScrollXOffset:{value:0},uvAnimationScrollYOffset:{value:0},uvAnimationRotationPhase:{value:0}},(e=l.uniforms)!=null?e:{}]),this.setValues(l),this._uploadUniformsWorkaround(),this.customProgramCacheKey=()=>[...Object.entries(this._generateDefines()).map(([t,n])=>`${t}:${n}`),this.matcapTexture?`matcapTextureColorSpace:${Ks(this.matcapTexture)}`:"",this.shadeMultiplyTexture?`shadeMultiplyTextureColorSpace:${Ks(this.shadeMultiplyTexture)}`:"",this.rimMultiplyTexture?`rimMultiplyTextureColorSpace:${Ks(this.rimMultiplyTexture)}`:""].join(","),this.onBeforeCompile=t=>{const n=parseInt(ws,10),s=Object.entries(Gi(Gi({},this._generateDefines()),this.defines)).filter(([r,i])=>!!i).map(([r,i])=>`#define ${r} ${i}`).join(`
`)+`
`;t.vertexShader=s+t.vertexShader,t.fragmentShader=s+t.fragmentShader,n<154&&(t.fragmentShader=t.fragmentShader.replace("#include <colorspace_fragment>","#include <encodings_fragment>"))}}get color(){return this.uniforms.litFactor.value}set color(l){this.uniforms.litFactor.value=l}get map(){return this.uniforms.map.value}set map(l){this.uniforms.map.value=l}get normalMap(){return this.uniforms.normalMap.value}set normalMap(l){this.uniforms.normalMap.value=l}get normalScale(){return this.uniforms.normalScale.value}set normalScale(l){this.uniforms.normalScale.value=l}get emissive(){return this.uniforms.emissive.value}set emissive(l){this.uniforms.emissive.value=l}get emissiveIntensity(){return this.uniforms.emissiveIntensity.value}set emissiveIntensity(l){this.uniforms.emissiveIntensity.value=l}get emissiveMap(){return this.uniforms.emissiveMap.value}set emissiveMap(l){this.uniforms.emissiveMap.value=l}get shadeColorFactor(){return this.uniforms.shadeColorFactor.value}set shadeColorFactor(l){this.uniforms.shadeColorFactor.value=l}get shadeMultiplyTexture(){return this.uniforms.shadeMultiplyTexture.value}set shadeMultiplyTexture(l){this.uniforms.shadeMultiplyTexture.value=l}get shadingShiftFactor(){return this.uniforms.shadingShiftFactor.value}set shadingShiftFactor(l){this.uniforms.shadingShiftFactor.value=l}get shadingShiftTexture(){return this.uniforms.shadingShiftTexture.value}set shadingShiftTexture(l){this.uniforms.shadingShiftTexture.value=l}get shadingShiftTextureScale(){return this.uniforms.shadingShiftTextureScale.value}set shadingShiftTextureScale(l){this.uniforms.shadingShiftTextureScale.value=l}get shadingToonyFactor(){return this.uniforms.shadingToonyFactor.value}set shadingToonyFactor(l){this.uniforms.shadingToonyFactor.value=l}get giEqualizationFactor(){return this.uniforms.giEqualizationFactor.value}set giEqualizationFactor(l){this.uniforms.giEqualizationFactor.value=l}get matcapFactor(){return this.uniforms.matcapFactor.value}set matcapFactor(l){this.uniforms.matcapFactor.value=l}get matcapTexture(){return this.uniforms.matcapTexture.value}set matcapTexture(l){this.uniforms.matcapTexture.value=l}get parametricRimColorFactor(){return this.uniforms.parametricRimColorFactor.value}set parametricRimColorFactor(l){this.uniforms.parametricRimColorFactor.value=l}get rimMultiplyTexture(){return this.uniforms.rimMultiplyTexture.value}set rimMultiplyTexture(l){this.uniforms.rimMultiplyTexture.value=l}get rimLightingMixFactor(){return this.uniforms.rimLightingMixFactor.value}set rimLightingMixFactor(l){this.uniforms.rimLightingMixFactor.value=l}get parametricRimFresnelPowerFactor(){return this.uniforms.parametricRimFresnelPowerFactor.value}set parametricRimFresnelPowerFactor(l){this.uniforms.parametricRimFresnelPowerFactor.value=l}get parametricRimLiftFactor(){return this.uniforms.parametricRimLiftFactor.value}set parametricRimLiftFactor(l){this.uniforms.parametricRimLiftFactor.value=l}get outlineWidthMultiplyTexture(){return this.uniforms.outlineWidthMultiplyTexture.value}set outlineWidthMultiplyTexture(l){this.uniforms.outlineWidthMultiplyTexture.value=l}get outlineWidthFactor(){return this.uniforms.outlineWidthFactor.value}set outlineWidthFactor(l){this.uniforms.outlineWidthFactor.value=l}get outlineColorFactor(){return this.uniforms.outlineColorFactor.value}set outlineColorFactor(l){this.uniforms.outlineColorFactor.value=l}get outlineLightingMixFactor(){return this.uniforms.outlineLightingMixFactor.value}set outlineLightingMixFactor(l){this.uniforms.outlineLightingMixFactor.value=l}get uvAnimationMaskTexture(){return this.uniforms.uvAnimationMaskTexture.value}set uvAnimationMaskTexture(l){this.uniforms.uvAnimationMaskTexture.value=l}get uvAnimationScrollXOffset(){return this.uniforms.uvAnimationScrollXOffset.value}set uvAnimationScrollXOffset(l){this.uniforms.uvAnimationScrollXOffset.value=l}get uvAnimationScrollYOffset(){return this.uniforms.uvAnimationScrollYOffset.value}set uvAnimationScrollYOffset(l){this.uniforms.uvAnimationScrollYOffset.value=l}get uvAnimationRotationPhase(){return this.uniforms.uvAnimationRotationPhase.value}set uvAnimationRotationPhase(l){this.uniforms.uvAnimationRotationPhase.value=l}get ignoreVertexColor(){return this._ignoreVertexColor}set ignoreVertexColor(l){this._ignoreVertexColor=l,this.needsUpdate=!0}get v0CompatShade(){return this._v0CompatShade}set v0CompatShade(l){this._v0CompatShade=l,this.needsUpdate=!0}get debugMode(){return this._debugMode}set debugMode(l){this._debugMode=l,this.needsUpdate=!0}get outlineWidthMode(){return this._outlineWidthMode}set outlineWidthMode(l){this._outlineWidthMode=l,this.needsUpdate=!0}get isOutline(){return this._isOutline}set isOutline(l){this._isOutline=l,this.needsUpdate=!0}get isMToonMaterial(){return!0}update(l){this._uploadUniformsWorkaround(),this._updateUVAnimation(l)}copy(l){return super.copy(l),this.map=l.map,this.normalMap=l.normalMap,this.emissiveMap=l.emissiveMap,this.shadeMultiplyTexture=l.shadeMultiplyTexture,this.shadingShiftTexture=l.shadingShiftTexture,this.matcapTexture=l.matcapTexture,this.rimMultiplyTexture=l.rimMultiplyTexture,this.outlineWidthMultiplyTexture=l.outlineWidthMultiplyTexture,this.uvAnimationMaskTexture=l.uvAnimationMaskTexture,this.normalMapType=l.normalMapType,this.uvAnimationScrollXSpeedFactor=l.uvAnimationScrollXSpeedFactor,this.uvAnimationScrollYSpeedFactor=l.uvAnimationScrollYSpeedFactor,this.uvAnimationRotationSpeedFactor=l.uvAnimationRotationSpeedFactor,this.ignoreVertexColor=l.ignoreVertexColor,this.v0CompatShade=l.v0CompatShade,this.debugMode=l.debugMode,this.outlineWidthMode=l.outlineWidthMode,this.isOutline=l.isOutline,this.needsUpdate=!0,this}_updateUVAnimation(l){this.uniforms.uvAnimationScrollXOffset.value+=l*this.uvAnimationScrollXSpeedFactor,this.uniforms.uvAnimationScrollYOffset.value+=l*this.uvAnimationScrollYSpeedFactor,this.uniforms.uvAnimationRotationPhase.value+=l*this.uvAnimationRotationSpeedFactor,this.uniforms.alphaTest.value=this.alphaTest,this.uniformsNeedUpdate=!0}_uploadUniformsWorkaround(){this.uniforms.opacity.value=this.opacity,this._updateTextureMatrix(this.uniforms.map,this.uniforms.mapUvTransform),this._updateTextureMatrix(this.uniforms.normalMap,this.uniforms.normalMapUvTransform),this._updateTextureMatrix(this.uniforms.emissiveMap,this.uniforms.emissiveMapUvTransform),this._updateTextureMatrix(this.uniforms.shadeMultiplyTexture,this.uniforms.shadeMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.shadingShiftTexture,this.uniforms.shadingShiftTextureUvTransform),this._updateTextureMatrix(this.uniforms.matcapTexture,this.uniforms.matcapTextureUvTransform),this._updateTextureMatrix(this.uniforms.rimMultiplyTexture,this.uniforms.rimMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.outlineWidthMultiplyTexture,this.uniforms.outlineWidthMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.uvAnimationMaskTexture,this.uniforms.uvAnimationMaskTextureUvTransform),this.uniformsNeedUpdate=!0}_generateDefines(){const l=parseInt(ws,10),e=this.outlineWidthMultiplyTexture!==null,t=this.map!==null||this.normalMap!==null||this.emissiveMap!==null||this.shadeMultiplyTexture!==null||this.shadingShiftTexture!==null||this.rimMultiplyTexture!==null||this.uvAnimationMaskTexture!==null;return{THREE_VRM_THREE_REVISION:l,OUTLINE:this._isOutline,MTOON_USE_UV:e||t,MTOON_UVS_VERTEX_ONLY:e&&!t,V0_COMPAT_SHADE:this._v0CompatShade,USE_SHADEMULTIPLYTEXTURE:this.shadeMultiplyTexture!==null,USE_SHADINGSHIFTTEXTURE:this.shadingShiftTexture!==null,USE_MATCAPTEXTURE:this.matcapTexture!==null,USE_RIMMULTIPLYTEXTURE:this.rimMultiplyTexture!==null,USE_OUTLINEWIDTHMULTIPLYTEXTURE:this._isOutline&&this.outlineWidthMultiplyTexture!==null,USE_UVANIMATIONMASKTEXTURE:this.uvAnimationMaskTexture!==null,IGNORE_VERTEX_COLOR:this._ignoreVertexColor===!0,DEBUG_NORMAL:this._debugMode==="normal",DEBUG_LITSHADERATE:this._debugMode==="litShadeRate",DEBUG_UV:this._debugMode==="uv",OUTLINE_WIDTH_SCREEN:this._isOutline&&this._outlineWidthMode===qi.ScreenCoordinates}}_updateTextureMatrix(l,e){l.value&&(l.value.matrixAutoUpdate&&l.value.updateMatrix(),e.value.copy(l.value.matrix))}},vd=new Set(["1.0","1.0-beta"]),_a=class gs{get name(){return gs.EXTENSION_NAME}constructor(e,t={}){var n,s,r,i;this.parser=e,this.materialType=(n=t.materialType)!=null?n:yd,this.renderOrderOffset=(s=t.renderOrderOffset)!=null?s:0,this.v0CompatShade=(r=t.v0CompatShade)!=null?r:!1,this.debugMode=(i=t.debugMode)!=null?i:"none",this._mToonMaterialSet=new Set}beforeRoot(){return Gt(this,null,function*(){this._removeUnlitExtensionIfMToonExists()})}afterRoot(e){return Gt(this,null,function*(){e.userData.vrmMToonMaterials=Array.from(this._mToonMaterialSet)})}getMaterialType(e){return this._getMToonExtension(e)?this.materialType:null}extendMaterialParams(e,t){const n=this._getMToonExtension(e);return n?this._extendMaterialParams(n,t):null}loadMesh(e){return Gt(this,null,function*(){var t;const n=this.parser,r=(t=n.json.meshes)==null?void 0:t[e];if(r==null)throw new Error(`MToonMaterialLoaderPlugin: Attempt to use meshes[${e}] of glTF but the mesh doesn't exist`);const i=r.primitives,o=yield n.loadMesh(e);if(i.length===1){const a=o,c=i[0].material;c!=null&&this._setupPrimitive(a,c)}else{const a=o;for(let c=0;c<i.length;c++){const d=a.children[c],u=i[c].material;u!=null&&this._setupPrimitive(d,u)}}return o})}_removeUnlitExtensionIfMToonExists(){const n=this.parser.json.materials;n?.map((s,r)=>{var i;this._getMToonExtension(r)&&((i=s.extensions)!=null&&i.KHR_materials_unlit)&&delete s.extensions.KHR_materials_unlit})}_getMToonExtension(e){var t,n;const i=(t=this.parser.json.materials)==null?void 0:t[e];if(i==null){console.warn(`MToonMaterialLoaderPlugin: Attempt to use materials[${e}] of glTF but the material doesn't exist`);return}const o=(n=i.extensions)==null?void 0:n[gs.EXTENSION_NAME];if(o==null)return;const a=o.specVersion;if(!vd.has(a)){console.warn(`MToonMaterialLoaderPlugin: Unknown ${gs.EXTENSION_NAME} specVersion "${a}"`);return}return o}_extendMaterialParams(e,t){return Gt(this,null,function*(){var n;delete t.metalness,delete t.roughness;const s=new fd(this.parser,t);s.assignPrimitive("transparentWithZWrite",e.transparentWithZWrite),s.assignColor("shadeColorFactor",e.shadeColorFactor),s.assignTexture("shadeMultiplyTexture",e.shadeMultiplyTexture,!0),s.assignPrimitive("shadingShiftFactor",e.shadingShiftFactor),s.assignTexture("shadingShiftTexture",e.shadingShiftTexture,!0),s.assignPrimitive("shadingShiftTextureScale",(n=e.shadingShiftTexture)==null?void 0:n.scale),s.assignPrimitive("shadingToonyFactor",e.shadingToonyFactor),s.assignPrimitive("giEqualizationFactor",e.giEqualizationFactor),s.assignColor("matcapFactor",e.matcapFactor),s.assignTexture("matcapTexture",e.matcapTexture,!0),s.assignColor("parametricRimColorFactor",e.parametricRimColorFactor),s.assignTexture("rimMultiplyTexture",e.rimMultiplyTexture,!0),s.assignPrimitive("rimLightingMixFactor",e.rimLightingMixFactor),s.assignPrimitive("parametricRimFresnelPowerFactor",e.parametricRimFresnelPowerFactor),s.assignPrimitive("parametricRimLiftFactor",e.parametricRimLiftFactor),s.assignPrimitive("outlineWidthMode",e.outlineWidthMode),s.assignPrimitive("outlineWidthFactor",e.outlineWidthFactor),s.assignTexture("outlineWidthMultiplyTexture",e.outlineWidthMultiplyTexture,!1),s.assignColor("outlineColorFactor",e.outlineColorFactor),s.assignPrimitive("outlineLightingMixFactor",e.outlineLightingMixFactor),s.assignTexture("uvAnimationMaskTexture",e.uvAnimationMaskTexture,!1),s.assignPrimitive("uvAnimationScrollXSpeedFactor",e.uvAnimationScrollXSpeedFactor),s.assignPrimitive("uvAnimationScrollYSpeedFactor",e.uvAnimationScrollYSpeedFactor),s.assignPrimitive("uvAnimationRotationSpeedFactor",e.uvAnimationRotationSpeedFactor),s.assignPrimitive("v0CompatShade",this.v0CompatShade),s.assignPrimitive("debugMode",this.debugMode),yield s.pending})}_setupPrimitive(e,t){const n=this._getMToonExtension(t);if(n){const s=this._parseRenderOrder(n);e.renderOrder=s+this.renderOrderOffset,this._generateOutline(e),this._addToMaterialSet(e);return}}_shouldGenerateOutline(e){return typeof e.outlineWidthMode=="string"&&e.outlineWidthMode!=="none"&&typeof e.outlineWidthFactor=="number"&&e.outlineWidthFactor>0}_generateOutline(e){const t=e.material;if(!(t instanceof fs)||!this._shouldGenerateOutline(t))return;e.material=[t];const n=t.clone();n.name+=" (Outline)",n.isOutline=!0,n.side=jo,e.material.push(n);const s=e.geometry,r=s.index?s.index.count:s.attributes.position.count/3;s.addGroup(0,r,0),s.addGroup(0,r,1)}_addToMaterialSet(e){const t=e.material,n=new Set;Array.isArray(t)?t.forEach(s=>n.add(s)):n.add(t);for(const s of n)this._mToonMaterialSet.add(s)}_parseRenderOrder(e){var t;return(e.transparentWithZWrite?0:19)+((t=e.renderQueueOffsetNumber)!=null?t:0)}};_a.EXTENSION_NAME="VRMC_materials_mtoon";var xd=_a,Sd=(l,e,t)=>new Promise((n,s)=>{var r=a=>{try{o(t.next(a))}catch(c){s(c)}},i=a=>{try{o(t.throw(a))}catch(c){s(c)}},o=a=>a.done?n(a.value):Promise.resolve(a.value).then(r,i);o((t=t.apply(l,e)).next())}),Ca=class Er{get name(){return Er.EXTENSION_NAME}constructor(e){this.parser=e}extendMaterialParams(e,t){return Sd(this,null,function*(){const n=this._getHDREmissiveMultiplierExtension(e);if(n==null)return;console.warn("VRMMaterialsHDREmissiveMultiplierLoaderPlugin: `VRMC_materials_hdr_emissiveMultiplier` is archived. Use `KHR_materials_emissive_strength` instead.");const s=n.emissiveMultiplier;t.emissiveIntensity=s})}_getHDREmissiveMultiplierExtension(e){var t,n;const i=(t=this.parser.json.materials)==null?void 0:t[e];if(i==null){console.warn(`VRMMaterialsHDREmissiveMultiplierLoaderPlugin: Attempt to use materials[${e}] of glTF but the material doesn't exist`);return}const o=(n=i.extensions)==null?void 0:n[Er.EXTENSION_NAME];if(o!=null)return o}};Ca.EXTENSION_NAME="VRMC_materials_hdr_emissiveMultiplier";var wd=Ca,_d=Object.defineProperty,Cd=Object.defineProperties,Td=Object.getOwnPropertyDescriptors,Xi=Object.getOwnPropertySymbols,Md=Object.prototype.hasOwnProperty,Ed=Object.prototype.propertyIsEnumerable,Ki=(l,e,t)=>e in l?_d(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t,xt=(l,e)=>{for(var t in e||(e={}))Md.call(e,t)&&Ki(l,t,e[t]);if(Xi)for(var t of Xi(e))Ed.call(e,t)&&Ki(l,t,e[t]);return l},Yi=(l,e)=>Cd(l,Td(e)),bd=(l,e,t)=>new Promise((n,s)=>{var r=a=>{try{o(t.next(a))}catch(c){s(c)}},i=a=>{try{o(t.throw(a))}catch(c){s(c)}},o=a=>a.done?n(a.value):Promise.resolve(a.value).then(r,i);o((t=t.apply(l,e)).next())});function sn(l){return Math.pow(l,2.2)}var Id=class{get name(){return"VRMMaterialsV0CompatPlugin"}constructor(l){var e;this.parser=l,this._renderQueueMapTransparent=new Map,this._renderQueueMapTransparentZWrite=new Map;const t=this.parser.json;t.extensionsUsed=(e=t.extensionsUsed)!=null?e:[],t.extensionsUsed.indexOf("KHR_texture_transform")===-1&&t.extensionsUsed.push("KHR_texture_transform")}beforeRoot(){return bd(this,null,function*(){var l;const e=this.parser.json,t=(l=e.extensions)==null?void 0:l.VRM,n=t?.materialProperties;n&&(this._populateRenderQueueMap(n),n.forEach((s,r)=>{var i,o;const a=(i=e.materials)==null?void 0:i[r];if(a==null){console.warn(`VRMMaterialsV0CompatPlugin: Attempt to use materials[${r}] of glTF but the material doesn't exist`);return}if(s.shader==="VRM/MToon"){const c=this._parseV0MToonProperties(s,a);e.materials[r]=c}else if((o=s.shader)!=null&&o.startsWith("VRM/Unlit")){const c=this._parseV0UnlitProperties(s,a);e.materials[r]=c}else s.shader==="VRM_USE_GLTFSHADER"||console.warn(`VRMMaterialsV0CompatPlugin: Unknown shader: ${s.shader}`)}))})}_parseV0MToonProperties(l,e){var t,n,s,r,i,o,a,c,d,u,f,h,g,p,m,A,y,v,x,w,T,C,E,I,P,B,M,D,_,k,G,O,$,U,Z,V,z,ne,te,J,ue,me,de,fe,q,X,ie,ee,S,N,W,R,b,L,K;const Y=(n=(t=l.keywordMap)==null?void 0:t._ALPHABLEND_ON)!=null?n:!1,se=((s=l.floatProperties)==null?void 0:s._ZWrite)===1&&Y,le=this._v0ParseRenderQueue(l),re=(i=(r=l.keywordMap)==null?void 0:r._ALPHATEST_ON)!=null?i:!1,pe=Y?"BLEND":re?"MASK":"OPAQUE",Ce=re?(a=(o=l.floatProperties)==null?void 0:o._Cutoff)!=null?a:.5:void 0,Xe=((d=(c=l.floatProperties)==null?void 0:c._CullMode)!=null?d:2)===0,Ke=this._portTextureTransform(l),Ye=((f=(u=l.vectorProperties)==null?void 0:u._Color)!=null?f:[1,1,1,1]).map((ii,nl)=>nl===3?ii:sn(ii)),H=(h=l.textureProperties)==null?void 0:h._MainTex,ae=H!=null?{index:H,extensions:xt({},Ke)}:void 0,be=(p=(g=l.floatProperties)==null?void 0:g._BumpScale)!=null?p:1,Re=(m=l.textureProperties)==null?void 0:m._BumpMap,Be=Re!=null?{index:Re,scale:be,extensions:xt({},Ke)}:void 0,mt=((y=(A=l.vectorProperties)==null?void 0:A._EmissionColor)!=null?y:[0,0,0,1]).map(sn),lt=(v=l.textureProperties)==null?void 0:v._EmissionMap,Xn=lt!=null?{index:lt,extensions:xt({},Ke)}:void 0,Xt=((w=(x=l.vectorProperties)==null?void 0:x._ShadeColor)!=null?w:[.97,.81,.86,1]).map(sn),$e=(T=l.textureProperties)==null?void 0:T._ShadeTexture,Qe=$e!=null?{index:$e,extensions:xt({},Ke)}:void 0;let it=(E=(C=l.floatProperties)==null?void 0:C._ShadeShift)!=null?E:0,yt=(P=(I=l.floatProperties)==null?void 0:I._ShadeToony)!=null?P:.9;yt=Ae.lerp(yt,1,.5+.5*it),it=-it-(1-yt);const Dt=(M=(B=l.floatProperties)==null?void 0:B._IndirectLightIntensity)!=null?M:.1,Kt=Dt?1-Dt:void 0,Ls=(D=l.textureProperties)==null?void 0:D._SphereAdd,Ha=Ls!=null?[1,1,1]:void 0,Va=Ls!=null?{index:Ls}:void 0,Wa=(k=(_=l.floatProperties)==null?void 0:_._RimLightingMix)!=null?k:0,ni=(G=l.textureProperties)==null?void 0:G._RimTexture,ja=ni!=null?{index:ni,extensions:xt({},Ke)}:void 0,Qa=(($=(O=l.vectorProperties)==null?void 0:O._RimColor)!=null?$:[0,0,0,1]).map(sn),Ga=(Z=(U=l.floatProperties)==null?void 0:U._RimFresnelPower)!=null?Z:1,qa=(z=(V=l.floatProperties)==null?void 0:V._RimLift)!=null?z:0,Xa=["none","worldCoordinates","screenCoordinates"][(te=(ne=l.floatProperties)==null?void 0:ne._OutlineWidthMode)!=null?te:0];let ks=(ue=(J=l.floatProperties)==null?void 0:J._OutlineWidth)!=null?ue:0;ks=.01*ks;const si=(me=l.textureProperties)==null?void 0:me._OutlineWidthTexture,Ka=si!=null?{index:si,extensions:xt({},Ke)}:void 0,Ya=((fe=(de=l.vectorProperties)==null?void 0:de._OutlineColor)!=null?fe:[0,0,0]).map(sn),Za=((X=(q=l.floatProperties)==null?void 0:q._OutlineColorMode)!=null?X:0)===1?(ee=(ie=l.floatProperties)==null?void 0:ie._OutlineLightingMix)!=null?ee:1:0,ri=(S=l.textureProperties)==null?void 0:S._UvAnimMaskTexture,Ja=ri!=null?{index:ri,extensions:xt({},Ke)}:void 0,$a=(W=(N=l.floatProperties)==null?void 0:N._UvAnimScrollX)!=null?W:0;let Kn=(b=(R=l.floatProperties)==null?void 0:R._UvAnimScrollY)!=null?b:0;Kn!=null&&(Kn=-Kn);const el=(K=(L=l.floatProperties)==null?void 0:L._UvAnimRotation)!=null?K:0,tl={specVersion:"1.0",transparentWithZWrite:se,renderQueueOffsetNumber:le,shadeColorFactor:Xt,shadeMultiplyTexture:Qe,shadingShiftFactor:it,shadingToonyFactor:yt,giEqualizationFactor:Kt,matcapFactor:Ha,matcapTexture:Va,rimLightingMixFactor:Wa,rimMultiplyTexture:ja,parametricRimColorFactor:Qa,parametricRimFresnelPowerFactor:Ga,parametricRimLiftFactor:qa,outlineWidthMode:Xa,outlineWidthFactor:ks,outlineWidthMultiplyTexture:Ka,outlineColorFactor:Ya,outlineLightingMixFactor:Za,uvAnimationMaskTexture:Ja,uvAnimationScrollXSpeedFactor:$a,uvAnimationScrollYSpeedFactor:Kn,uvAnimationRotationSpeedFactor:el};return Yi(xt({},e),{pbrMetallicRoughness:{baseColorFactor:Ye,baseColorTexture:ae},normalTexture:Be,emissiveTexture:Xn,emissiveFactor:mt,alphaMode:pe,alphaCutoff:Ce,doubleSided:Xe,extensions:{VRMC_materials_mtoon:tl}})}_parseV0UnlitProperties(l,e){var t,n,s,r,i;const o=l.shader==="VRM/UnlitTransparentZWrite",a=l.shader==="VRM/UnlitTransparent"||o,c=this._v0ParseRenderQueue(l),d=l.shader==="VRM/UnlitCutout",u=a?"BLEND":d?"MASK":"OPAQUE",f=d?(n=(t=l.floatProperties)==null?void 0:t._Cutoff)!=null?n:.5:void 0,h=this._portTextureTransform(l),g=((r=(s=l.vectorProperties)==null?void 0:s._Color)!=null?r:[1,1,1,1]).map(sn),p=(i=l.textureProperties)==null?void 0:i._MainTex,m=p!=null?{index:p,extensions:xt({},h)}:void 0,A={specVersion:"1.0",transparentWithZWrite:o,renderQueueOffsetNumber:c,shadeColorFactor:g,shadeMultiplyTexture:m};return Yi(xt({},e),{pbrMetallicRoughness:{baseColorFactor:g,baseColorTexture:m},alphaMode:u,alphaCutoff:f,extensions:{VRMC_materials_mtoon:A}})}_portTextureTransform(l){var e,t,n,s,r;const i=(e=l.vectorProperties)==null?void 0:e._MainTex;if(i==null)return{};const o=[(t=i?.[0])!=null?t:0,(n=i?.[1])!=null?n:0],a=[(s=i?.[2])!=null?s:1,(r=i?.[3])!=null?r:1];return o[1]=1-a[1]-o[1],{KHR_texture_transform:{offset:o,scale:a}}}_v0ParseRenderQueue(l){var e,t;const n=l.shader==="VRM/UnlitTransparentZWrite",s=((e=l.keywordMap)==null?void 0:e._ALPHABLEND_ON)!=null||l.shader==="VRM/UnlitTransparent"||n,r=((t=l.floatProperties)==null?void 0:t._ZWrite)===1||n;let i=0;if(s){const o=l.renderQueue;o!=null&&(r?i=this._renderQueueMapTransparentZWrite.get(o):i=this._renderQueueMapTransparent.get(o))}return i}_populateRenderQueueMap(l){const e=new Set,t=new Set;l.forEach(n=>{var s,r;const i=n.shader==="VRM/UnlitTransparentZWrite",o=((s=n.keywordMap)==null?void 0:s._ALPHABLEND_ON)!=null||n.shader==="VRM/UnlitTransparent"||i,a=((r=n.floatProperties)==null?void 0:r._ZWrite)===1||i;if(o){const c=n.renderQueue;c!=null&&(a?t.add(c):e.add(c))}}),e.size>10&&console.warn(`VRMMaterialsV0CompatPlugin: This VRM uses ${e.size} render queues for Transparent materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`),t.size>10&&console.warn(`VRMMaterialsV0CompatPlugin: This VRM uses ${t.size} render queues for TransparentZWrite materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`),Array.from(e).sort().forEach((n,s)=>{const r=Math.min(Math.max(s-e.size+1,-9),0);this._renderQueueMapTransparent.set(n,r)}),Array.from(t).sort().forEach((n,s)=>{const r=Math.min(Math.max(s,0),9);this._renderQueueMapTransparentZWrite.set(n,r)})}},Zi=(l,e,t)=>new Promise((n,s)=>{var r=a=>{try{o(t.next(a))}catch(c){s(c)}},i=a=>{try{o(t.throw(a))}catch(c){s(c)}},o=a=>a.done?n(a.value):Promise.resolve(a.value).then(r,i);o((t=t.apply(l,e)).next())}),kt=new F,Ys=class extends Je{constructor(l){super(),this._attrPosition=new He(new Float32Array([0,0,0,0,0,0]),3),this._attrPosition.setUsage(Go);const e=new je;e.setAttribute("position",this._attrPosition);const t=new _n({color:16711935,depthTest:!1,depthWrite:!1});this._line=new Fr(e,t),this.add(this._line),this.constraint=l}updateMatrixWorld(l){kt.setFromMatrixPosition(this.constraint.destination.matrixWorld),this._attrPosition.setXYZ(0,kt.x,kt.y,kt.z),this.constraint.source&&kt.setFromMatrixPosition(this.constraint.source.matrixWorld),this._attrPosition.setXYZ(1,kt.x,kt.y,kt.z),this._attrPosition.needsUpdate=!0,super.updateMatrixWorld(l)}};function Ji(l,e){return e.set(l.elements[12],l.elements[13],l.elements[14])}var Rd=new F,Bd=new F;function Pd(l,e){return l.decompose(Rd,e,Bd),e}function Ts(l){return l.invert?l.invert():l.inverse(),l}var Or=class{constructor(l,e){this.destination=l,this.source=e,this.weight=1}},Dd=new F,Fd=new F,Ld=new F,kd=new ce,Od=new ce,Ud=new ce,Nd=class extends Or{get aimAxis(){return this._aimAxis}set aimAxis(l){this._aimAxis=l,this._v3AimAxis.set(l==="PositiveX"?1:l==="NegativeX"?-1:0,l==="PositiveY"?1:l==="NegativeY"?-1:0,l==="PositiveZ"?1:l==="NegativeZ"?-1:0)}get dependencies(){const l=new Set([this.source]);return this.destination.parent&&l.add(this.destination.parent),l}constructor(l,e){super(l,e),this._aimAxis="PositiveX",this._v3AimAxis=new F(1,0,0),this._dstRestQuat=new ce}setInitState(){this._dstRestQuat.copy(this.destination.quaternion)}update(){this.destination.updateWorldMatrix(!0,!1),this.source.updateWorldMatrix(!0,!1);const l=kd.identity(),e=Od.identity();this.destination.parent&&(Pd(this.destination.parent.matrixWorld,l),Ts(e.copy(l)));const t=Dd.copy(this._v3AimAxis).applyQuaternion(this._dstRestQuat).applyQuaternion(l),n=Ji(this.source.matrixWorld,Fd).sub(Ji(this.destination.matrixWorld,Ld)).normalize(),s=Ud.setFromUnitVectors(t,n).premultiply(e).multiply(l).multiply(this._dstRestQuat);this.destination.quaternion.copy(this._dstRestQuat).slerp(s,this.weight)}};function zd(l,e){const t=[l];let n=l.parent;for(;n!==null;)t.unshift(n),n=n.parent;t.forEach(s=>{e(s)})}var Hd=class{constructor(){this._constraints=new Set,this._objectConstraintsMap=new Map}get constraints(){return this._constraints}addConstraint(l){this._constraints.add(l);let e=this._objectConstraintsMap.get(l.destination);e==null&&(e=new Set,this._objectConstraintsMap.set(l.destination,e)),e.add(l)}deleteConstraint(l){this._constraints.delete(l),this._objectConstraintsMap.get(l.destination).delete(l)}setInitState(){const l=new Set,e=new Set;for(const t of this._constraints)this._processConstraint(t,l,e,n=>n.setInitState())}update(){const l=new Set,e=new Set;for(const t of this._constraints)this._processConstraint(t,l,e,n=>n.update())}_processConstraint(l,e,t,n){if(t.has(l))return;if(e.has(l))throw new Error("VRMNodeConstraintManager: Circular dependency detected while updating constraints");e.add(l);const s=l.dependencies;for(const r of s)zd(r,i=>{const o=this._objectConstraintsMap.get(i);if(o)for(const a of o)this._processConstraint(a,e,t,n)});n(l),t.add(l)}},Vd=new ce,Wd=new ce,jd=class extends Or{get dependencies(){return new Set([this.source])}constructor(l,e){super(l,e),this._dstRestQuat=new ce,this._invSrcRestQuat=new ce}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),Ts(this._invSrcRestQuat.copy(this.source.quaternion))}update(){const l=Vd.copy(this._invSrcRestQuat).multiply(this.source.quaternion),e=Wd.copy(this._dstRestQuat).multiply(l);this.destination.quaternion.copy(this._dstRestQuat).slerp(e,this.weight)}},Qd=new F,Gd=new ce,qd=new ce,Xd=class extends Or{get rollAxis(){return this._rollAxis}set rollAxis(l){this._rollAxis=l,this._v3RollAxis.set(l==="X"?1:0,l==="Y"?1:0,l==="Z"?1:0)}get dependencies(){return new Set([this.source])}constructor(l,e){super(l,e),this._rollAxis="X",this._v3RollAxis=new F(1,0,0),this._dstRestQuat=new ce,this._invDstRestQuat=new ce,this._invSrcRestQuatMulDstRestQuat=new ce}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),Ts(this._invDstRestQuat.copy(this._dstRestQuat)),Ts(this._invSrcRestQuatMulDstRestQuat.copy(this.source.quaternion)).multiply(this._dstRestQuat)}update(){const l=Gd.copy(this._invDstRestQuat).multiply(this.source.quaternion).multiply(this._invSrcRestQuatMulDstRestQuat),e=Qd.copy(this._v3RollAxis).applyQuaternion(l),n=qd.setFromUnitVectors(e,this._v3RollAxis).premultiply(this._dstRestQuat).multiply(l);this.destination.quaternion.copy(this._dstRestQuat).slerp(n,this.weight)}},Kd=new Set(["1.0","1.0-beta"]),Ta=class Dn{get name(){return Dn.EXTENSION_NAME}constructor(e,t){this.parser=e,this.helperRoot=t?.helperRoot}afterRoot(e){return Zi(this,null,function*(){e.userData.vrmNodeConstraintManager=yield this._import(e)})}_import(e){return Zi(this,null,function*(){var t;const n=this.parser.json;if(!(((t=n.extensionsUsed)==null?void 0:t.indexOf(Dn.EXTENSION_NAME))!==-1))return null;const r=new Hd,i=yield this.parser.getDependencies("node");return i.forEach((o,a)=>{var c;const d=n.nodes[a],u=(c=d?.extensions)==null?void 0:c[Dn.EXTENSION_NAME];if(u==null)return;const f=u.specVersion;if(!Kd.has(f)){console.warn(`VRMNodeConstraintLoaderPlugin: Unknown ${Dn.EXTENSION_NAME} specVersion "${f}"`);return}const h=u.constraint;if(h.roll!=null){const g=this._importRollConstraint(o,i,h.roll);r.addConstraint(g)}else if(h.aim!=null){const g=this._importAimConstraint(o,i,h.aim);r.addConstraint(g)}else if(h.rotation!=null){const g=this._importRotationConstraint(o,i,h.rotation);r.addConstraint(g)}}),e.scene.updateMatrixWorld(),r.setInitState(),r})}_importRollConstraint(e,t,n){const{source:s,rollAxis:r,weight:i}=n,o=t[s],a=new Xd(e,o);if(r!=null&&(a.rollAxis=r),i!=null&&(a.weight=i),this.helperRoot){const c=new Ys(a);this.helperRoot.add(c)}return a}_importAimConstraint(e,t,n){const{source:s,aimAxis:r,weight:i}=n,o=t[s],a=new Nd(e,o);if(r!=null&&(a.aimAxis=r),i!=null&&(a.weight=i),this.helperRoot){const c=new Ys(a);this.helperRoot.add(c)}return a}_importRotationConstraint(e,t,n){const{source:s,weight:r}=n,i=t[s],o=new jd(e,i);if(r!=null&&(o.weight=r),this.helperRoot){const a=new Ys(o);this.helperRoot.add(a)}return o}};Ta.EXTENSION_NAME="VRMC_node_constraint";var Yd=Ta,ns=(l,e,t)=>new Promise((n,s)=>{var r=a=>{try{o(t.next(a))}catch(c){s(c)}},i=a=>{try{o(t.throw(a))}catch(c){s(c)}},o=a=>a.done?n(a.value):Promise.resolve(a.value).then(r,i);o((t=t.apply(l,e)).next())}),Ur=class{},Zs=new F,jt=new F,Ma=class extends Ur{get type(){return"capsule"}constructor(l){var e,t,n,s;super(),this.offset=(e=l?.offset)!=null?e:new F(0,0,0),this.tail=(t=l?.tail)!=null?t:new F(0,0,0),this.radius=(n=l?.radius)!=null?n:0,this.inside=(s=l?.inside)!=null?s:!1}calculateCollision(l,e,t,n){Zs.setFromMatrixPosition(l),jt.subVectors(this.tail,this.offset).applyMatrix4(l),jt.sub(Zs);const s=jt.lengthSq();n.copy(e).sub(Zs);const r=jt.dot(n);r<=0||(s<=r||jt.multiplyScalar(r/s),n.sub(jt));const i=n.length(),o=this.inside?this.radius-t-i:i-t-this.radius;return o<0&&(n.multiplyScalar(1/i),this.inside&&n.negate()),o}},Js=new F,$i=new We,Ea=class extends Ur{get type(){return"plane"}constructor(l){var e,t;super(),this.offset=(e=l?.offset)!=null?e:new F(0,0,0),this.normal=(t=l?.normal)!=null?t:new F(0,0,1)}calculateCollision(l,e,t,n){n.setFromMatrixPosition(l),n.negate().add(e),$i.getNormalMatrix(l),Js.copy(this.normal).applyNormalMatrix($i).normalize();const s=n.dot(Js)-t;return n.copy(Js),s}},Zd=new F,ba=class extends Ur{get type(){return"sphere"}constructor(l){var e,t,n;super(),this.offset=(e=l?.offset)!=null?e:new F(0,0,0),this.radius=(t=l?.radius)!=null?t:0,this.inside=(n=l?.inside)!=null?n:!1}calculateCollision(l,e,t,n){n.subVectors(e,Zd.setFromMatrixPosition(l));const s=n.length(),r=this.inside?this.radius-t-s:s-t-this.radius;return r<0&&(n.multiplyScalar(1/s),this.inside&&n.negate()),r}},St=new F,Jd=class extends je{constructor(l){super(),this.worldScale=1,this._currentRadius=0,this._currentOffset=new F,this._currentTail=new F,this._shape=l,this._attrPos=new He(new Float32Array(396),3),this.setAttribute("position",this._attrPos),this._attrIndex=new He(new Uint16Array(264),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let l=!1;const e=this._shape.radius/this.worldScale;this._currentRadius!==e&&(this._currentRadius=e,l=!0),this._currentOffset.equals(this._shape.offset)||(this._currentOffset.copy(this._shape.offset),l=!0);const t=St.copy(this._shape.tail).divideScalar(this.worldScale);this._currentTail.distanceToSquared(t)>1e-10&&(this._currentTail.copy(t),l=!0),l&&this._buildPosition()}_buildPosition(){St.copy(this._currentTail).sub(this._currentOffset);const l=St.length()/this._currentRadius;for(let n=0;n<=16;n++){const s=n/16*Math.PI;this._attrPos.setXYZ(n,-Math.sin(s),-Math.cos(s),0),this._attrPos.setXYZ(17+n,l+Math.sin(s),Math.cos(s),0),this._attrPos.setXYZ(34+n,-Math.sin(s),0,-Math.cos(s)),this._attrPos.setXYZ(51+n,l+Math.sin(s),0,Math.cos(s))}for(let n=0;n<32;n++){const s=n/16*Math.PI;this._attrPos.setXYZ(68+n,0,Math.sin(s),Math.cos(s)),this._attrPos.setXYZ(100+n,l,Math.sin(s),Math.cos(s))}const e=Math.atan2(St.y,Math.sqrt(St.x*St.x+St.z*St.z)),t=-Math.atan2(St.z,St.x);this.rotateZ(e),this.rotateY(t),this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentOffset.x,this._currentOffset.y,this._currentOffset.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let l=0;l<34;l++){const e=(l+1)%34;this._attrIndex.setXY(l*2,l,e),this._attrIndex.setXY(68+l*2,34+l,34+e)}for(let l=0;l<32;l++){const e=(l+1)%32;this._attrIndex.setXY(136+l*2,68+l,68+e),this._attrIndex.setXY(200+l*2,100+l,100+e)}this._attrIndex.needsUpdate=!0}},$d=class extends je{constructor(l){super(),this.worldScale=1,this._currentOffset=new F,this._currentNormal=new F,this._shape=l,this._attrPos=new He(new Float32Array(6*3),3),this.setAttribute("position",this._attrPos),this._attrIndex=new He(new Uint16Array(10),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let l=!1;this._currentOffset.equals(this._shape.offset)||(this._currentOffset.copy(this._shape.offset),l=!0),this._currentNormal.equals(this._shape.normal)||(this._currentNormal.copy(this._shape.normal),l=!0),l&&this._buildPosition()}_buildPosition(){this._attrPos.setXYZ(0,-.5,-.5,0),this._attrPos.setXYZ(1,.5,-.5,0),this._attrPos.setXYZ(2,.5,.5,0),this._attrPos.setXYZ(3,-.5,.5,0),this._attrPos.setXYZ(4,0,0,0),this._attrPos.setXYZ(5,0,0,.25),this.translate(this._currentOffset.x,this._currentOffset.y,this._currentOffset.z),this.lookAt(this._currentNormal),this._attrPos.needsUpdate=!0}_buildIndex(){this._attrIndex.setXY(0,0,1),this._attrIndex.setXY(2,1,2),this._attrIndex.setXY(4,2,3),this._attrIndex.setXY(6,3,0),this._attrIndex.setXY(8,4,5),this._attrIndex.needsUpdate=!0}},eh=class extends je{constructor(l){super(),this.worldScale=1,this._currentRadius=0,this._currentOffset=new F,this._shape=l,this._attrPos=new He(new Float32Array(32*3*3),3),this.setAttribute("position",this._attrPos),this._attrIndex=new He(new Uint16Array(64*3),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let l=!1;const e=this._shape.radius/this.worldScale;this._currentRadius!==e&&(this._currentRadius=e,l=!0),this._currentOffset.equals(this._shape.offset)||(this._currentOffset.copy(this._shape.offset),l=!0),l&&this._buildPosition()}_buildPosition(){for(let l=0;l<32;l++){const e=l/16*Math.PI;this._attrPos.setXYZ(l,Math.cos(e),Math.sin(e),0),this._attrPos.setXYZ(32+l,0,Math.cos(e),Math.sin(e)),this._attrPos.setXYZ(64+l,Math.sin(e),0,Math.cos(e))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentOffset.x,this._currentOffset.y,this._currentOffset.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let l=0;l<32;l++){const e=(l+1)%32;this._attrIndex.setXY(l*2,l,e),this._attrIndex.setXY(64+l*2,32+l,32+e),this._attrIndex.setXY(128+l*2,64+l,64+e)}this._attrIndex.needsUpdate=!0}},th=new F,$s=class extends Je{constructor(l){if(super(),this.matrixAutoUpdate=!1,this.collider=l,this.collider.shape instanceof ba)this._geometry=new eh(this.collider.shape);else if(this.collider.shape instanceof Ma)this._geometry=new Jd(this.collider.shape);else if(this.collider.shape instanceof Ea)this._geometry=new $d(this.collider.shape);else throw new Error("VRMSpringBoneColliderHelper: Unknown collider shape type detected");const e=new _n({color:16711935,depthTest:!1,depthWrite:!1});this._line=new Ds(this._geometry,e),this.add(this._line)}dispose(){this._geometry.dispose()}updateMatrixWorld(l){this.collider.updateWorldMatrix(!0,!1),this.matrix.copy(this.collider.matrixWorld);const e=this.matrix.elements;this._geometry.worldScale=th.set(e[0],e[1],e[2]).length(),this._geometry.update(),super.updateMatrixWorld(l)}},nh=class extends je{constructor(l){super(),this.worldScale=1,this._currentRadius=0,this._currentTail=new F,this._springBone=l,this._attrPos=new He(new Float32Array(294),3),this.setAttribute("position",this._attrPos),this._attrIndex=new He(new Uint16Array(194),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let l=!1;const e=this._springBone.settings.hitRadius/this.worldScale;this._currentRadius!==e&&(this._currentRadius=e,l=!0),this._currentTail.equals(this._springBone.initialLocalChildPosition)||(this._currentTail.copy(this._springBone.initialLocalChildPosition),l=!0),l&&this._buildPosition()}_buildPosition(){for(let l=0;l<32;l++){const e=l/16*Math.PI;this._attrPos.setXYZ(l,Math.cos(e),Math.sin(e),0),this._attrPos.setXYZ(32+l,0,Math.cos(e),Math.sin(e)),this._attrPos.setXYZ(64+l,Math.sin(e),0,Math.cos(e))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.setXYZ(96,0,0,0),this._attrPos.setXYZ(97,this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let l=0;l<32;l++){const e=(l+1)%32;this._attrIndex.setXY(l*2,l,e),this._attrIndex.setXY(64+l*2,32+l,32+e),this._attrIndex.setXY(128+l*2,64+l,64+e)}this._attrIndex.setXY(192,96,97),this._attrIndex.needsUpdate=!0}},sh=new F,rh=class extends Je{constructor(l){super(),this.matrixAutoUpdate=!1,this.springBone=l,this._geometry=new nh(this.springBone);const e=new _n({color:16776960,depthTest:!1,depthWrite:!1});this._line=new Ds(this._geometry,e),this.add(this._line)}dispose(){this._geometry.dispose()}updateMatrixWorld(l){this.springBone.bone.updateWorldMatrix(!0,!1),this.matrix.copy(this.springBone.bone.matrixWorld);const e=this.matrix.elements;this._geometry.worldScale=sh.set(e[0],e[1],e[2]).length(),this._geometry.update(),super.updateMatrixWorld(l)}},er=class extends Ze{constructor(l){super(),this.colliderMatrix=new he,this.shape=l}updateWorldMatrix(l,e){super.updateWorldMatrix(l,e),ih(this.colliderMatrix,this.matrixWorld,this.shape.offset)}};function ih(l,e,t){const n=e.elements;l.copy(e),t&&(l.elements[12]=n[0]*t.x+n[4]*t.y+n[8]*t.z+n[12],l.elements[13]=n[1]*t.x+n[5]*t.y+n[9]*t.z+n[13],l.elements[14]=n[2]*t.x+n[6]*t.y+n[10]*t.z+n[14])}var oh=new he;function ah(l){return l.invert?l.invert():l.getInverse(oh.copy(l)),l}var lh=class{constructor(l){this._inverseCache=new he,this._shouldUpdateInverse=!0,this.matrix=l;const e={set:(t,n,s)=>(this._shouldUpdateInverse=!0,t[n]=s,!0)};this._originalElements=l.elements,l.elements=new Proxy(l.elements,e)}get inverse(){return this._shouldUpdateInverse&&(ah(this._inverseCache.copy(this.matrix)),this._shouldUpdateInverse=!1),this._inverseCache}revert(){this.matrix.elements=this._originalElements}},tr=new he,rn=new F,In=new F,Rn=new F,Bn=new F,ch=new he,uh=class{constructor(l,e,t={},n=[]){this._currentTail=new F,this._prevTail=new F,this._boneAxis=new F,this._worldSpaceBoneLength=0,this._center=null,this._initialLocalMatrix=new he,this._initialLocalRotation=new ce,this._initialLocalChildPosition=new F;var s,r,i,o,a,c;this.bone=l,this.bone.matrixAutoUpdate=!1,this.child=e,this.settings={hitRadius:(s=t.hitRadius)!=null?s:0,stiffness:(r=t.stiffness)!=null?r:1,gravityPower:(i=t.gravityPower)!=null?i:0,gravityDir:(a=(o=t.gravityDir)==null?void 0:o.clone())!=null?a:new F(0,-1,0),dragForce:(c=t.dragForce)!=null?c:.4},this.colliderGroups=n}get dependencies(){const l=new Set,e=this.bone.parent;e&&l.add(e);for(let t=0;t<this.colliderGroups.length;t++)for(let n=0;n<this.colliderGroups[t].colliders.length;n++)l.add(this.colliderGroups[t].colliders[n]);return l}get center(){return this._center}set center(l){var e;(e=this._center)!=null&&e.userData.inverseCacheProxy&&(this._center.userData.inverseCacheProxy.revert(),delete this._center.userData.inverseCacheProxy),this._center=l,this._center&&(this._center.userData.inverseCacheProxy||(this._center.userData.inverseCacheProxy=new lh(this._center.matrixWorld)))}get initialLocalChildPosition(){return this._initialLocalChildPosition}get _parentMatrixWorld(){return this.bone.parent?this.bone.parent.matrixWorld:tr}setInitState(){this._initialLocalMatrix.copy(this.bone.matrix),this._initialLocalRotation.copy(this.bone.quaternion),this.child?this._initialLocalChildPosition.copy(this.child.position):this._initialLocalChildPosition.copy(this.bone.position).normalize().multiplyScalar(.07);const l=this._getMatrixWorldToCenter();this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(l),this._prevTail.copy(this._currentTail),this._boneAxis.copy(this._initialLocalChildPosition).normalize()}reset(){this.bone.quaternion.copy(this._initialLocalRotation),this.bone.updateMatrix(),this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld,this.bone.matrix);const l=this._getMatrixWorldToCenter();this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(l),this._prevTail.copy(this._currentTail)}update(l){if(l<=0)return;this._calcWorldSpaceBoneLength();const e=In.copy(this._boneAxis).transformDirection(this._initialLocalMatrix).transformDirection(this._parentMatrixWorld);Bn.copy(this._currentTail).add(rn.subVectors(this._currentTail,this._prevTail).multiplyScalar(1-this.settings.dragForce)).applyMatrix4(this._getMatrixCenterToWorld()).addScaledVector(e,this.settings.stiffness*l).addScaledVector(this.settings.gravityDir,this.settings.gravityPower*l),Rn.setFromMatrixPosition(this.bone.matrixWorld),Bn.sub(Rn).normalize().multiplyScalar(this._worldSpaceBoneLength).add(Rn),this._collision(Bn),this._prevTail.copy(this._currentTail),this._currentTail.copy(Bn).applyMatrix4(this._getMatrixWorldToCenter());const t=ch.multiplyMatrices(this._parentMatrixWorld,this._initialLocalMatrix).invert();this.bone.quaternion.setFromUnitVectors(this._boneAxis,rn.copy(Bn).applyMatrix4(t).normalize()).premultiply(this._initialLocalRotation),this.bone.updateMatrix(),this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld,this.bone.matrix)}_collision(l){for(let e=0;e<this.colliderGroups.length;e++)for(let t=0;t<this.colliderGroups[e].colliders.length;t++){const n=this.colliderGroups[e].colliders[t],s=n.shape.calculateCollision(n.colliderMatrix,l,this.settings.hitRadius,rn);if(s<0){l.addScaledVector(rn,-s),l.sub(Rn);const r=l.length();l.multiplyScalar(this._worldSpaceBoneLength/r).add(Rn)}}}_calcWorldSpaceBoneLength(){rn.setFromMatrixPosition(this.bone.matrixWorld),this.child?In.setFromMatrixPosition(this.child.matrixWorld):(In.copy(this._initialLocalChildPosition),In.applyMatrix4(this.bone.matrixWorld)),this._worldSpaceBoneLength=rn.sub(In).length()}_getMatrixCenterToWorld(){return this._center?this._center.matrixWorld:tr}_getMatrixWorldToCenter(){return this._center?this._center.userData.inverseCacheProxy.inverse:tr}};function dh(l,e){const t=[];let n=l;for(;n!==null;)t.unshift(n),n=n.parent;t.forEach(s=>{e(s)})}function br(l,e){l.children.forEach(t=>{e(t)||br(t,e)})}function hh(l){var e;const t=new Map;for(const n of l){let s=n;do{const r=((e=t.get(s))!=null?e:0)+1;if(r===l.size)return s;t.set(s,r),s=s.parent}while(s!==null)}return null}var eo=class{constructor(){this._joints=new Set,this._sortedJoints=[],this._hasWarnedCircularDependency=!1,this._ancestors=[],this._objectSpringBonesMap=new Map,this._isSortedJointsDirty=!1,this._relevantChildrenUpdated=this._relevantChildrenUpdated.bind(this)}get joints(){return this._joints}get springBones(){return console.warn("VRMSpringBoneManager: springBones is deprecated. use joints instead."),this._joints}get colliderGroups(){const l=new Set;return this._joints.forEach(e=>{e.colliderGroups.forEach(t=>{l.add(t)})}),Array.from(l)}get colliders(){const l=new Set;return this.colliderGroups.forEach(e=>{e.colliders.forEach(t=>{l.add(t)})}),Array.from(l)}addJoint(l){this._joints.add(l);let e=this._objectSpringBonesMap.get(l.bone);e==null&&(e=new Set,this._objectSpringBonesMap.set(l.bone,e)),e.add(l),this._isSortedJointsDirty=!0}addSpringBone(l){console.warn("VRMSpringBoneManager: addSpringBone() is deprecated. use addJoint() instead."),this.addJoint(l)}deleteJoint(l){this._joints.delete(l),this._objectSpringBonesMap.get(l.bone).delete(l),this._isSortedJointsDirty=!0}deleteSpringBone(l){console.warn("VRMSpringBoneManager: deleteSpringBone() is deprecated. use deleteJoint() instead."),this.deleteJoint(l)}setInitState(){this._sortJoints();for(let l=0;l<this._sortedJoints.length;l++){const e=this._sortedJoints[l];e.bone.updateMatrix(),e.bone.updateWorldMatrix(!1,!1),e.setInitState()}}reset(){this._sortJoints();for(let l=0;l<this._sortedJoints.length;l++){const e=this._sortedJoints[l];e.bone.updateMatrix(),e.bone.updateWorldMatrix(!1,!1),e.reset()}}update(l){this._sortJoints();for(let e=0;e<this._ancestors.length;e++)this._ancestors[e].updateWorldMatrix(e===0,!1);for(let e=0;e<this._sortedJoints.length;e++){const t=this._sortedJoints[e];t.bone.updateMatrix(),t.bone.updateWorldMatrix(!1,!1),t.update(l),br(t.bone,this._relevantChildrenUpdated)}}_sortJoints(){if(!this._isSortedJointsDirty)return;const l=[],e=new Set,t=new Set,n=new Set;for(const r of this._joints)this._insertJointSort(r,e,t,l,n);this._sortedJoints=l;const s=hh(n);this._ancestors=[],s&&(this._ancestors.push(s),br(s,r=>{var i,o;return((o=(i=this._objectSpringBonesMap.get(r))==null?void 0:i.size)!=null?o:0)>0?!0:(this._ancestors.push(r),!1)})),this._isSortedJointsDirty=!1}_insertJointSort(l,e,t,n,s){if(t.has(l))return;if(e.has(l)){this._hasWarnedCircularDependency||(console.warn("VRMSpringBoneManager: Circular dependency detected"),this._hasWarnedCircularDependency=!0);return}e.add(l);const r=l.dependencies;for(const i of r){let o=!1,a=null;dh(i,c=>{const d=this._objectSpringBonesMap.get(c);if(d)for(const u of d)o=!0,this._insertJointSort(u,e,t,n,s);else o||(a=c)}),a&&s.add(a)}n.push(l),t.add(l)}_relevantChildrenUpdated(l){var e,t;return((t=(e=this._objectSpringBonesMap.get(l))==null?void 0:e.size)!=null?t:0)>0?!0:(l.updateWorldMatrix(!1,!1),!1)}},to="VRMC_springBone_extended_collider",fh=new Set(["1.0","1.0-beta"]),ph=new Set(["1.0"]),Ia=class un{get name(){return un.EXTENSION_NAME}constructor(e,t){var n;this.parser=e,this.jointHelperRoot=t?.jointHelperRoot,this.colliderHelperRoot=t?.colliderHelperRoot,this.useExtendedColliders=(n=t?.useExtendedColliders)!=null?n:!0}afterRoot(e){return ns(this,null,function*(){e.userData.vrmSpringBoneManager=yield this._import(e)})}_import(e){return ns(this,null,function*(){const t=yield this._v1Import(e);if(t!=null)return t;const n=yield this._v0Import(e);return n??null})}_v1Import(e){return ns(this,null,function*(){var t,n,s,r,i;const o=e.parser.json;if(!(((t=o.extensionsUsed)==null?void 0:t.indexOf(un.EXTENSION_NAME))!==-1))return null;const c=new eo,d=yield e.parser.getDependencies("node"),u=(n=o.extensions)==null?void 0:n[un.EXTENSION_NAME];if(!u)return null;const f=u.specVersion;if(!fh.has(f))return console.warn(`VRMSpringBoneLoaderPlugin: Unknown ${un.EXTENSION_NAME} specVersion "${f}"`),null;const h=(s=u.colliders)==null?void 0:s.map((p,m)=>{var A,y,v,x,w,T,C,E,I,P,B,M,D,_,k;const G=d[p.node];if(G==null)return console.warn(`VRMSpringBoneLoaderPlugin: The collider #${m} attempted to use the node #${p.node} but not found`),null;const O=p.shape,$=(A=p.extensions)==null?void 0:A[to];if(this.useExtendedColliders&&$!=null){const U=$.specVersion;if(!ph.has(U))console.warn(`VRMSpringBoneLoaderPlugin: Unknown ${to} specVersion "${U}". Fallbacking to the ${un.EXTENSION_NAME} definition`);else{const Z=$.shape;if(Z.sphere)return this._importSphereCollider(G,{offset:new F().fromArray((y=Z.sphere.offset)!=null?y:[0,0,0]),radius:(v=Z.sphere.radius)!=null?v:0,inside:(x=Z.sphere.inside)!=null?x:!1});if(Z.capsule)return this._importCapsuleCollider(G,{offset:new F().fromArray((w=Z.capsule.offset)!=null?w:[0,0,0]),radius:(T=Z.capsule.radius)!=null?T:0,tail:new F().fromArray((C=Z.capsule.tail)!=null?C:[0,0,0]),inside:(E=Z.capsule.inside)!=null?E:!1});if(Z.plane)return this._importPlaneCollider(G,{offset:new F().fromArray((I=Z.plane.offset)!=null?I:[0,0,0]),normal:new F().fromArray((P=Z.plane.normal)!=null?P:[0,0,1])})}}if(O.sphere)return this._importSphereCollider(G,{offset:new F().fromArray((B=O.sphere.offset)!=null?B:[0,0,0]),radius:(M=O.sphere.radius)!=null?M:0,inside:!1});if(O.capsule)return this._importCapsuleCollider(G,{offset:new F().fromArray((D=O.capsule.offset)!=null?D:[0,0,0]),radius:(_=O.capsule.radius)!=null?_:0,tail:new F().fromArray((k=O.capsule.tail)!=null?k:[0,0,0]),inside:!1});throw new Error(`VRMSpringBoneLoaderPlugin: The collider #${m} has no valid shape`)}),g=(r=u.colliderGroups)==null?void 0:r.map((p,m)=>{var A;return{colliders:((A=p.colliders)!=null?A:[]).flatMap(v=>{const x=h?.[v];return x??(console.warn(`VRMSpringBoneLoaderPlugin: The colliderGroup #${m} attempted to use a collider #${v} but not found`),[])}),name:p.name}});return(i=u.springs)==null||i.forEach((p,m)=>{var A;const y=p.joints,v=(A=p.colliderGroups)==null?void 0:A.map(T=>{const C=g?.[T];if(C==null)throw new Error(`VRMSpringBoneLoaderPlugin: The spring #${m} attempted to use a colliderGroup ${T} but not found`);return C}),x=p.center!=null?d[p.center]:void 0;let w;y.forEach(T=>{if(w){const C=w.node,E=d[C],I=T.node,P=d[I],B={hitRadius:w.hitRadius,dragForce:w.dragForce,gravityPower:w.gravityPower,stiffness:w.stiffness,gravityDir:w.gravityDir!=null?new F().fromArray(w.gravityDir):void 0},M=this._importJoint(E,P,B,v);x&&(M.center=x),c.addJoint(M)}w=T})}),c.setInitState(),c})}_v0Import(e){return ns(this,null,function*(){var t,n,s;const r=e.parser.json;if(!(((t=r.extensionsUsed)==null?void 0:t.indexOf("VRM"))!==-1))return null;const o=(n=r.extensions)==null?void 0:n.VRM,a=o?.secondaryAnimation;if(!a)return null;const c=a?.boneGroups;if(!c)return null;const d=new eo,u=yield e.parser.getDependencies("node"),f=(s=a.colliderGroups)==null?void 0:s.map(h=>{var g;const p=u[h.node];return{colliders:((g=h.colliders)!=null?g:[]).map((A,y)=>{var v,x,w;const T=new F(0,0,0);return A.offset&&T.set((v=A.offset.x)!=null?v:0,(x=A.offset.y)!=null?x:0,A.offset.z?-A.offset.z:0),this._importSphereCollider(p,{offset:T,radius:(w=A.radius)!=null?w:0,inside:!1})})}});return c?.forEach((h,g)=>{const p=h.bones;p&&p.forEach(m=>{var A,y,v,x;const w=u[m],T=new F;h.gravityDir?T.set((A=h.gravityDir.x)!=null?A:0,(y=h.gravityDir.y)!=null?y:0,(v=h.gravityDir.z)!=null?v:0):T.set(0,-1,0);const C=h.center!=null?u[h.center]:void 0,E={hitRadius:h.hitRadius,dragForce:h.dragForce,gravityPower:h.gravityPower,stiffness:h.stiffiness,gravityDir:T},I=(x=h.colliderGroups)==null?void 0:x.map(P=>{const B=f?.[P];if(B==null)throw new Error(`VRMSpringBoneLoaderPlugin: The spring #${g} attempted to use a colliderGroup ${P} but not found`);return B});w.traverse(P=>{var B;const M=(B=P.children[0])!=null?B:null,D=this._importJoint(P,M,E,I);C&&(D.center=C),d.addJoint(D)})})}),e.scene.updateMatrixWorld(),d.setInitState(),d})}_importJoint(e,t,n,s){const r=new uh(e,t,n,s);if(this.jointHelperRoot){const i=new rh(r);this.jointHelperRoot.add(i),i.renderOrder=this.jointHelperRoot.renderOrder}return r}_importSphereCollider(e,t){const n=new ba(t),s=new er(n);if(e.add(s),this.colliderHelperRoot){const r=new $s(s);this.colliderHelperRoot.add(r),r.renderOrder=this.colliderHelperRoot.renderOrder}return s}_importCapsuleCollider(e,t){const n=new Ma(t),s=new er(n);if(e.add(s),this.colliderHelperRoot){const r=new $s(s);this.colliderHelperRoot.add(r),r.renderOrder=this.colliderHelperRoot.renderOrder}return s}_importPlaneCollider(e,t){const n=new Ea(t),s=new er(n);if(e.add(s),this.colliderHelperRoot){const r=new $s(s);this.colliderHelperRoot.add(r),r.renderOrder=this.colliderHelperRoot.renderOrder}return s}};Ia.EXTENSION_NAME="VRMC_springBone";var mh=Ia,gh=class{get name(){return"VRMLoaderPlugin"}constructor(l,e){var t,n,s,r,i,o,a,c,d,u;this.parser=l;const f=e?.helperRoot,h=e?.autoUpdateHumanBones;this.expressionPlugin=(t=e?.expressionPlugin)!=null?t:new Pu(l),this.firstPersonPlugin=(n=e?.firstPersonPlugin)!=null?n:new Fu(l),this.humanoidPlugin=(s=e?.humanoidPlugin)!=null?s:new Hu(l,{helperRoot:f,autoUpdateHumanBones:h}),this.lookAtPlugin=(r=e?.lookAtPlugin)!=null?r:new nd(l,{helperRoot:f}),this.metaPlugin=(i=e?.metaPlugin)!=null?i:new id(l),this.mtoonMaterialPlugin=(o=e?.mtoonMaterialPlugin)!=null?o:new xd(l),this.materialsHDREmissiveMultiplierPlugin=(a=e?.materialsHDREmissiveMultiplierPlugin)!=null?a:new wd(l),this.materialsV0CompatPlugin=(c=e?.materialsV0CompatPlugin)!=null?c:new Id(l),this.springBonePlugin=(d=e?.springBonePlugin)!=null?d:new mh(l,{colliderHelperRoot:f,jointHelperRoot:f}),this.nodeConstraintPlugin=(u=e?.nodeConstraintPlugin)!=null?u:new Yd(l,{helperRoot:f})}beforeRoot(){return $n(this,null,function*(){yield this.materialsV0CompatPlugin.beforeRoot(),yield this.mtoonMaterialPlugin.beforeRoot()})}loadMesh(l){return $n(this,null,function*(){return yield this.mtoonMaterialPlugin.loadMesh(l)})}getMaterialType(l){const e=this.mtoonMaterialPlugin.getMaterialType(l);return e??null}extendMaterialParams(l,e){return $n(this,null,function*(){yield this.materialsHDREmissiveMultiplierPlugin.extendMaterialParams(l,e),yield this.mtoonMaterialPlugin.extendMaterialParams(l,e)})}afterRoot(l){return $n(this,null,function*(){yield this.metaPlugin.afterRoot(l),yield this.humanoidPlugin.afterRoot(l),yield this.expressionPlugin.afterRoot(l),yield this.lookAtPlugin.afterRoot(l),yield this.firstPersonPlugin.afterRoot(l),yield this.springBonePlugin.afterRoot(l),yield this.nodeConstraintPlugin.afterRoot(l),yield this.mtoonMaterialPlugin.afterRoot(l);const e=l.userData.vrmMeta,t=l.userData.vrmHumanoid;if(e&&t){const n=new ad({scene:l.scene,expressionManager:l.userData.vrmExpressionManager,firstPerson:l.userData.vrmFirstPerson,humanoid:t,lookAt:l.userData.vrmLookAt,meta:e,materials:l.userData.vrmMToonMaterials,springBoneManager:l.userData.vrmSpringBoneManager,nodeConstraintManager:l.userData.vrmNodeConstraintManager});l.userData.vrm=n}})}};function Ah(l){const e=new Set;return l.traverse(t=>{if(!t.isMesh)return;const n=t;e.add(n)}),e}function no(l,e,t){if(e.size===1){const i=e.values().next().value;if(i.weight===1)return l[i.index]}const n=new Float32Array(l[0].count*3);let s=0;if(t)s=1;else for(const i of e)s+=i.weight;for(const i of e){const o=l[i.index],a=i.weight/s;for(let c=0;c<o.count;c++)n[c*3+0]+=o.getX(c)*a,n[c*3+1]+=o.getY(c)*a,n[c*3+2]+=o.getZ(c)*a}return new He(n,3)}function yh(l){var e;const t=Ah(l.scene),n=new Map,s=(e=l.expressionManager)==null?void 0:e.expressionMap;if(s!=null)for(const[r,i]of Object.entries(s)){const o=new Set;for(const a of i.binds)if(a instanceof Cs){if(a.weight!==0)for(const c of a.primitives){let d=n.get(c);d==null&&(d=new Map,n.set(c,d));let u=d.get(r);u==null&&(u=new Set,d.set(r,u)),u.add(a)}o.add(a)}for(const a of o)i.deleteBind(a)}for(const r of t){const i=n.get(r);if(i==null)continue;const o=r.geometry.morphAttributes;r.geometry.morphAttributes={};const a=r.geometry.clone();r.geometry=a;const c=a.morphTargetsRelative,d=o.position!=null,u=o.normal!=null,f={},h={},g=[];if(d||u){d&&(f.position=[]),u&&(f.normal=[]);let p=0;for(const[m,A]of i)d&&(f.position[p]=no(o.position,A,c)),u&&(f.normal[p]=no(o.normal,A,c)),s?.[m].addBind(new Cs({index:p,weight:1,primitives:[r]})),h[m]=p,g.push(0),p++}a.morphAttributes=f,r.morphTargetDictionary=h,r.morphTargetInfluences=g}}function Ms(l,e,t){if(l.getComponent)return l.getComponent(e,t);{let n=l.array[e*l.itemSize+t];return l.normalized&&(n=Ae.denormalize(n,l.array)),n}}function Ra(l,e,t,n){l.setComponent?l.setComponent(e,t,n):(l.normalized&&(n=Ae.normalize(n,l.array)),l.array[e*l.itemSize+t]=n)}function vh(l){var e;const t=xh(l),n=new Set;for(const u of t)n.has(u.geometry)&&(u.geometry=Mh(u.geometry)),n.add(u.geometry);const s=new Map;for(const u of n){const f=u.getAttribute("skinIndex"),h=(e=s.get(f))!=null?e:new Map;s.set(f,h);const g=u.getAttribute("skinWeight"),p=Sh(f,g);h.set(g,p)}const r=new Map;for(const u of t){const f=wh(u,s);r.set(u,f)}const i=[];for(const[u,f]of r){let h=!1;for(const g of i)if(_h(f,g.boneInverseMap)){h=!0,g.meshes.add(u);for(const[m,A]of f)g.boneInverseMap.set(m,A);break}h||i.push({boneInverseMap:f,meshes:new Set([u])})}const o=new Map,a=new nr,c=new nr,d=new nr;for(const u of i){const{boneInverseMap:f,meshes:h}=u,g=Array.from(f.keys()),p=Array.from(f.values()),m=new Cn(g,p),A=c.getOrCreate(m);for(const y of h){const v=y.geometry.getAttribute("skinIndex"),x=a.getOrCreate(v),w=y.skeleton.bones,T=w.map(I=>d.getOrCreate(I)).join(","),C=`${x};${A};${T}`;let E=o.get(C);E==null&&(E=v.clone(),Ch(E,w,g),o.set(C,E)),y.geometry.setAttribute("skinIndex",E)}for(const y of h)y.bind(m,new he)}}function xh(l){const e=new Set;return l.traverse(t=>{if(!t.isSkinnedMesh)return;const n=t;e.add(n)}),e}function Sh(l,e){const t=new Set;for(let n=0;n<l.count;n++)for(let s=0;s<l.itemSize;s++){const r=Ms(l,n,s);Ms(e,n,s)!==0&&t.add(r)}return t}function wh(l,e){const t=new Map,n=l.skeleton,s=l.geometry,r=s.getAttribute("skinIndex"),i=s.getAttribute("skinWeight"),o=e.get(r),a=o?.get(i);if(!a)throw new Error("Unreachable. attributeUsedIndexSetMap does not know the skin index attribute or the skin weight attribute.");for(const c of a)t.set(n.bones[c],n.boneInverses[c]);return t}function _h(l,e){for(const[t,n]of l.entries()){const s=e.get(t);if(s!=null&&!Th(n,s))return!1}return!0}function Ch(l,e,t){const n=new Map;for(const r of e)n.set(r,n.size);const s=new Map;for(const[r,i]of t.entries()){const o=n.get(i);s.set(o,r)}for(let r=0;r<l.count;r++)for(let i=0;i<l.itemSize;i++){const o=Ms(l,r,i),a=s.get(o);Ra(l,r,i,a)}l.needsUpdate=!0}function Th(l,e,t){if(t=t||1e-4,l.elements.length!=e.elements.length)return!1;for(let n=0,s=l.elements.length;n<s;n++)if(Math.abs(l.elements[n]-e.elements[n])>t)return!1;return!0}var nr=class{constructor(){this._objectIndexMap=new Map,this._index=0}get(l){return this._objectIndexMap.get(l)}getOrCreate(l){let e=this._objectIndexMap.get(l);return e==null&&(e=this._index,this._objectIndexMap.set(l,e),this._index++),e}};function Mh(l){var e,t,n,s;const r=new je;r.name=l.name,r.setIndex(l.index);for(const[i,o]of Object.entries(l.attributes))r.setAttribute(i,o);for(const[i,o]of Object.entries(l.morphAttributes)){const a=i;r.morphAttributes[a]=o.concat()}r.morphTargetsRelative=l.morphTargetsRelative,r.groups=[];for(const i of l.groups)r.addGroup(i.start,i.count,i.materialIndex);return r.boundingSphere=(t=(e=l.boundingSphere)==null?void 0:e.clone())!=null?t:null,r.boundingBox=(s=(n=l.boundingBox)==null?void 0:n.clone())!=null?s:null,r.drawRange.start=l.drawRange.start,r.drawRange.count=l.drawRange.count,r.userData=l.userData,r}function so(l){if(Object.values(l).forEach(e=>{e?.isTexture&&e.dispose()}),l.isShaderMaterial){const e=l.uniforms;e&&Object.values(e).forEach(t=>{const n=t.value;n?.isTexture&&n.dispose()})}l.dispose()}function Eh(l){const e=l.geometry;e&&e.dispose();const t=l.skeleton;t&&t.dispose();const n=l.material;n&&(Array.isArray(n)?n.forEach(s=>so(s)):n&&so(n))}function bh(l){l.traverse(Eh)}function Ih(l,e){var t,n;console.warn("VRMUtils.removeUnnecessaryJoints: removeUnnecessaryJoints is deprecated. Use combineSkeletons instead. combineSkeletons contributes more to the performance improvement. This function will be removed in the next major version.");const s=(t=e?.experimentalSameBoneCounts)!=null?t:!1,r=[];l.traverse(a=>{a.type==="SkinnedMesh"&&r.push(a)});const i=new Map;let o=0;for(const a of r){const d=a.geometry.getAttribute("skinIndex");if(i.has(d))continue;const u=new Map,f=new Map;for(let h=0;h<d.count;h++)for(let g=0;g<d.itemSize;g++){const p=Ms(d,h,g);let m=u.get(p);m==null&&(m=u.size,u.set(p,m),f.set(m,p)),Ra(d,h,g,m)}d.needsUpdate=!0,i.set(d,f),o=Math.max(o,u.size)}for(const a of r){const d=a.geometry.getAttribute("skinIndex"),u=i.get(d),f=[],h=[],g=s?o:u.size;for(let m=0;m<g;m++){const A=(n=u.get(m))!=null?n:0;f.push(a.skeleton.bones[A]),h.push(a.skeleton.boneInverses[A])}const p=new Cn(f,h);a.bind(p,new he)}}function Rh(l){const e=new Map;l.traverse(t=>{var n,s,r,i;if(!t.isMesh)return;const o=t,a=o.geometry,c=a.index;if(c==null)return;const d=e.get(a);if(d!=null){o.geometry=d;return}const u=Object.values(a.attributes)[0].count,f=new Array(u);let h=0;const g=c.array;for(let x=0;x<g.length;x++){const w=g[x];f[w]||(f[w]=!0,h++)}if(h===u)return;const p=[],m=[];let A=0;for(let x=0;x<f.length;x++)if(f[x]){const w=A++;p[x]=w,m[w]=x}const y=new je;y.name=a.name,y.morphTargetsRelative=a.morphTargetsRelative,a.groups.forEach(x=>{y.addGroup(x.start,x.count,x.materialIndex)}),y.boundingBox=(s=(n=a.boundingBox)==null?void 0:n.clone())!=null?s:null,y.boundingSphere=(i=(r=a.boundingSphere)==null?void 0:r.clone())!=null?i:null,y.setDrawRange(a.drawRange.start,a.drawRange.count),y.userData=a.userData,e.set(a,y);{const x=c.array,w=new x.constructor(x.length);for(let T=0;T<x.length;T++){const C=x[T],E=p[C];w[T]=E}y.setIndex(new He(w,1,!1))}Object.keys(a.attributes).forEach(x=>{const w=a.attributes[x];if(w.isInterleavedBufferAttribute)throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");const T=w.array,{itemSize:C,normalized:E}=w,I=new T.constructor(m.length*C);m.forEach((P,B)=>{for(let M=0;M<C;M++)I[B*C+M]=T[P*C+M]}),y.setAttribute(x,new He(I,C,E))});let v=!0;for(const[x,w]of Object.entries(a.morphAttributes)){const T=x;y.morphAttributes[T]=[];for(let C=0;C<w.length;C++){const E=w[C];if(E.isInterleavedBufferAttribute)throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");const I=E.array,{itemSize:P,normalized:B}=E,M=new I.constructor(m.length*P);m.forEach((D,_)=>{for(let k=0;k<P;k++)M[_*P+k]=I[D*P+k]}),v=v&&M.every(D=>D===0),y.morphAttributes[T][C]=new He(M,P,B)}}v&&(y.morphAttributes={}),o.geometry=y}),Array.from(e.keys()).forEach(t=>{t.dispose()})}function Bh(l){var e;((e=l.meta)==null?void 0:e.metaVersion)==="0"&&(l.scene.rotation.y=Math.PI)}var Mt=class{constructor(){}};Mt.combineMorphs=yh;Mt.combineSkeletons=vh;Mt.deepDispose=bh;Mt.removeUnnecessaryJoints=Ih;Mt.removeUnnecessaryVertices=Rh;Mt.rotateVRM0=Bh;/*!
 * @pixiv/three-vrm-core v3.4.4
 * The implementation of core features of VRM, for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-core is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 *//*!
 * @pixiv/three-vrm-materials-mtoon v3.4.4
 * MToon (toon material) module for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-materials-mtoon is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 *//*!
 * @pixiv/three-vrm-materials-hdr-emissive-multiplier v3.4.4
 * Support VRMC_hdr_emissiveMultiplier for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-materials-hdr-emissive-multiplier is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 *//*!
 * @pixiv/three-vrm-materials-v0compat v3.4.4
 * VRM0.0 materials compatibility layer plugin for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-materials-v0compat is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 *//*!
 * @pixiv/three-vrm-node-constraint v3.4.4
 * Node constraint module for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-node-constraint is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 *//*!
 * @pixiv/three-vrm-springbone v3.4.4
 * Spring bone module for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-springbone is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 */class Ph{constructor(e,t=null,n=null,s=1,r=!1){this.modelUrl=t,this.animationUrl=n,this.currentVrm=void 0,this.currentMixer=void 0,this.currentAction=void 0,this.previousAction=null,this.transitionDuration=.5,this.scene=e,this.scale=s,this.center=r,this._isLoading=!0,this.clock=new Il,this.loadVRM(this.modelUrl,this.animationUrl),this.place()}loadVRM(e=null,t=null,n=null){this._isLoading=!0,e&&(this.modelUrl=e),t&&(this.animationUrl=t),n&&(this.scale=n);const s=new oa;s.crossOrigin="anonymous";const r=new Je;r.renderOrder=1e4,r.clear(),s.register(i=>new gh(i,{helperRoot:r,autoUpdateHumanBones:!0})),this.loadingPromise=new Promise((i,o)=>{s.load(this.modelUrl,async a=>{const c=a.userData.vrm;Mt.removeUnnecessaryVertices(a.scene),Mt.removeUnnecessaryJoints(a.scene),this.currentVrm=c,c.scene.traverse(f=>{f.frustumCulled=!1});const d=new F;new Qt().setFromObject(c.scene).getSize(d),this.ground=-d.y*.5*this.scale,this.animationUrl&&this.animationUrl!==""&&await this.loadFBX(this.animationUrl),c.scene.position.y+=this.ground,c.scene.scale.setScalar(this.scale);for(const f of c.springBoneManager.joints)f.settings.stiffness*=this.scale,f.settings.hitRadius*=this.scale;for(const f of c.springBoneManager.colliders){const h=f.shape;h.radius*=this.scale,h.tail&&h.tail.multiplyScalar(this.scale)}Mt.rotateVRM0(c),c.scene.updateMatrix(),c.scene.position0=c.scene.position.clone(),c.scene.rotation0=c.scene.rotation.clone(),c.scene.quaternion0=c.scene.quaternion.clone(),c.scene.matrix0=c.scene.matrix.clone(),c.hipPos0=c.humanoid.getNormalizedBoneNode("hips").position.clone(),this._isLoading=!1,i(a)},a=>{let c=parseFloat((100*(a.loaded/a.total)).toPrecision(3));const d=document.getElementById("loaddisplay");d&&(d.innerHTML=c+"%")},a=>o(a))})}async loadFBX(e=null){this._isLoading=!0,e&&(this.animationUrl=e),this.currentMixer||(this.currentMixer=new Rl(this.currentVrm.scene));const t=await Dh(this.animationUrl,this.currentVrm,this.scale);this.previousAction=this.action,this.action=this.currentMixer.clipAction(t),this.currentAction=this.action,this.previousAction?(this.previousAction.fadeOut(this.transitionDuration),this.action.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(this.transitionDuration).play()):(this.action.play(),this.currentMixer.update(0),this.currentVrm.update(0)),this._isLoading=!1}async place(){await this.loadingPromise,this.scene.add(this.currentVrm.scene),this.center||this.currentVrm.scene.position.set(0,0,0)}async leave(e){e.remove(this.currentVrm.scene),Mt.deepDispose(this.currentVrm.scene),this.currentVrm=void 0,this.currentMixer=void 0}async changeVRM(e,t,n=null){let s=this.currentVrm.scene.position.clone(),r=this.currentVrm.scene.rotation.clone(),i=this.currentVrm.scene.rotation0.clone();s.y=0,await this.leave(e),await this.loadVRM(t,null,n),await this.place();let o=this.currentVrm.scene.rotation0.clone(),a=c=>new ce().setFromEuler(c);r=a(r).multiply(a(i).clone().invert()),r=a(o).multiply(r),r=new at().setFromQuaternion(r,"YZX"),this.currentVrm.scene.position.copy(s),this.currentVrm.scene.rotation.copy(r),this.center&&(this.currentVrm.scene.position.y+=this.ground)}async changeFBX(e){await this.loadFBX(e)}isLoading(){return this._isLoading}update(){if(this._isLoading)return;const e=this.clock.getDelta();this.currentVrm&&this.currentVrm.update(e),this.currentMixer&&this.currentMixer.update(e)}}function Dh(l,e,t){return new Mc().loadAsync(l).then(s=>{const r=vs.findByName(s.animations,"mixamo.com"),i=[],o=new ce,a=new ce,c=new ce;new F;const d=s.getObjectByName("mixamorigHips").position.y,f=Math.abs(e.hipPos0.y)*t/d;return r.tracks.forEach(h=>{const g=h.name.split("."),p=g[0],m=Fh[p],A=e.humanoid?.getNormalizedBoneNode(m)?.name,y=s.getObjectByName(p);if(A!=null){const v=g[1];if(y.getWorldQuaternion(o).invert(),y.parent.getWorldQuaternion(a),h instanceof xn){for(let x=0;x<h.values.length;x+=4){const w=h.values.slice(x,x+4);c.fromArray(w),c.premultiply(a).multiply(o),c.toArray(w),w.forEach((T,C)=>{h.values[C+x]=T})}i.push(new xn(`${A}.${v}`,h.times,h.values.map((x,w)=>e.meta?.metaVersion==="0"&&w%2===0?-x:x)))}else if(h instanceof Wn){const x=h.values.map((w,T)=>(e.meta?.metaVersion==="0"&&T%3!==1?-w:w)*f);i.push(new Wn(`${A}.${v}`,h.times,x))}}}),new vs("vrmAnimation",r.duration,i)})}const Fh={mixamorigHips:"hips",mixamorigSpine:"spine",mixamorigSpine1:"chest",mixamorigSpine2:"upperChest",mixamorigNeck:"neck",mixamorigHead:"head",mixamorigLeftShoulder:"leftShoulder",mixamorigLeftArm:"leftUpperArm",mixamorigLeftForeArm:"leftLowerArm",mixamorigLeftHand:"leftHand",mixamorigLeftHandThumb1:"leftThumbMetacarpal",mixamorigLeftHandThumb2:"leftThumbProximal",mixamorigLeftHandThumb3:"leftThumbDistal",mixamorigLeftHandIndex1:"leftIndexProximal",mixamorigLeftHandIndex2:"leftIndexIntermediate",mixamorigLeftHandIndex3:"leftIndexDistal",mixamorigLeftHandMiddle1:"leftMiddleProximal",mixamorigLeftHandMiddle2:"leftMiddleIntermediate",mixamorigLeftHandMiddle3:"leftMiddleDistal",mixamorigLeftHandRing1:"leftRingProximal",mixamorigLeftHandRing2:"leftRingIntermediate",mixamorigLeftHandRing3:"leftRingDistal",mixamorigLeftHandPinky1:"leftLittleProximal",mixamorigLeftHandPinky2:"leftLittleIntermediate",mixamorigLeftHandPinky3:"leftLittleDistal",mixamorigRightShoulder:"rightShoulder",mixamorigRightArm:"rightUpperArm",mixamorigRightForeArm:"rightLowerArm",mixamorigRightHand:"rightHand",mixamorigRightHandPinky1:"rightLittleProximal",mixamorigRightHandPinky2:"rightLittleIntermediate",mixamorigRightHandPinky3:"rightLittleDistal",mixamorigRightHandRing1:"rightRingProximal",mixamorigRightHandRing2:"rightRingIntermediate",mixamorigRightHandRing3:"rightRingDistal",mixamorigRightHandMiddle1:"rightMiddleProximal",mixamorigRightHandMiddle2:"rightMiddleIntermediate",mixamorigRightHandMiddle3:"rightMiddleDistal",mixamorigRightHandIndex1:"rightIndexProximal",mixamorigRightHandIndex2:"rightIndexIntermediate",mixamorigRightHandIndex3:"rightIndexDistal",mixamorigRightHandThumb1:"rightThumbMetacarpal",mixamorigRightHandThumb2:"rightThumbProximal",mixamorigRightHandThumb3:"rightThumbDistal",mixamorigLeftUpLeg:"leftUpperLeg",mixamorigLeftLeg:"leftLowerLeg",mixamorigLeftFoot:"leftFoot",mixamorigLeftToeBase:"leftToes",mixamorigRightUpLeg:"rightUpperLeg",mixamorigRightLeg:"rightLowerLeg",mixamorigRightFoot:"rightFoot",mixamorigRightToeBase:"rightToes"};class Nt{static idGen=0;constructor(e,t){let n,s;this.promise=new Promise((c,d)=>{n=c,s=d});const r=n.bind(this),i=s.bind(this),o=(...c)=>{r(...c)},a=c=>{i(c)};e(o.bind(this),a.bind(this)),this.abortHandler=t,this.id=Nt.idGen++}then(e){return new Nt((t,n)=>{this.promise=this.promise.then((...s)=>{const r=e(...s);r instanceof Promise||r instanceof Nt?r.then((...i)=>{t(...i)}):t(r)}).catch(s=>{n(s)})},this.abortHandler)}catch(e){return new Nt(t=>{this.promise=this.promise.then((...n)=>{t(...n)}).catch(e)},this.abortHandler)}abort(e){this.abortHandler&&this.abortHandler(e)}}class Ba extends Error{constructor(e){super(e)}}(function(){const l=new Float32Array(1),e=new Int32Array(l.buffer);return function(t){l[0]=t;const n=e[0];let s=n>>16&32768,r=n>>12&2047;const i=n>>23&255;return i<103?s:i>142?(s|=31744,s|=(i==255?0:1)&&n&8388607,s):i<113?(r|=2048,s|=(r>>114-i)+(r>>113-i&1),s):(s|=i-112<<10|r>>1,s+=r&1,s)}})();const sr=function(){const l=new Float32Array(1),e=new Int32Array(l.buffer);return function(t){return l[0]=t,e[0]}}(),Lh=function(l,e){return l[e]+(l[e+1]<<8)+(l[e+2]<<16)+(l[e+3]<<24)},Fs=function(l,e,t=!0,n){const s=new AbortController,r=s.signal;let i=!1;const o=d=>{s.abort(d),i=!0};let a=!1;const c=(d,u,f,h)=>{e&&!a&&(e(d,u,f,h),d===100&&(a=!0))};return new Nt((d,u)=>{const f={signal:r};n&&(f.headers=n),fetch(l,f).then(async h=>{if(!h.ok){const v=await h.text();u(new Error(`Fetch failed: ${h.status} ${h.statusText} ${v}`));return}const g=h.body.getReader();let p=0,m=h.headers.get("Content-Length"),A=m?parseInt(m):void 0;const y=[];for(;!i;)try{const{value:v,done:x}=await g.read();if(x){if(c(100,"100%",v,A),t){const C=new Blob(y).arrayBuffer();d(C)}else d();break}p+=v.length;let w,T;A!==void 0&&(w=p/A*100,T=`${w.toFixed(2)}%`),t&&y.push(v),c(w,T,v,A)}catch(v){u(v);return}}).catch(h=>{u(new Ba(h))})},o)},Le=function(l,e,t){return Math.max(Math.min(l,t),e)},on=function(){return performance.now()/1e3},dn=l=>{if(l.geometry&&(l.geometry.dispose(),l.geometry=null),l.material&&(l.material.dispose(),l.material=null),l.children)for(let e of l.children)dn(e)},ut=(l,e)=>new Promise(t=>{window.setTimeout(()=>{t(l?l():void 0)},e?1:50)}),An=(l=0)=>{let e=0;if(l===1)e=9;else if(l===2)e=24;else if(l===3)e=45;else if(l>3)throw new Error("getSphericalHarmonicsComponentCountForDegree() -> Invalid spherical harmonics degree");return e},Nr=()=>{let l,e;return{promise:new Promise((n,s)=>{l=n,e=s}),resolve:l,reject:e}},rr=l=>{let e,t;return l||(l=()=>{}),{promise:new Nt((s,r)=>{e=s,t=r},l),resolve:e,reject:t}};class kh{constructor(e,t,n){this.major=e,this.minor=t,this.patch=n}toString(){return`${this.major}_${this.minor}_${this.patch}`}}function zr(){const l=navigator.userAgent;return l.indexOf("iPhone")>0||l.indexOf("iPad")>0}function Pa(){if(zr()){const l=navigator.userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/);return new kh(parseInt(l[1]||0,10),parseInt(l[2]||0,10),parseInt(l[3]||0,10))}else return null}const Oh=14;class oe{static OFFSET={X:0,Y:1,Z:2,SCALE0:3,SCALE1:4,SCALE2:5,ROTATION0:6,ROTATION1:7,ROTATION2:8,ROTATION3:9,FDC0:10,FDC1:11,FDC2:12,OPACITY:13,FRC0:14,FRC1:15,FRC2:16,FRC3:17,FRC4:18,FRC5:19,FRC6:20,FRC7:21,FRC8:22,FRC9:23,FRC10:24,FRC11:25,FRC12:26,FRC13:27,FRC14:28,FRC15:29,FRC16:30,FRC17:31,FRC18:32,FRC19:33,FRC20:34,FRC21:35,FRC22:36,FRC23:37};constructor(e=0){this.sphericalHarmonicsDegree=e,this.sphericalHarmonicsCount=An(this.sphericalHarmonicsDegree),this.componentCount=this.sphericalHarmonicsCount+Oh,this.defaultSphericalHarmonics=new Array(this.sphericalHarmonicsCount).fill(0),this.splats=[],this.splatCount=0}static createSplat(e=0){const t=[0,0,0,1,1,1,1,0,0,0,0,0,0,0];let n=An(e);for(let s=0;s<n;s++)t.push(0);return t}addSplat(e){e.originalIndex=this.splatCount,this.splats.push(e),this.splatCount++}getSplat(e){return this.splats[e]}addDefaultSplat(){const e=oe.createSplat(this.sphericalHarmonicsDegree);return this.addSplat(e),e}addSplatFromComonents(e,t,n,s,r,i,o,a,c,d,u,f,h,g,...p){const m=[e,t,n,s,r,i,o,a,c,d,u,f,h,g,...this.defaultSphericalHarmonics];for(let A=0;A<p.length&&A<this.sphericalHarmonicsCount;A++)m[A]=p[A];return this.addSplat(m),m}addSplatFromArray(e,t){const n=e.splats[t],s=oe.createSplat(this.sphericalHarmonicsDegree);for(let r=0;r<this.componentCount&&r<n.length;r++)s[r]=n[r];this.addSplat(s)}}class Ee{static DefaultSplatSortDistanceMapPrecision=16;static MemoryPageSize=65536;static BytesPerFloat=4;static BytesPerInt=4;static MaxScenes=32;static ProgressiveLoadSectionSize=262144;static ProgressiveLoadSectionDelayDuration=15;static SphericalHarmonics8BitCompressionRange=3}const Uh=Ee.SphericalHarmonics8BitCompressionRange,Ot=Uh/2,Ve=jn.toHalfFloat.bind(jn),Hr=jn.fromHalfFloat.bind(jn),Fe=(l,e,t=!1,n,s)=>{if(e===0)return l;if(e===1||e===2&&!t)return jn.fromHalfFloat(l);if(e===2)return Vr(l,n,s)},Ln=(l,e,t)=>{l=Le(l,e,t);const n=t-e;return Le(Math.floor((l-e)/n*255),0,255)},Vr=(l,e,t)=>{const n=t-e;return l/255*n+e},Da=(l,e,t)=>Ln(Hr(l,e,t)),Nh=(l,e,t)=>Ve(Vr(l,e,t)),Me=(l,e,t,n=!1)=>t===0?l.getFloat32(e*4,!0):t===1||t===2&&!n?l.getUint16(e*2,!0):l.getUint8(e,!0),zh=function(){const l=e=>e;return function(e,t,n,s=!1){if(t===n)return e;let r=l;return t===2&&s?n===1?r=Nh:n==0&&(r=Vr):t===2||t===1?n===0?r=Hr:n==2&&(s?r=Da:r=l):t===0&&(n===1?r=Ve:n==2&&(s?r=Ln:r=Ve)),r(e)}}(),an=(l,e,t,n,s=0)=>{const r=new Uint8Array(l,e),i=new Uint8Array(t,n);for(let o=0;o<s;o++)i[o]=r[o]};class j{static CurrentMajorVersion=0;static CurrentMinorVersion=1;static CenterComponentCount=3;static ScaleComponentCount=3;static RotationComponentCount=4;static ColorComponentCount=4;static CovarianceComponentCount=6;static SplatScaleOffsetFloat=3;static SplatRotationOffsetFloat=6;static CompressionLevels={0:{BytesPerCenter:12,BytesPerScale:12,BytesPerRotation:16,BytesPerColor:4,ScaleOffsetBytes:12,RotationffsetBytes:24,ColorOffsetBytes:40,SphericalHarmonicsOffsetBytes:44,ScaleRange:1,BytesPerSphericalHarmonicsComponent:4,SphericalHarmonicsOffsetFloat:11,SphericalHarmonicsDegrees:{0:{BytesPerSplat:44},1:{BytesPerSplat:80},2:{BytesPerSplat:140}}},1:{BytesPerCenter:6,BytesPerScale:6,BytesPerRotation:8,BytesPerColor:4,ScaleOffsetBytes:6,RotationffsetBytes:12,ColorOffsetBytes:20,SphericalHarmonicsOffsetBytes:24,ScaleRange:32767,BytesPerSphericalHarmonicsComponent:2,SphericalHarmonicsOffsetFloat:12,SphericalHarmonicsDegrees:{0:{BytesPerSplat:24},1:{BytesPerSplat:42},2:{BytesPerSplat:72}}},2:{BytesPerCenter:6,BytesPerScale:6,BytesPerRotation:8,BytesPerColor:4,ScaleOffsetBytes:6,RotationffsetBytes:12,ColorOffsetBytes:20,SphericalHarmonicsOffsetBytes:24,ScaleRange:32767,BytesPerSphericalHarmonicsComponent:1,SphericalHarmonicsOffsetFloat:12,SphericalHarmonicsDegrees:{0:{BytesPerSplat:24},1:{BytesPerSplat:33},2:{BytesPerSplat:48}}}};static CovarianceSizeFloats=6;static HeaderSizeBytes=4096;static SectionHeaderSizeBytes=1024;static BucketStorageSizeBytes=12;static BucketStorageSizeFloats=3;static BucketBlockSize=5;static BucketSize=256;constructor(e,t=!0){this.constructFromBuffer(e,t)}getSplatCount(){return this.splatCount}getMaxSplatCount(){return this.maxSplatCount}getMinSphericalHarmonicsDegree(){let e=0;for(let t=0;t<this.sections.length;t++){const n=this.sections[t];(t===0||n.sphericalHarmonicsDegree<e)&&(e=n.sphericalHarmonicsDegree)}return e}getBucketIndex(e,t){let n;const s=e.fullBucketCount*e.bucketSize;if(t<s)n=Math.floor(t/e.bucketSize);else{let r=s;n=e.fullBucketCount;let i=0;for(;r<e.splatCount;){let o=e.partiallyFilledBucketLengths[i];if(t>=r&&t<r+o)break;r+=o,n++,i++}}return n}getSplatCenter(e,t,n){const s=this.globalSplatIndexToSectionMap[e],r=this.sections[s],i=e-r.splatCountOffset,o=r.bytesPerSplat*i,a=new DataView(this.bufferData,r.dataBase+o),c=Me(a,0,this.compressionLevel),d=Me(a,1,this.compressionLevel),u=Me(a,2,this.compressionLevel);if(this.compressionLevel>=1){const h=this.getBucketIndex(r,i)*j.BucketStorageSizeFloats,g=r.compressionScaleFactor,p=r.compressionScaleRange;t.x=(c-p)*g+r.bucketArray[h],t.y=(d-p)*g+r.bucketArray[h+1],t.z=(u-p)*g+r.bucketArray[h+2]}else t.x=c,t.y=d,t.z=u;n&&t.applyMatrix4(n)}getSplatScaleAndRotation=function(){const e=new he,t=new he,n=new he,s=new F,r=new F,i=new ce;return function(o,a,c,d,u){const f=this.globalSplatIndexToSectionMap[o],h=this.sections[f],g=o-h.splatCountOffset,p=h.bytesPerSplat*g+j.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,m=new DataView(this.bufferData,h.dataBase+p);r.set(Fe(Me(m,0,this.compressionLevel),this.compressionLevel),Fe(Me(m,1,this.compressionLevel),this.compressionLevel),Fe(Me(m,2,this.compressionLevel),this.compressionLevel)),u&&(u.x!==void 0&&(r.x=u.x),u.y!==void 0&&(r.y=u.y),u.z!==void 0&&(r.z=u.z)),i.set(Fe(Me(m,4,this.compressionLevel),this.compressionLevel),Fe(Me(m,5,this.compressionLevel),this.compressionLevel),Fe(Me(m,6,this.compressionLevel),this.compressionLevel),Fe(Me(m,3,this.compressionLevel),this.compressionLevel)),d?(e.makeScale(r.x,r.y,r.z),t.makeRotationFromQuaternion(i),n.copy(e).multiply(t).multiply(d),n.decompose(s,c,a)):(a.copy(r),c.copy(i))}}();getSplatColor(e,t){const n=this.globalSplatIndexToSectionMap[e],s=this.sections[n],r=e-s.splatCountOffset,i=s.bytesPerSplat*r+j.CompressionLevels[this.compressionLevel].ColorOffsetBytes,o=new Uint8Array(this.bufferData,s.dataBase+i,4);t.set(o[0],o[1],o[2],o[3])}fillSplatCenterArray(e,t,n,s,r){const i=this.splatCount;n=n||0,s=s||i-1,r===void 0&&(r=n);const o=new F;for(let a=n;a<=s;a++){const c=this.globalSplatIndexToSectionMap[a],d=this.sections[c],u=a-d.splatCountOffset,f=(a-n+r)*j.CenterComponentCount,h=d.bytesPerSplat*u,g=new DataView(this.bufferData,d.dataBase+h),p=Me(g,0,this.compressionLevel),m=Me(g,1,this.compressionLevel),A=Me(g,2,this.compressionLevel);if(this.compressionLevel>=1){const v=this.getBucketIndex(d,u)*j.BucketStorageSizeFloats,x=d.compressionScaleFactor,w=d.compressionScaleRange;o.x=(p-w)*x+d.bucketArray[v],o.y=(m-w)*x+d.bucketArray[v+1],o.z=(A-w)*x+d.bucketArray[v+2]}else o.x=p,o.y=m,o.z=A;t&&o.applyMatrix4(t),e[f]=o.x,e[f+1]=o.y,e[f+2]=o.z}}fillSplatScaleRotationArray=function(){const e=new he,t=new he,n=new he,s=new F,r=new ce,i=new F,o=a=>{const c=a.w<0?-1:1;a.x*=c,a.y*=c,a.z*=c,a.w*=c};return function(a,c,d,u,f,h,g,p){const m=this.splatCount;u=u||0,f=f||m-1,h===void 0&&(h=u);const A=(y,v)=>(v===void 0&&(v=this.compressionLevel),zh(y,v,g));for(let y=u;y<=f;y++){const v=this.globalSplatIndexToSectionMap[y],x=this.sections[v],w=y-x.splatCountOffset,T=x.bytesPerSplat*w+j.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,C=(y-u+h)*j.ScaleComponentCount,E=(y-u+h)*j.RotationComponentCount,I=new DataView(this.bufferData,x.dataBase+T),P=p&&p.x!==void 0?p.x:Me(I,0,this.compressionLevel),B=p&&p.y!==void 0?p.y:Me(I,1,this.compressionLevel),M=p&&p.z!==void 0?p.z:Me(I,2,this.compressionLevel),D=Me(I,3,this.compressionLevel),_=Me(I,4,this.compressionLevel),k=Me(I,5,this.compressionLevel),G=Me(I,6,this.compressionLevel);s.set(Fe(P,this.compressionLevel),Fe(B,this.compressionLevel),Fe(M,this.compressionLevel)),r.set(Fe(_,this.compressionLevel),Fe(k,this.compressionLevel),Fe(G,this.compressionLevel),Fe(D,this.compressionLevel)).normalize(),d&&(i.set(0,0,0),e.makeScale(s.x,s.y,s.z),t.makeRotationFromQuaternion(r),n.identity().premultiply(e).premultiply(t),n.premultiply(d),n.decompose(i,r,s),r.normalize()),o(r),a&&(a[C]=A(s.x,0),a[C+1]=A(s.y,0),a[C+2]=A(s.z,0)),c&&(c[E]=A(r.x,0),c[E+1]=A(r.y,0),c[E+2]=A(r.z,0),c[E+3]=A(r.w,0))}}}();static computeCovariance=function(){const e=new he,t=new We,n=new We,s=new We,r=new We,i=new We,o=new We;return function(a,c,d,u,f=0,h){e.makeScale(a.x,a.y,a.z),t.setFromMatrix4(e),e.makeRotationFromQuaternion(c),n.setFromMatrix4(e),s.copy(n).multiply(t),r.copy(s).transpose().premultiply(s),d&&(i.setFromMatrix4(d),o.copy(i).transpose(),r.multiply(o),r.premultiply(i)),h>=1?(u[f]=Ve(r.elements[0]),u[f+1]=Ve(r.elements[3]),u[f+2]=Ve(r.elements[6]),u[f+3]=Ve(r.elements[4]),u[f+4]=Ve(r.elements[7]),u[f+5]=Ve(r.elements[8])):(u[f]=r.elements[0],u[f+1]=r.elements[3],u[f+2]=r.elements[6],u[f+3]=r.elements[4],u[f+4]=r.elements[7],u[f+5]=r.elements[8])}}();fillSplatCovarianceArray(e,t,n,s,r,i){const o=this.splatCount,a=new F,c=new ce;n=n||0,s=s||o-1,r===void 0&&(r=n);for(let d=n;d<=s;d++){const u=this.globalSplatIndexToSectionMap[d],f=this.sections[u],h=d-f.splatCountOffset,g=(d-n+r)*j.CovarianceComponentCount,p=f.bytesPerSplat*h+j.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,m=new DataView(this.bufferData,f.dataBase+p);a.set(Fe(Me(m,0,this.compressionLevel),this.compressionLevel),Fe(Me(m,1,this.compressionLevel),this.compressionLevel),Fe(Me(m,2,this.compressionLevel),this.compressionLevel)),c.set(Fe(Me(m,4,this.compressionLevel),this.compressionLevel),Fe(Me(m,5,this.compressionLevel),this.compressionLevel),Fe(Me(m,6,this.compressionLevel),this.compressionLevel),Fe(Me(m,3,this.compressionLevel),this.compressionLevel)),j.computeCovariance(a,c,t,e,g,i)}}fillSplatColorArray(e,t,n,s,r){const i=this.splatCount;n=n||0,s=s||i-1,r===void 0&&(r=n);for(let o=n;o<=s;o++){const a=this.globalSplatIndexToSectionMap[o],c=this.sections[a],d=o-c.splatCountOffset,u=(o-n+r)*j.ColorComponentCount,f=c.bytesPerSplat*d+j.CompressionLevels[this.compressionLevel].ColorOffsetBytes,h=new Uint8Array(this.bufferData,c.dataBase+f);let g=h[3];g=g>=t?g:0,e[u]=h[0],e[u+1]=h[1],e[u+2]=h[2],e[u+3]=g}}fillSphericalHarmonicsArray=function(){for(let _=0;_<15;_++)new F;const e=new We,t=new he,n=new F,s=new F,r=new ce,i=[],o=[],a=[],c=[],d=[],u=[],f=[],h=[],g=[],p=[],m=[],A=[],y=[],v=[],x=[],w=[],T=[],C=[],E=_=>_,I=(_,k,G,O)=>{_[0]=k,_[1]=G,_[2]=O},P=(_,k,G,O,$)=>{_[0]=Me(k,O,$,!0),_[1]=Me(k,O+G,$,!0),_[2]=Me(k,O+G+G,$,!0)},B=(_,k)=>{k[0]=_[0],k[1]=_[1],k[2]=_[2]},M=(_,k,G,O)=>{k[G]=O(_[0]),k[G+1]=O(_[1]),k[G+2]=O(_[2])},D=(_,k,G,O,$)=>(k[0]=Fe(_[0],G,!0,O,$),k[1]=Fe(_[1],G,!0,O,$),k[2]=Fe(_[2],G,!0,O,$),k);return function(_,k,G,O,$,U,Z){const V=this.splatCount;O=O||0,$=$||V-1,U===void 0&&(U=O),G&&k>=1&&(t.copy(G),t.decompose(n,r,s),r.normalize(),t.makeRotationFromQuaternion(r),e.setFromMatrix4(t),I(i,e.elements[4],-e.elements[7],e.elements[1]),I(o,-e.elements[5],e.elements[8],-e.elements[2]),I(a,e.elements[3],-e.elements[6],e.elements[0]));const z=te=>Da(te,this.minSphericalHarmonicsCoeff,this.maxSphericalHarmonicsCoeff),ne=te=>Ln(te,this.minSphericalHarmonicsCoeff,this.maxSphericalHarmonicsCoeff);for(let te=O;te<=$;te++){const J=this.globalSplatIndexToSectionMap[te],ue=this.sections[J];k=Math.min(k,ue.sphericalHarmonicsDegree);const me=An(k),de=te-ue.splatCountOffset,fe=ue.bytesPerSplat*de+j.CompressionLevels[this.compressionLevel].SphericalHarmonicsOffsetBytes,q=new DataView(this.bufferData,ue.dataBase+fe),X=(te-O+U)*me;let ie=G?0:this.compressionLevel,ee=E;ie!==Z&&(ie===1?Z===0?ee=Hr:Z==2&&(ee=z):ie===0&&(Z===1?ee=Ve:Z==2&&(ee=ne)));const S=this.minSphericalHarmonicsCoeff,N=this.maxSphericalHarmonicsCoeff;k>=1&&(P(g,q,3,0,this.compressionLevel),P(p,q,3,1,this.compressionLevel),P(m,q,3,2,this.compressionLevel),G?(D(g,g,this.compressionLevel,S,N),D(p,p,this.compressionLevel,S,N),D(m,m,this.compressionLevel,S,N),j.rotateSphericalHarmonics3(g,p,m,i,o,a,v,x,w)):(B(g,v),B(p,x),B(m,w)),M(v,_,X,ee),M(x,_,X+3,ee),M(w,_,X+6,ee),k>=2&&(P(g,q,5,9,this.compressionLevel),P(p,q,5,10,this.compressionLevel),P(m,q,5,11,this.compressionLevel),P(A,q,5,12,this.compressionLevel),P(y,q,5,13,this.compressionLevel),G?(D(g,g,this.compressionLevel,S,N),D(p,p,this.compressionLevel,S,N),D(m,m,this.compressionLevel,S,N),D(A,A,this.compressionLevel,S,N),D(y,y,this.compressionLevel,S,N),j.rotateSphericalHarmonics5(g,p,m,A,y,i,o,a,c,d,u,f,h,v,x,w,T,C)):(B(g,v),B(p,x),B(m,w),B(A,T),B(y,C)),M(v,_,X+9,ee),M(x,_,X+12,ee),M(w,_,X+15,ee),M(T,_,X+18,ee),M(C,_,X+21,ee)))}}}();static dot3=(e,t,n,s,r)=>{r[0]=r[1]=r[2]=0;const i=s[0],o=s[1],a=s[2];j.addInto3(e[0]*i,e[1]*i,e[2]*i,r),j.addInto3(t[0]*o,t[1]*o,t[2]*o,r),j.addInto3(n[0]*a,n[1]*a,n[2]*a,r)};static addInto3=(e,t,n,s)=>{s[0]=s[0]+e,s[1]=s[1]+t,s[2]=s[2]+n};static dot5=(e,t,n,s,r,i,o)=>{o[0]=o[1]=o[2]=0;const a=i[0],c=i[1],d=i[2],u=i[3],f=i[4];j.addInto3(e[0]*a,e[1]*a,e[2]*a,o),j.addInto3(t[0]*c,t[1]*c,t[2]*c,o),j.addInto3(n[0]*d,n[1]*d,n[2]*d,o),j.addInto3(s[0]*u,s[1]*u,s[2]*u,o),j.addInto3(r[0]*f,r[1]*f,r[2]*f,o)};static rotateSphericalHarmonics3=(e,t,n,s,r,i,o,a,c)=>{j.dot3(e,t,n,s,o),j.dot3(e,t,n,r,a),j.dot3(e,t,n,i,c)};static rotateSphericalHarmonics5=(e,t,n,s,r,i,o,a,c,d,u,f,h,g,p,m,A,y)=>{const v=Math.sqrt(.25),x=Math.sqrt(3/4),w=Math.sqrt(1/3),T=Math.sqrt(4/3),C=Math.sqrt(1/12);c[0]=v*(a[2]*i[0]+a[0]*i[2]+(i[2]*a[0]+i[0]*a[2])),c[1]=a[1]*i[0]+i[1]*a[0],c[2]=x*(a[1]*i[1]+i[1]*a[1]),c[3]=a[1]*i[2]+i[1]*a[2],c[4]=v*(a[2]*i[2]-a[0]*i[0]+(i[2]*a[2]-i[0]*a[0])),j.dot5(e,t,n,s,r,c,g),d[0]=v*(o[2]*i[0]+o[0]*i[2]+(i[2]*o[0]+i[0]*o[2])),d[1]=o[1]*i[0]+i[1]*o[0],d[2]=x*(o[1]*i[1]+i[1]*o[1]),d[3]=o[1]*i[2]+i[1]*o[2],d[4]=v*(o[2]*i[2]-o[0]*i[0]+(i[2]*o[2]-i[0]*o[0])),j.dot5(e,t,n,s,r,d,p),u[0]=w*(o[2]*o[0]+o[0]*o[2])+-C*(a[2]*a[0]+a[0]*a[2]+(i[2]*i[0]+i[0]*i[2])),u[1]=T*o[1]*o[0]+-w*(a[1]*a[0]+i[1]*i[0]),u[2]=o[1]*o[1]+-v*(a[1]*a[1]+i[1]*i[1]),u[3]=T*o[1]*o[2]+-w*(a[1]*a[2]+i[1]*i[2]),u[4]=w*(o[2]*o[2]-o[0]*o[0])+-C*(a[2]*a[2]-a[0]*a[0]+(i[2]*i[2]-i[0]*i[0])),j.dot5(e,t,n,s,r,u,m),f[0]=v*(o[2]*a[0]+o[0]*a[2]+(a[2]*o[0]+a[0]*o[2])),f[1]=o[1]*a[0]+a[1]*o[0],f[2]=x*(o[1]*a[1]+a[1]*o[1]),f[3]=o[1]*a[2]+a[1]*o[2],f[4]=v*(o[2]*a[2]-o[0]*a[0]+(a[2]*o[2]-a[0]*o[0])),j.dot5(e,t,n,s,r,f,A),h[0]=v*(a[2]*a[0]+a[0]*a[2]-(i[2]*i[0]+i[0]*i[2])),h[1]=a[1]*a[0]-i[1]*i[0],h[2]=x*(a[1]*a[1]-i[1]*i[1]),h[3]=a[1]*a[2]-i[1]*i[2],h[4]=v*(a[2]*a[2]-a[0]*a[0]-(i[2]*i[2]-i[0]*i[0])),j.dot5(e,t,n,s,r,h,y)};static parseHeader(e){const t=new Uint8Array(e,0,j.HeaderSizeBytes),n=new Uint16Array(e,0,j.HeaderSizeBytes/2),s=new Uint32Array(e,0,j.HeaderSizeBytes/4),r=new Float32Array(e,0,j.HeaderSizeBytes/4),i=t[0],o=t[1],a=s[1],c=s[2],d=s[3],u=s[4],f=n[10],h=new F(r[6],r[7],r[8]),g=r[9]||-Ot,p=r[10]||Ot;return{versionMajor:i,versionMinor:o,maxSectionCount:a,sectionCount:c,maxSplatCount:d,splatCount:u,compressionLevel:f,sceneCenter:h,minSphericalHarmonicsCoeff:g,maxSphericalHarmonicsCoeff:p}}static writeHeaderCountsToBuffer(e,t,n){const s=new Uint32Array(n,0,j.HeaderSizeBytes/4);s[2]=e,s[4]=t}static writeHeaderToBuffer(e,t){const n=new Uint8Array(t,0,j.HeaderSizeBytes),s=new Uint16Array(t,0,j.HeaderSizeBytes/2),r=new Uint32Array(t,0,j.HeaderSizeBytes/4),i=new Float32Array(t,0,j.HeaderSizeBytes/4);n[0]=e.versionMajor,n[1]=e.versionMinor,n[2]=0,n[3]=0,r[1]=e.maxSectionCount,r[2]=e.sectionCount,r[3]=e.maxSplatCount,r[4]=e.splatCount,s[10]=e.compressionLevel,i[6]=e.sceneCenter.x,i[7]=e.sceneCenter.y,i[8]=e.sceneCenter.z,i[9]=e.minSphericalHarmonicsCoeff||-Ot,i[10]=e.maxSphericalHarmonicsCoeff||Ot}static parseSectionHeaders(e,t,n=0,s){const r=e.compressionLevel,i=e.maxSectionCount,o=new Uint16Array(t,n,i*j.SectionHeaderSizeBytes/2),a=new Uint32Array(t,n,i*j.SectionHeaderSizeBytes/4),c=new Float32Array(t,n,i*j.SectionHeaderSizeBytes/4),d=[];let u=0,f=u/2,h=u/4,g=j.HeaderSizeBytes+e.maxSectionCount*j.SectionHeaderSizeBytes,p=0;for(let m=0;m<i;m++){const A=a[h+1],y=a[h+2],v=a[h+3],x=c[h+4],w=x/2,T=o[f+10],C=a[h+6]||j.CompressionLevels[r].ScaleRange,E=a[h+8],I=a[h+9],P=I*4,B=T*v+P,M=o[f+20],{bytesPerSplat:D}=j.calculateComponentStorage(r,M),_=D*A,k=_+B,G={bytesPerSplat:D,splatCountOffset:p,splatCount:s?A:0,maxSplatCount:A,bucketSize:y,bucketCount:v,bucketBlockSize:x,halfBucketBlockSize:w,bucketStorageSizeBytes:T,bucketsStorageSizeBytes:B,splatDataStorageSizeBytes:_,storageSizeBytes:k,compressionScaleRange:C,compressionScaleFactor:w/C,base:g,bucketsBase:g+P,dataBase:g+B,fullBucketCount:E,partiallyFilledBucketCount:I,sphericalHarmonicsDegree:M};d[m]=G,g+=k,u+=j.SectionHeaderSizeBytes,f=u/2,h=u/4,p+=A}return d}static writeSectionHeaderToBuffer(e,t,n,s=0){const r=new Uint16Array(n,s,j.SectionHeaderSizeBytes/2),i=new Uint32Array(n,s,j.SectionHeaderSizeBytes/4),o=new Float32Array(n,s,j.SectionHeaderSizeBytes/4);i[0]=e.splatCount,i[1]=e.maxSplatCount,i[2]=t>=1?e.bucketSize:0,i[3]=t>=1?e.bucketCount:0,o[4]=t>=1?e.bucketBlockSize:0,r[10]=t>=1?j.BucketStorageSizeBytes:0,i[6]=t>=1?e.compressionScaleRange:0,i[7]=e.storageSizeBytes,i[8]=t>=1?e.fullBucketCount:0,i[9]=t>=1?e.partiallyFilledBucketCount:0,r[20]=e.sphericalHarmonicsDegree}static writeSectionHeaderSplatCountToBuffer(e,t,n=0){const s=new Uint32Array(t,n,j.SectionHeaderSizeBytes/4);s[0]=e}constructFromBuffer(e,t){this.bufferData=e,this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSectionMap=[];const n=j.parseHeader(this.bufferData);this.versionMajor=n.versionMajor,this.versionMinor=n.versionMinor,this.maxSectionCount=n.maxSectionCount,this.sectionCount=t?n.maxSectionCount:0,this.maxSplatCount=n.maxSplatCount,this.splatCount=t?n.maxSplatCount:0,this.compressionLevel=n.compressionLevel,this.sceneCenter=new F().copy(n.sceneCenter),this.minSphericalHarmonicsCoeff=n.minSphericalHarmonicsCoeff,this.maxSphericalHarmonicsCoeff=n.maxSphericalHarmonicsCoeff,this.sections=j.parseSectionHeaders(n,this.bufferData,j.HeaderSizeBytes,t),this.linkBufferArrays(),this.buildMaps()}static calculateComponentStorage(e,t){const n=j.CompressionLevels[e].BytesPerCenter,s=j.CompressionLevels[e].BytesPerScale,r=j.CompressionLevels[e].BytesPerRotation,i=j.CompressionLevels[e].BytesPerColor,o=An(t),a=j.CompressionLevels[e].BytesPerSphericalHarmonicsComponent*o,c=n+s+r+i+a;return{bytesPerCenter:n,bytesPerScale:s,bytesPerRotation:r,bytesPerColor:i,sphericalHarmonicsComponentsPerSplat:o,sphericalHarmonicsBytesPerSplat:a,bytesPerSplat:c}}linkBufferArrays(){for(let e=0;e<this.maxSectionCount;e++){const t=this.sections[e];t.bucketArray=new Float32Array(this.bufferData,t.bucketsBase,t.bucketCount*j.BucketStorageSizeFloats),t.partiallyFilledBucketCount>0&&(t.partiallyFilledBucketLengths=new Uint32Array(this.bufferData,t.base,t.partiallyFilledBucketCount))}}buildMaps(){let e=0;for(let t=0;t<this.maxSectionCount;t++){const n=this.sections[t];for(let s=0;s<n.maxSplatCount;s++){const r=e+s;this.globalSplatIndexToLocalSplatIndexMap[r]=s,this.globalSplatIndexToSectionMap[r]=t}e+=n.maxSplatCount}}updateLoadedCounts(e,t){j.writeHeaderCountsToBuffer(e,t,this.bufferData),this.sectionCount=e,this.splatCount=t}updateSectionLoadedCounts(e,t){const n=j.HeaderSizeBytes+j.SectionHeaderSizeBytes*e;j.writeSectionHeaderSplatCountToBuffer(t,this.bufferData,n),this.sections[e].splatCount=t}static writeSplatDataToSectionBuffer=function(){const e=new ArrayBuffer(12),t=new ArrayBuffer(12),n=new ArrayBuffer(16),s=new ArrayBuffer(4),r=new ArrayBuffer(256),i=new ce,o=new F,a=new F,{X:c,Y:d,Z:u,SCALE0:f,SCALE1:h,SCALE2:g,ROTATION0:p,ROTATION1:m,ROTATION2:A,ROTATION3:y,FDC0:v,FDC1:x,FDC2:w,OPACITY:T,FRC0:C,FRC9:E}=oe.OFFSET,I=(P,B,M)=>{const D=M*2+1;return P=Math.round(P*B)+M,Le(P,0,D)};return function(P,B,M,D,_,k,G,O,$=-Ot,U=Ot){const Z=An(_),V=j.CompressionLevels[D].BytesPerCenter,z=j.CompressionLevels[D].BytesPerScale,ne=j.CompressionLevels[D].BytesPerRotation,te=j.CompressionLevels[D].BytesPerColor,J=M,ue=J+V,me=ue+z,de=me+ne,fe=de+te;if(P[p]!==void 0?(i.set(P[p],P[m],P[A],P[y]),i.normalize()):i.set(1,0,0,0),P[f]!==void 0?o.set(P[f]||0,P[h]||0,P[g]||0):o.set(0,0,0),D===0){const X=new Float32Array(B,J,j.CenterComponentCount),ie=new Float32Array(B,me,j.RotationComponentCount),ee=new Float32Array(B,ue,j.ScaleComponentCount);if(ie.set([i.x,i.y,i.z,i.w]),ee.set([o.x,o.y,o.z]),X.set([P[c],P[d],P[u]]),_>0){const S=new Float32Array(B,fe,Z);if(_>=1){for(let N=0;N<9;N++)S[N]=P[C+N]||0;if(_>=2)for(let N=0;N<15;N++)S[N+9]=P[E+N]||0}}}else{const X=new Uint16Array(e,0,j.CenterComponentCount),ie=new Uint16Array(n,0,j.RotationComponentCount),ee=new Uint16Array(t,0,j.ScaleComponentCount);if(ie.set([Ve(i.x),Ve(i.y),Ve(i.z),Ve(i.w)]),ee.set([Ve(o.x),Ve(o.y),Ve(o.z)]),a.set(P[c],P[d],P[u]).sub(k),a.x=I(a.x,G,O),a.y=I(a.y,G,O),a.z=I(a.z,G,O),X.set([a.x,a.y,a.z]),_>0){const S=D===1?Uint16Array:Uint8Array,N=D===1?2:1,W=new S(r,0,Z);if(_>=1){for(let b=0;b<9;b++){const L=P[C+b]||0;W[b]=D===1?Ve(L):Ln(L,$,U)}const R=9*N;if(an(W.buffer,0,B,fe,R),_>=2){for(let b=0;b<15;b++){const L=P[E+b]||0;W[b+9]=D===1?Ve(L):Ln(L,$,U)}an(W.buffer,R,B,fe+R,15*N)}}}an(X.buffer,0,B,J,6),an(ee.buffer,0,B,ue,6),an(ie.buffer,0,B,me,8)}const q=new Uint8ClampedArray(s,0,4);q.set([P[v]||0,P[x]||0,P[w]||0]),q[3]=P[T]||0,an(q.buffer,0,B,de,4)}}();static generateFromUncompressedSplatArrays(e,t,n,s,r,i,o=[]){let a=0;for(let w=0;w<e.length;w++){const T=e[w];a=Math.max(T.sphericalHarmonicsDegree,a)}let c,d;for(let w=0;w<e.length;w++){const T=e[w];for(let C=0;C<T.splats.length;C++){const E=T.splats[C];for(let I=oe.OFFSET.FRC0;I<oe.OFFSET.FRC23&&I<E.length;I++)(!c||E[I]<c)&&(c=E[I]),(!d||E[I]>d)&&(d=E[I])}}c=c||-Ot,d=d||Ot;const{bytesPerSplat:u}=j.calculateComponentStorage(n,a),f=j.CompressionLevels[n].ScaleRange,h=[],g=[];let p=0;for(let w=0;w<e.length;w++){const T=e[w],C=new oe(a);for(let J=0;J<T.splatCount;J++){const ue=T.splats[J];(ue[oe.OFFSET.OPACITY]||0)>=t&&C.addSplat(ue)}const E=o[w]||{},I=(E.blockSizeFactor||1)*(r||j.BucketBlockSize),P=Math.ceil((E.bucketSizeFactor||1)*(i||j.BucketSize)),B=j.computeBucketsForUncompressedSplatArray(C,I,P),M=B.fullBuckets.length,D=B.partiallyFullBuckets.map(J=>J.splats.length),_=D.length,k=[...B.fullBuckets,...B.partiallyFullBuckets],G=C.splats.length*u,O=_*4,$=n>=1?k.length*j.BucketStorageSizeBytes+O:0,U=G+$,Z=new ArrayBuffer(U),V=f/(I*.5),z=new F;let ne=0;for(let J=0;J<k.length;J++){const ue=k[J];z.fromArray(ue.center);for(let me=0;me<ue.splats.length;me++){let de=ue.splats[me];const fe=C.splats[de],q=$+ne*u;j.writeSplatDataToSectionBuffer(fe,Z,q,n,a,z,V,f,c,d),ne++}}if(p+=ne,n>=1){const J=new Uint32Array(Z,0,D.length*4);for(let me=0;me<D.length;me++)J[me]=D[me];const ue=new Float32Array(Z,O,k.length*j.BucketStorageSizeFloats);for(let me=0;me<k.length;me++){const de=k[me],fe=me*3;ue[fe]=de.center[0],ue[fe+1]=de.center[1],ue[fe+2]=de.center[2]}}h.push(Z);const te=new ArrayBuffer(j.SectionHeaderSizeBytes);j.writeSectionHeaderToBuffer({maxSplatCount:ne,splatCount:ne,bucketSize:P,bucketCount:k.length,bucketBlockSize:I,compressionScaleRange:f,storageSizeBytes:U,fullBucketCount:M,partiallyFilledBucketCount:_,sphericalHarmonicsDegree:a},n,te,0),g.push(te)}let m=0;for(let w of h)m+=w.byteLength;const A=j.HeaderSizeBytes+j.SectionHeaderSizeBytes*h.length+m,y=new ArrayBuffer(A);j.writeHeaderToBuffer({versionMajor:0,versionMinor:1,maxSectionCount:h.length,sectionCount:h.length,maxSplatCount:p,splatCount:p,compressionLevel:n,sceneCenter:s,minSphericalHarmonicsCoeff:c,maxSphericalHarmonicsCoeff:d},y);let v=j.HeaderSizeBytes;for(let w of g)new Uint8Array(y,v,j.SectionHeaderSizeBytes).set(new Uint8Array(w)),v+=j.SectionHeaderSizeBytes;for(let w of h)new Uint8Array(y,v,w.byteLength).set(new Uint8Array(w)),v+=w.byteLength;return new j(y)}static computeBucketsForUncompressedSplatArray(e,t,n){let s=e.splatCount;const r=t/2,i=new F,o=new F;for(let p=0;p<s;p++){const m=e.splats[p],A=[m[oe.OFFSET.X],m[oe.OFFSET.Y],m[oe.OFFSET.Z]];(p===0||A[0]<i.x)&&(i.x=A[0]),(p===0||A[0]>o.x)&&(o.x=A[0]),(p===0||A[1]<i.y)&&(i.y=A[1]),(p===0||A[1]>o.y)&&(o.y=A[1]),(p===0||A[2]<i.z)&&(i.z=A[2]),(p===0||A[2]>o.z)&&(o.z=A[2])}const a=new F().copy(o).sub(i),c=Math.ceil(a.y/t),d=Math.ceil(a.z/t),u=new F,f=[],h={};for(let p=0;p<s;p++){const m=e.splats[p],A=[m[oe.OFFSET.X],m[oe.OFFSET.Y],m[oe.OFFSET.Z]],y=Math.floor((A[0]-i.x)/t),v=Math.floor((A[1]-i.y)/t),x=Math.floor((A[2]-i.z)/t);u.x=y*t+i.x+r,u.y=v*t+i.y+r,u.z=x*t+i.z+r;const w=y*(c*d)+v*d+x;let T=h[w];T||(h[w]=T={splats:[],center:u.toArray()}),T.splats.push(p),T.splats.length>=n&&(f.push(T),h[w]=null)}const g=[];for(let p in h)if(h.hasOwnProperty(p)){const m=h[p];m&&g.push(m)}return{fullBuckets:f,partiallyFullBuckets:g}}static preallocateUncompressed(e,t){const n=j.CompressionLevels[0].SphericalHarmonicsDegrees[t],s=j.HeaderSizeBytes+j.SectionHeaderSizeBytes,r=s+n.BytesPerSplat*e,i=new ArrayBuffer(r);return j.writeHeaderToBuffer({versionMajor:j.CurrentMajorVersion,versionMinor:j.CurrentMinorVersion,maxSectionCount:1,sectionCount:1,maxSplatCount:e,splatCount:e,compressionLevel:0,sceneCenter:new F},i),j.writeSectionHeaderToBuffer({maxSplatCount:e,splatCount:e,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0,sphericalHarmonicsDegree:t},0,i,j.HeaderSizeBytes),{splatBuffer:new j(i,!0),splatBufferDataOffsetBytes:s}}}const ro=new Uint8Array([112,108,121,10]),io=new Uint8Array([10,101,110,100,95,104,101,97,100,101,114,10]),ir="end_header",or=new Map([["char",Int8Array],["uchar",Uint8Array],["short",Int16Array],["ushort",Uint16Array],["int",Int32Array],["uint",Uint32Array],["float",Float32Array],["double",Float64Array]]),Et=(l,e)=>{const t=(1<<e)-1;return(l&t)/t},oo=(l,e)=>{l.x=Et(e>>>21,11),l.y=Et(e>>>11,10),l.z=Et(e,11)},Hh=(l,e)=>{l.x=Et(e>>>24,8),l.y=Et(e>>>16,8),l.z=Et(e>>>8,8),l.w=Et(e,8)},Vh=(l,e)=>{const t=1/(Math.sqrt(2)*.5),n=(Et(e>>>20,10)-.5)*t,s=(Et(e>>>10,10)-.5)*t,r=(Et(e,10)-.5)*t,i=Math.sqrt(1-(n*n+s*s+r*r));switch(e>>>30){case 0:l.set(i,n,s,r);break;case 1:l.set(n,i,s,r);break;case 2:l.set(n,s,i,r);break;case 3:l.set(n,s,r,i);break}},It=(l,e,t)=>l*(1-t)+e*t,ke=(l,e)=>l.properties.find(t=>t.name===e&&t.storage)?.storage;class we{static decodeHeaderText(e){let t,n,s,r;const i=e.split(`
`).filter(u=>!u.startsWith("comment "));let o=0,a=!1;for(let u=1;u<i.length;++u){const f=i[u].split(" ");switch(f[0]){case"format":if(f[1]!=="binary_little_endian")throw new Error("Unsupported ply format");break;case"element":t={name:f[1],count:parseInt(f[2],10),properties:[],storageSizeBytes:0},t.name==="chunk"?n=t:t.name==="vertex"?s=t:t.name==="sh"&&(r=t);break;case"property":{if(!or.has(f[1]))throw new Error(`Unrecognized property data type '${f[1]}' in ply header`);const h=or.get(f[1]),g=h.BYTES_PER_ELEMENT*t.count;t.name==="vertex"&&(o+=h.BYTES_PER_ELEMENT),t.properties.push({type:f[1],name:f[2],storage:null,byteSize:h.BYTES_PER_ELEMENT,storageSizeByes:g}),t.storageSizeBytes+=g;break}case ir:a=!0;break;default:throw new Error(`Unrecognized header value '${f[0]}' in ply header`)}if(a)break}let c=0,d=0;return r&&(d=r.properties.length,r.properties.length>=45?c=3:r.properties.length>=24?c=2:r.properties.length>=9&&(c=1)),{chunkElement:n,vertexElement:s,shElement:r,bytesPerSplat:o,headerSizeBytes:e.indexOf(ir)+ir.length+1,sphericalHarmonicsDegree:c,sphericalHarmonicsPerSplat:d}}static decodeHeader(e){const t=(h,g)=>{const p=h.length-g.length;let m,A;for(m=0;m<=p;++m){for(A=0;A<g.length&&h[m+A]===g[A];++A);if(A===g.length)return m}return-1},n=(h,g)=>{if(h.length<g.length)return!1;for(let p=0;p<g.length;++p)if(h[p]!==g[p])return!1;return!0};let s=new Uint8Array(e),r;if(s.length>=ro.length&&!n(s,ro))throw new Error("Invalid PLY header");if(r=t(s,io),r===-1)throw new Error("End of PLY header not found");const i=new TextDecoder("ascii").decode(s.slice(0,r)),{chunkElement:o,vertexElement:a,shElement:c,sphericalHarmonicsDegree:d,sphericalHarmonicsPerSplat:u,bytesPerSplat:f}=we.decodeHeaderText(i);return{headerSizeBytes:r+io.length,bytesPerSplat:f,chunkElement:o,vertexElement:a,shElement:c,sphericalHarmonicsDegree:d,sphericalHarmonicsPerSplat:u}}static readElementData(e,t,n,s,r,i=null){let o=t instanceof DataView?t:new DataView(t);s=s||0,r=r||e.count-1;for(let a=s;a<=r;++a)for(let c=0;c<e.properties.length;++c){const d=e.properties[c],u=or.get(d.type),f=u.BYTES_PER_ELEMENT*e.count;if((!d.storage||d.storage.byteLength<f)&&(!i||i(d.name))&&(d.storage=new u(e.count)),d.storage)switch(d.type){case"char":d.storage[a]=o.getInt8(n);break;case"uchar":d.storage[a]=o.getUint8(n);break;case"short":d.storage[a]=o.getInt16(n,!0);break;case"ushort":d.storage[a]=o.getUint16(n,!0);break;case"int":d.storage[a]=o.getInt32(n,!0);break;case"uint":d.storage[a]=o.getUint32(n,!0);break;case"float":d.storage[a]=o.getFloat32(n,!0);break;case"double":d.storage[a]=o.getFloat64(n,!0);break}n+=d.byteSize}return n}static readPly(e,t=null){const n=we.decodeHeader(e);let s=we.readElementData(n.chunkElement,e,n.headerSizeBytes,null,null,t);return s=we.readElementData(n.vertexElement,e,s,null,null,t),we.readElementData(n.shElement,e,s,null,null,t),{chunkElement:n.chunkElement,vertexElement:n.vertexElement,shElement:n.shElement,sphericalHarmonicsDegree:n.sphericalHarmonicsDegree,sphericalHarmonicsPerSplat:n.sphericalHarmonicsPerSplat}}static getElementStorageArrays(e,t,n){const s={};if(t){const r=ke(e,"min_r"),i=ke(e,"min_g"),o=ke(e,"min_b"),a=ke(e,"max_r"),c=ke(e,"max_g"),d=ke(e,"max_b"),u=ke(e,"min_x"),f=ke(e,"min_y"),h=ke(e,"min_z"),g=ke(e,"max_x"),p=ke(e,"max_y"),m=ke(e,"max_z"),A=ke(e,"min_scale_x"),y=ke(e,"min_scale_y"),v=ke(e,"min_scale_z"),x=ke(e,"max_scale_x"),w=ke(e,"max_scale_y"),T=ke(e,"max_scale_z"),C=ke(t,"packed_position"),E=ke(t,"packed_rotation"),I=ke(t,"packed_scale"),P=ke(t,"packed_color");s.colorExtremes={minR:r,maxR:a,minG:i,maxG:c,minB:o,maxB:d},s.positionExtremes={minX:u,maxX:g,minY:f,maxY:p,minZ:h,maxZ:m},s.scaleExtremes={minScaleX:A,maxScaleX:x,minScaleY:y,maxScaleY:w,minScaleZ:v,maxScaleZ:T},s.position=C,s.rotation=E,s.scale=I,s.color=P}if(n){const r={};for(let i=0;i<45;i++){const o=`f_rest_${i}`,a=ke(n,o);if(a)r[o]=a;else break}s.sh=r}return s}static decompressBaseSplat=function(){const e=new F,t=new ce,n=new F,s=new zt,r=oe.OFFSET;return function(i,o,a,c,d,u,f,h,g,p){p=p||oe.createSplat();const m=Math.floor((o+i)/256);return oo(e,a[i]),Vh(t,f[i]),oo(n,d[i]),Hh(s,g[i]),p[r.X]=It(c.minX[m],c.maxX[m],e.x),p[r.Y]=It(c.minY[m],c.maxY[m],e.y),p[r.Z]=It(c.minZ[m],c.maxZ[m],e.z),p[r.ROTATION0]=t.x,p[r.ROTATION1]=t.y,p[r.ROTATION2]=t.z,p[r.ROTATION3]=t.w,p[r.SCALE0]=Math.exp(It(u.minScaleX[m],u.maxScaleX[m],n.x)),p[r.SCALE1]=Math.exp(It(u.minScaleY[m],u.maxScaleY[m],n.y)),p[r.SCALE2]=Math.exp(It(u.minScaleZ[m],u.maxScaleZ[m],n.z)),h.minR&&h.maxR?p[r.FDC0]=Le(Math.round(It(h.minR[m],h.maxR[m],s.x)*255),0,255):p[r.FDC0]=Le(Math.floor(s.x*255),0,255),h.minG&&h.maxG?p[r.FDC1]=Le(Math.round(It(h.minG[m],h.maxG[m],s.y)*255),0,255):p[r.FDC1]=Le(Math.floor(s.y*255),0,255),h.minB&&h.maxB?p[r.FDC2]=Le(Math.round(It(h.minB[m],h.maxB[m],s.z)*255),0,255):p[r.FDC2]=Le(Math.floor(s.z*255),0,255),p[r.OPACITY]=Le(Math.floor(s.w*255),0,255),p}}();static decompressSphericalHarmonics=function(){const e=[0,3,8,15],t=[0,1,2,9,10,11,12,13,24,25,26,27,28,29,30,3,4,5,14,15,16,17,18,31,32,33,34,35,36,37,6,7,8,19,20,21,22,23,38,39,40,41,42,43,44];return function(n,s,r,i,o){o=o||oe.createSplat();let a=e[r],c=e[i];for(let d=0;d<3;++d)for(let u=0;u<15;++u){const f=t[d*15+u];u<a&&u<c&&(o[oe.OFFSET.FRC0+f]=s[d*c+u][n]*(8/255)-4)}return o}}();static parseToUncompressedSplatBufferSection(e,t,n,s,r,i,o,a,c=null){we.readElementData(t,i,0,n,s,c);const d=j.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat,{positionExtremes:u,scaleExtremes:f,colorExtremes:h,position:g,rotation:p,scale:m,color:A}=we.getElementStorageArrays(e,t),y=oe.createSplat();for(let v=n;v<=s;++v){we.decompressBaseSplat(v,r,g,u,m,f,p,h,A,y);const x=v*d+a;j.writeSplatDataToSectionBuffer(y,o,x,0,0)}}static parseToUncompressedSplatArraySection(e,t,n,s,r,i,o,a=null){we.readElementData(t,i,0,n,s,a);const{positionExtremes:c,scaleExtremes:d,colorExtremes:u,position:f,rotation:h,scale:g,color:p}=we.getElementStorageArrays(e,t);for(let m=n;m<=s;++m){const A=oe.createSplat();we.decompressBaseSplat(m,r,f,c,g,d,h,u,p,A),o.addSplat(A)}}static parseSphericalHarmonicsToUncompressedSplatArraySection(e,t,n,s,r,i,o,a,c,d=null){we.readElementData(t,r,i,n,s,d);const{sh:u}=we.getElementStorageArrays(e,void 0,t),f=Object.values(u);for(let h=n;h<=s;++h)we.decompressSphericalHarmonics(h,f,o,a,c.splats[h])}static parseToUncompressedSplatArray(e,t){const{chunkElement:n,vertexElement:s,shElement:r,sphericalHarmonicsDegree:i}=we.readPly(e);t=Math.min(t,i);const o=new oe(t),{positionExtremes:a,scaleExtremes:c,colorExtremes:d,position:u,rotation:f,scale:h,color:g}=we.getElementStorageArrays(n,s);let p;if(t>0){const{sh:m}=we.getElementStorageArrays(n,void 0,r);p=Object.values(m)}for(let m=0;m<s.count;++m){o.addDefaultSplat();const A=o.getSplat(o.splatCount-1);we.decompressBaseSplat(m,0,u,a,h,c,f,d,g,A),t>0&&we.decompressSphericalHarmonics(m,p,t,i,A)}return o}static parseToUncompressedSplatBuffer(e,t){const{chunkElement:n,vertexElement:s,shElement:r,sphericalHarmonicsDegree:i}=we.readPly(e);t=Math.min(t,i);const{splatBuffer:o,splatBufferDataOffsetBytes:a}=j.preallocateUncompressed(s.count,t),{positionExtremes:c,scaleExtremes:d,colorExtremes:u,position:f,rotation:h,scale:g,color:p}=we.getElementStorageArrays(n,s);let m;if(t>0){const{sh:v}=we.getElementStorageArrays(n,void 0,r);m=Object.values(v)}const A=j.CompressionLevels[0].SphericalHarmonicsDegrees[t].BytesPerSplat,y=oe.createSplat(t);for(let v=0;v<s.count;++v){we.decompressBaseSplat(v,0,f,c,g,d,h,u,p,y),t>0&&we.decompressSphericalHarmonics(v,m,t,i,y);const x=v*A+a;j.writeSplatDataToSectionBuffer(y,o.bufferData,x,0,t)}return o}}const st={INRIAV1:0,INRIAV2:1,PlayCanvasCompressed:2},[Fa,Wr,jr,Qr,Gr,qr,Xr]=[0,1,2,3,4,5,6],ao={double:Fa,int:Wr,uint:jr,float:Qr,short:Gr,ushort:qr,uchar:Xr},Wh={[Fa]:8,[Wr]:4,[jr]:4,[Qr]:4,[Gr]:2,[qr]:2,[Xr]:1};class Te{static HeaderEndToken="end_header";static decodeSectionHeader(e,t,n=0){const s=[];let r=!1,i=-1,o=0,a=!1,c=null;const d=[],u=[],f=[],h={};for(let A=n;A<e.length;A++){const y=e[A].trim();if(y.startsWith("element"))if(r){i--;break}else{r=!0,n=A,i=A;const v=y.split(" ");let x=0;for(let w of v){const T=w.trim();T.length>0&&(x++,x===2?c=T:x===3&&(o=parseInt(T)))}}else if(y.startsWith("property")){const v=y.match(/(\w+)\s+(\w+)\s+(\w+)/);if(v){const x=v[2],w=v[3];f.push(w);const T=t[w];h[w]=x;const C=ao[x];T!==void 0&&(d.push(T),u[T]=C)}}if(y===Te.HeaderEndToken){a=!0;break}r&&(s.push(y),i++)}const g=[];let p=0;for(let A of f){const y=h[A];if(h.hasOwnProperty(A)){const v=t[A];v!==void 0&&(g[v]=p)}p+=Wh[ao[y]]}const m=Te.decodeSphericalHarmonicsFromSectionHeader(f,t);return{headerLines:s,headerStartLine:n,headerEndLine:i,fieldTypes:u,fieldIds:d,fieldOffsets:g,bytesPerVertex:p,vertexCount:o,dataSizeBytes:p*o,endOfHeader:a,sectionName:c,sphericalHarmonicsDegree:m.degree,sphericalHarmonicsCoefficientsPerChannel:m.coefficientsPerChannel,sphericalHarmonicsDegree1Fields:m.degree1Fields,sphericalHarmonicsDegree2Fields:m.degree2Fields}}static decodeSphericalHarmonicsFromSectionHeader(e,t){let n=0,s=0;for(let a of e)a.startsWith("f_rest")&&n++;s=n/3;let r=0;s>=3&&(r=1),s>=8&&(r=2);let i=[],o=[];for(let a=0;a<3;a++){if(r>=1)for(let c=0;c<3;c++)i.push(t["f_rest_"+(c+s*a)]);if(r>=2)for(let c=0;c<5;c++)o.push(t["f_rest_"+(c+s*a+3)])}return{degree:r,coefficientsPerChannel:s,degree1Fields:i,degree2Fields:o}}static getHeaderSectionNames(e){const t=[];for(let n of e)if(n.startsWith("element")){const s=n.split(" ");let r=0;for(let i of s){const o=i.trim();o.length>0&&(r++,r===2&&t.push(o))}}return t}static checkTextForEndHeader(e){return!!e.includes(Te.HeaderEndToken)}static checkBufferForEndHeader(e,t,n,s){const r=new Uint8Array(e,Math.max(0,t-n),n),i=s.decode(r);return Te.checkTextForEndHeader(i)}static extractHeaderFromBufferToText(e){const t=new TextDecoder;let n=0,s="";const r=100;for(;;){if(n+r>=e.byteLength)throw new Error("End of file reached while searching for end of header");const i=new Uint8Array(e,n,r);if(s+=t.decode(i),n+=r,Te.checkBufferForEndHeader(e,n,r*2,t))break}return s}static readHeaderFromBuffer(e){const t=new TextDecoder;let n=0,s="";const r=100;for(;;){if(n+r>=e.byteLength)throw new Error("End of file reached while searching for end of header");const i=new Uint8Array(e,n,r);if(s+=t.decode(i),n+=r,Te.checkBufferForEndHeader(e,n,r*2,t))break}return s}static convertHeaderTextToLines(e){const t=e.split(`
`),n=[];for(let s=0;s<t.length;s++){const r=t[s].trim();if(n.push(r),r===Te.HeaderEndToken)break}return n}static determineHeaderFormatFromHeaderText(e){const t=Te.convertHeaderTextToLines(e);let n=st.INRIAV1;for(let s=0;s<t.length;s++){const r=t[s].trim();if(r.startsWith("element chunk")||r.match(/[A-Za-z]*packed_[A-Za-z]*/))n=st.PlayCanvasCompressed;else if(r.startsWith("element codebook_centers"))n=st.INRIAV2;else if(r===Te.HeaderEndToken)break}return n}static determineHeaderFormatFromPlyBuffer(e){const t=Te.extractHeaderFromBufferToText(e);return Te.determineHeaderFormatFromHeaderText(t)}static readVertex(e,t,n,s,r,i,o=!0){const a=n*t.bytesPerVertex+s,c=t.fieldOffsets,d=t.fieldTypes;for(let u of r){const f=d[u];f===Qr?i[u]=e.getFloat32(a+c[u],!0):f===Gr?i[u]=e.getInt16(a+c[u],!0):f===qr?i[u]=e.getUint16(a+c[u],!0):f===Wr?i[u]=e.getInt32(a+c[u],!0):f===jr?i[u]=e.getUint32(a+c[u],!0):f===Xr&&(o?i[u]=e.getUint8(a+c[u])/255:i[u]=e.getUint8(a+c[u]))}}}const La=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity","red","green","blue","f_rest_0"],jh=La.map((l,e)=>e),[lo,Qh,Gh,qh,Xh,Kh,Yh,Zh,Jh,$h,co,ef,tf,uo,ho,nf,sf,rf]=jh;class qe{static decodeHeaderLines(e){let t=0;e.forEach(d=>{d.includes("f_rest_")&&t++});let n=0;t>=45?n=45:t>=24?n=24:t>=9&&(n=9);let r=Array.from(Array(Math.max(n-1,0))).map((d,u)=>`f_rest_${u+1}`);const i=[...La,...r],o=i.map((d,u)=>u),a=o.reduce((d,u)=>(d[i[u]]=u,d),{}),c=Te.decodeSectionHeader(e,a,0);return c.splatCount=c.vertexCount,c.bytesPerSplat=c.bytesPerVertex,c.fieldsToReadIndexes=o,c}static decodeHeaderText(e){const t=Te.convertHeaderTextToLines(e),n=qe.decodeHeaderLines(t);return n.headerText=e,n.headerSizeBytes=e.indexOf(Te.HeaderEndToken)+Te.HeaderEndToken.length+1,n}static decodeHeaderFromBuffer(e){const t=Te.readHeaderFromBuffer(e);return qe.decodeHeaderText(t)}static findSplatData(e,t){return new DataView(e,t.headerSizeBytes)}static parseToUncompressedSplatBufferSection(e,t,n,s,r,i,o,a=0){a=Math.min(a,e.sphericalHarmonicsDegree);const c=j.CompressionLevels[0].SphericalHarmonicsDegrees[a].BytesPerSplat;for(let d=t;d<=n;d++){const u=qe.parseToUncompressedSplat(s,d,e,r,a),f=d*c+o;j.writeSplatDataToSectionBuffer(u,i,f,0,a)}}static parseToUncompressedSplatArraySection(e,t,n,s,r,i,o=0){o=Math.min(o,e.sphericalHarmonicsDegree);for(let a=t;a<=n;a++){const c=qe.parseToUncompressedSplat(s,a,e,r,o);i.addSplat(c)}}static decodeSectionSplatData(e,t,n,s,r=!0){if(s=Math.min(s,n.sphericalHarmonicsDegree),r){const i=new oe(s);for(let o=0;o<t;o++){const a=qe.parseToUncompressedSplat(e,o,n,0,s);i.addSplat(a)}return i}else{const{splatBuffer:i,splatBufferDataOffsetBytes:o}=j.preallocateUncompressed(t,s);return qe.parseToUncompressedSplatBufferSection(n,0,t-1,e,0,i.bufferData,o,s),i}}static parseToUncompressedSplat=function(){let e=[];const t=new ce,n=oe.OFFSET.X,s=oe.OFFSET.Y,r=oe.OFFSET.Z,i=oe.OFFSET.SCALE0,o=oe.OFFSET.SCALE1,a=oe.OFFSET.SCALE2,c=oe.OFFSET.ROTATION0,d=oe.OFFSET.ROTATION1,u=oe.OFFSET.ROTATION2,f=oe.OFFSET.ROTATION3,h=oe.OFFSET.FDC0,g=oe.OFFSET.FDC1,p=oe.OFFSET.FDC2,m=oe.OFFSET.OPACITY,A=[];for(let y=0;y<45;y++)A[y]=oe.OFFSET.FRC0+y;return function(y,v,x,w=0,T=0){T=Math.min(T,x.sphericalHarmonicsDegree),qe.readSplat(y,x,v,w,e);const C=oe.createSplat(T);if(e[lo]!==void 0?(C[i]=Math.exp(e[lo]),C[o]=Math.exp(e[Qh]),C[a]=Math.exp(e[Gh])):(C[i]=.01,C[o]=.01,C[a]=.01),e[co]!==void 0){const E=.28209479177387814;C[h]=(.5+E*e[co])*255,C[g]=(.5+E*e[ef])*255,C[p]=(.5+E*e[tf])*255}else e[ho]!==void 0?(C[h]=e[ho]*255,C[g]=e[nf]*255,C[p]=e[sf]*255):(C[h]=0,C[g]=0,C[p]=0);if(e[uo]!==void 0&&(C[m]=1/(1+Math.exp(-e[uo]))*255),C[h]=Le(Math.floor(C[h]),0,255),C[g]=Le(Math.floor(C[g]),0,255),C[p]=Le(Math.floor(C[p]),0,255),C[m]=Le(Math.floor(C[m]),0,255),T>=1&&e[rf]!==void 0){for(let E=0;E<9;E++)C[A[E]]=e[x.sphericalHarmonicsDegree1Fields[E]];if(T>=2)for(let E=0;E<15;E++)C[A[9+E]]=e[x.sphericalHarmonicsDegree2Fields[E]]}return t.set(e[qh],e[Xh],e[Kh],e[Yh]),t.normalize(),C[c]=t.x,C[d]=t.y,C[u]=t.z,C[f]=t.w,C[n]=e[Zh],C[s]=e[Jh],C[r]=e[$h],C}}();static readSplat(e,t,n,s,r){return Te.readVertex(e,t,n,s,t.fieldsToReadIndexes,r,!0)}static parseToUncompressedSplatArray(e,t=0){const{header:n,splatCount:s,splatData:r}=fo(e);return qe.decodeSectionSplatData(r,s,n,t,!0)}static parseToUncompressedSplatBuffer(e,t=0){const{header:n,splatCount:s,splatData:r}=fo(e);return qe.decodeSectionSplatData(r,s,n,t,!1)}}function fo(l){const e=qe.decodeHeaderFromBuffer(l),t=e.splatCount,n=qe.findSplatData(l,e);return{header:e,splatCount:t,splatData:n}}const ka=["features_dc","features_rest_0","features_rest_1","features_rest_2","features_rest_3","features_rest_4","features_rest_5","features_rest_6","features_rest_7","features_rest_8","features_rest_9","features_rest_10","features_rest_11","features_rest_12","features_rest_13","features_rest_14","opacity","scaling","rotation_re","rotation_im"],ss=ka.map((l,e)=>e),[rs,of,af,po,is,lf,ar]=[0,1,4,16,17,18,19],Oa=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity","red","green","blue","f_rest_0","f_rest_1","f_rest_2","f_rest_3","f_rest_4","f_rest_5","f_rest_6","f_rest_7","f_rest_8","f_rest_9","f_rest_10","f_rest_11","f_rest_12","f_rest_13","f_rest_14","f_rest_15","f_rest_16","f_rest_17","f_rest_18","f_rest_19","f_rest_20","f_rest_21","f_rest_22","f_rest_23","f_rest_24","f_rest_25","f_rest_26","f_rest_27","f_rest_28","f_rest_29","f_rest_30","f_rest_31","f_rest_32","f_rest_33","f_rest_34","f_rest_35","f_rest_36","f_rest_37","f_rest_38","f_rest_39","f_rest_40","f_rest_41","f_rest_42","f_rest_43","f_rest_44","f_rest_45"],Ir=Oa.map((l,e)=>e),[mo,cf,uf,df,hf,ff,pf,mf,gf,Af,Rr,Ua,Na,go]=Ir,Ao=Rr,yf=Ua,vf=Na,os=l=>{const e=(31744&l)>>10,t=1023&l;return(l>>15?-1:1)*(e?e===31?t?NaN:1/0:Math.pow(2,e-15)*(1+t/1024):t/1024*6103515625e-14)};class ct{static decodeSectionHeadersFromHeaderLines(e){const t=Ir.reduce((d,u)=>(d[Oa[u]]=u,d),{}),n=ss.reduce((d,u)=>(d[ka[u]]=u,d),{}),s=Te.getHeaderSectionNames(e);let r;for(let d=0;d<s.length;d++)s[d]==="codebook_centers"&&(r=d);let i=0,o=!1;const a=[];let c=0;for(;!o;){let d;c===r?d=Te.decodeSectionHeader(e,n,i):d=Te.decodeSectionHeader(e,t,i),o=d.endOfHeader,i=d.headerEndLine+1,o||(d.splatCount=d.vertexCount,d.bytesPerSplat=d.bytesPerVertex),a.push(d),c++}return a}static decodeSectionHeadersFromHeaderText(e){const t=Te.convertHeaderTextToLines(e);return ct.decodeSectionHeadersFromHeaderLines(t)}static getSplatCountFromSectionHeaders(e){let t=0;for(let n of e)n.sectionName!=="codebook_centers"&&(t+=n.vertexCount);return t}static decodeHeaderFromHeaderText(e){const t=e.indexOf(Te.HeaderEndToken)+Te.HeaderEndToken.length+1,n=ct.decodeSectionHeadersFromHeaderText(e),s=ct.getSplatCountFromSectionHeaders(n);return{headerSizeBytes:t,sectionHeaders:n,splatCount:s}}static decodeHeaderFromBuffer(e){const t=Te.readHeaderFromBuffer(e);return ct.decodeHeaderFromHeaderText(t)}static findVertexData(e,t,n){let s=t.headerSizeBytes;for(let r=0;r<n&&r<t.sectionHeaders.length;r++){const i=t.sectionHeaders[r];s+=i.dataSizeBytes}return new DataView(e,s,t.sectionHeaders[n].dataSizeBytes)}static decodeCodeBook(e,t){const n=[],s=[];for(let r=0;r<t.vertexCount;r++){Te.readVertex(e,t,r,0,ss,n);for(let i of ss){const o=ss[i];let a=s[o];a||(s[o]=a=[]),a.push(n[i])}}for(let r=0;r<s.length;r++){const i=s[r],o=.28209479177387814;for(let a=0;a<i.length;a++){const c=os(i[a]);r===po?i[a]=Math.round(1/(1+Math.exp(-c))*255):r===rs?i[a]=Math.round((.5+o*c)*255):r===is?i[a]=Math.exp(c):i[a]=c}}return s}static decodeSectionSplatData(e,t,n,s,r){r=Math.min(r,n.sphericalHarmonicsDegree);const i=new oe(r);for(let o=0;o<t;o++){const a=ct.parseToUncompressedSplat(e,o,n,s,0,r);i.addSplat(a)}return i}static parseToUncompressedSplat=function(){let e=[];const t=new ce,n=oe.OFFSET.X,s=oe.OFFSET.Y,r=oe.OFFSET.Z,i=oe.OFFSET.SCALE0,o=oe.OFFSET.SCALE1,a=oe.OFFSET.SCALE2,c=oe.OFFSET.ROTATION0,d=oe.OFFSET.ROTATION1,u=oe.OFFSET.ROTATION2,f=oe.OFFSET.ROTATION3,h=oe.OFFSET.FDC0,g=oe.OFFSET.FDC1,p=oe.OFFSET.FDC2,m=oe.OFFSET.OPACITY,A=[];for(let y=0;y<45;y++)A[y]=oe.OFFSET.FRC0+y;return function(y,v,x,w,T=0,C=0){C=Math.min(C,x.sphericalHarmonicsDegree),ct.readSplat(y,x,v,T,e);const E=oe.createSplat(C);if(e[mo]!==void 0?(E[i]=w[is][e[mo]],E[o]=w[is][e[cf]],E[a]=w[is][e[uf]]):(E[i]=.01,E[o]=.01,E[a]=.01),e[Rr]!==void 0?(E[h]=w[rs][e[Rr]],E[g]=w[rs][e[Ua]],E[p]=w[rs][e[Na]]):e[Ao]!==void 0?(E[h]=e[Ao]*255,E[g]=e[yf]*255,E[p]=e[vf]*255):(E[h]=0,E[g]=0,E[p]=0),e[go]!==void 0&&(E[m]=w[po][e[go]]),E[h]=Le(Math.floor(E[h]),0,255),E[g]=Le(Math.floor(E[g]),0,255),E[p]=Le(Math.floor(E[p]),0,255),E[m]=Le(Math.floor(E[m]),0,255),C>=1&&x.sphericalHarmonicsDegree>=1){for(let D=0;D<9;D++){const _=w[of+D%3];E[A[D]]=_[e[x.sphericalHarmonicsDegree1Fields[D]]]}if(C>=2&&x.sphericalHarmonicsDegree>=2)for(let D=0;D<15;D++){const _=w[af+D%5];E[A[9+D]]=_[e[x.sphericalHarmonicsDegree2Fields[D]]]}}const I=w[lf][e[df]],P=w[ar][e[hf]],B=w[ar][e[ff]],M=w[ar][e[pf]];return t.set(I,P,B,M),t.normalize(),E[c]=t.x,E[d]=t.y,E[u]=t.z,E[f]=t.w,E[n]=os(e[mf]),E[s]=os(e[gf]),E[r]=os(e[Af]),E}}();static readSplat(e,t,n,s,r){return Te.readVertex(e,t,n,s,Ir,r,!1)}static parseToUncompressedSplatArray(e,t=0){const n=[],s=ct.decodeHeaderFromBuffer(e,t);let r;for(let o=0;o<s.sectionHeaders.length;o++){const a=s.sectionHeaders[o];if(a.sectionName==="codebook_centers"){const c=ct.findVertexData(e,s,o);r=ct.decodeCodeBook(c,a)}}for(let o=0;o<s.sectionHeaders.length;o++){const a=s.sectionHeaders[o];if(a.sectionName!=="codebook_centers"){const c=a.vertexCount,d=ct.findVertexData(e,s,o),u=ct.decodeSectionSplatData(d,c,a,r,t);n.push(u)}}const i=new oe(t);for(let o of n)for(let a of o.splats)i.addSplat(a);return i}}class yo{static parseToUncompressedSplatArray(e,t=0){const n=Te.determineHeaderFormatFromPlyBuffer(e);if(n===st.PlayCanvasCompressed)return we.parseToUncompressedSplatArray(e,t);if(n===st.INRIAV1)return qe.parseToUncompressedSplatArray(e,t);if(n===st.INRIAV2)return ct.parseToUncompressedSplatArray(e,t)}static parseToUncompressedSplatBuffer(e,t=0){const n=Te.determineHeaderFormatFromPlyBuffer(e);if(n===st.PlayCanvasCompressed)return we.parseToUncompressedSplatBuffer(e,t);if(n===st.INRIAV1)return qe.parseToUncompressedSplatBuffer(e,t);if(n===st.INRIAV2)throw new Error("parseToUncompressedSplatBuffer() is not implemented for INRIA V2 PLY files")}}class Kr{constructor(e,t,n,s){this.sectionCount=e,this.sectionFilters=t,this.groupingParameters=n,this.partitionGenerator=s}partitionUncompressedSplatArray(e){let t,n,s;if(this.partitionGenerator){const i=this.partitionGenerator(e);t=i.groupingParameters,n=i.sectionCount,s=i.sectionFilters}else t=this.groupingParameters,n=this.sectionCount,s=this.sectionFilters;const r=[];for(let i=0;i<n;i++){const o=new oe(e.sphericalHarmonicsDegree),a=s[i];for(let c=0;c<e.splatCount;c++)a(c)&&o.addSplat(e.splats[c]);r.push(o)}return{splatArrays:r,parameters:t}}static getStandardPartitioner(e=0,t=new F,n=j.BucketBlockSize,s=j.BucketSize){const r=i=>{const o=oe.OFFSET.X,a=oe.OFFSET.Y,c=oe.OFFSET.Z;e<=0&&(e=i.splatCount);const d=new F,u=.5,f=A=>{A.x=Math.floor(A.x/u)*u,A.y=Math.floor(A.y/u)*u,A.z=Math.floor(A.z/u)*u};i.splats.forEach(A=>{d.set(A[o],A[a],A[c]).sub(t),f(d),A.centerDist=d.lengthSq()});const h=[],g=[];e=Math.min(i.splatCount,e);const p=Math.ceil(i.splatCount/e);let m=0;for(let A=0;A<p;A++){let y=m;h.push(v=>v>=y&&v<y+e),g.push({blocksSize:n,bucketSize:s}),m+=e}return{sectionCount:h.length,sectionFilters:h,groupingParameters:g}};return new Kr(void 0,void 0,void 0,r)}}class qn{constructor(e,t,n,s,r,i,o){this.splatPartitioner=e,this.alphaRemovalThreshold=t,this.compressionLevel=n,this.sectionSize=s,this.sceneCenter=r?new F().copy(r):void 0,this.blockSize=i,this.bucketSize=o}generateFromUncompressedSplatArray(e){const t=this.splatPartitioner.partitionUncompressedSplatArray(e);return j.generateFromUncompressedSplatArrays(t.splatArrays,this.alphaRemovalThreshold,this.compressionLevel,this.sceneCenter,this.blockSize,this.bucketSize,t.parameters)}static getStandardGenerator(e=1,t=1,n=0,s=new F,r=j.BucketBlockSize,i=j.BucketSize){const o=Kr.getStandardPartitioner(n,s,r,i);return new qn(o,e,t,n,s,r,i)}}const ze={Downloading:0,Processing:1,Done:2};class Es extends Error{constructor(e){super(e)}}const Pe={ProgressiveToSplatBuffer:0,ProgressiveToSplatArray:1,DownloadBeforeProcessing:2};function vo(l,e){let t=0;for(let s of l)t+=s.sizeBytes;(!e||e.byteLength<t)&&(e=new ArrayBuffer(t));let n=0;for(let s of l)new Uint8Array(e,n,s.sizeBytes).set(s.data),n+=s.sizeBytes;return e}function xo(l,e,t,n,s,r,i,o){return e?qn.getStandardGenerator(t,n,s,r,i,o).generateFromUncompressedSplatArray(l):j.generateFromUncompressedSplatArrays([l],t,0,new F)}class Yr{static loadFromURL(e,t,n,s,r,i,o=!0,a=0,c,d,u,f,h){let g;!n&&!o?g=Pe.DownloadBeforeProcessing:o?g=Pe.ProgressiveToSplatArray:g=Pe.ProgressiveToSplatBuffer;const p=Ee.ProgressiveLoadSectionSize,m=j.HeaderSizeBytes+j.SectionHeaderSizeBytes,A=1;let y,v,x,w,T,C=0,E=0,I=0,P=!1,B=!1,M=!1;const D=Nr();let _=0,k=0,G=0,O=0,$="",U=null,Z=[],V;const z=new TextDecoder,ne=(te,J,ue)=>{const me=te>=100;if(ue&&(Z.push({data:ue,sizeBytes:ue.byteLength,startBytes:G,endBytes:G+ue.byteLength}),G+=ue.byteLength),g===Pe.DownloadBeforeProcessing)me&&D.resolve(Z);else{if(P){if(y===st.PlayCanvasCompressed&&!B){const de=U.headerSizeBytes+U.chunkElement.storageSizeBytes;T=vo(Z,T),T.byteLength>=de&&(we.readElementData(U.chunkElement,T,U.headerSizeBytes),_=de,k=de,B=!0)}}else if($+=z.decode(ue),Te.checkTextForEndHeader($)){if(y=Te.determineHeaderFormatFromHeaderText($),y===st.INRIAV1)U=qe.decodeHeaderText($),a=Math.min(a,U.sphericalHarmonicsDegree),C=U.splatCount,B=!0,O=U.headerSizeBytes+U.bytesPerSplat*C;else if(y===st.PlayCanvasCompressed){if(U=we.decodeHeaderText($),a=Math.min(a,U.sphericalHarmonicsDegree),g===Pe.ProgressiveToSplatBuffer&&a>0)throw new Es("PlyLoader.loadFromURL() -> Selected PLY format has spherical harmonics data that cannot be progressively loaded.");C=U.vertexElement.count,O=U.headerSizeBytes+U.bytesPerSplat*C+U.chunkElement.storageSizeBytes}else{if(g===Pe.ProgressiveToSplatBuffer)throw new Es("PlyLoader.loadFromURL() -> Selected PLY format cannot be progressively loaded.");g=Pe.DownloadBeforeProcessing;return}if(g===Pe.ProgressiveToSplatBuffer){const de=j.CompressionLevels[0].SphericalHarmonicsDegrees[a],fe=m+de.BytesPerSplat*C;x=new ArrayBuffer(fe),j.writeHeaderToBuffer({versionMajor:j.CurrentMajorVersion,versionMinor:j.CurrentMinorVersion,maxSectionCount:A,sectionCount:A,maxSplatCount:C,splatCount:0,compressionLevel:0,sceneCenter:new F},x)}else V=new oe(a);_=U.headerSizeBytes,k=U.headerSizeBytes,P=!0}if(P&&B&&Z.length>0&&(v=vo(Z,v),G-_>p||G>=O&&!M||me)){const fe=M?U.sphericalHarmonicsPerSplat:U.bytesPerSplat,X=(M?G:Math.min(O,G))-k,ie=Math.floor(X/fe),ee=ie*fe,S=G-k-ee,N=k-Z[0].startBytes,W=new DataView(v,N,ee);if(M)y===st.PlayCanvasCompressed&&g===Pe.ProgressiveToSplatArray&&(we.parseSphericalHarmonicsToUncompressedSplatArraySection(U.chunkElement,U.shElement,I,I+ie-1,W,0,a,U.sphericalHarmonicsDegree,V),I+=ie);else{if(g===Pe.ProgressiveToSplatBuffer){const R=j.CompressionLevels[0].SphericalHarmonicsDegrees[a],b=E*R.BytesPerSplat+m;y===st.PlayCanvasCompressed?we.parseToUncompressedSplatBufferSection(U.chunkElement,U.vertexElement,0,ie-1,E,W,x,b):qe.parseToUncompressedSplatBufferSection(U,0,ie-1,W,0,x,b,a)}else y===st.PlayCanvasCompressed?we.parseToUncompressedSplatArraySection(U.chunkElement,U.vertexElement,0,ie-1,E,W,V):qe.parseToUncompressedSplatArraySection(U,0,ie-1,W,0,V,a);E+=ie,g===Pe.ProgressiveToSplatBuffer&&(w||(j.writeSectionHeaderToBuffer({maxSplatCount:C,splatCount:E,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0,sphericalHarmonicsDegree:a},0,x,j.HeaderSizeBytes),w=new j(x,!1)),w.updateLoadedCounts(1,E)),G>=O&&(M=!0)}if(S===0)Z=[];else{let R=[],b=0;for(let L=Z.length-1;L>=0;L--){const K=Z[L];if(b+=K.sizeBytes,R.unshift(K),b>=S)break}Z=R}_+=p,k+=ee}s&&w&&s(w,me),me&&(g===Pe.ProgressiveToSplatBuffer?D.resolve(w):D.resolve(V))}t&&t(te,J,ze.Downloading)};return t&&t(0,"0%",ze.Downloading),Fs(e,ne,!1,c).then(()=>(t&&t(0,"0%",ze.Processing),D.promise.then(te=>{if(t&&t(100,"100%",ze.Done),g===Pe.DownloadBeforeProcessing){const J=Z.map(ue=>ue.data);return new Blob(J).arrayBuffer().then(ue=>Yr.loadFromFileData(ue,r,i,o,a,d,u,f,h))}else return g===Pe.ProgressiveToSplatBuffer?te:ut(()=>xo(te,o,r,i,d,u,f,h))})))}static loadFromFileData(e,t,n,s,r=0,i,o,a,c){return s?ut(()=>yo.parseToUncompressedSplatArray(e,r)).then(d=>xo(d,s,t,n,i,o,a,c)):ut(()=>yo.parseToUncompressedSplatBuffer(e,r))}}const xf=l=>new ReadableStream({async start(e){e.enqueue(l),e.close()}});async function Sf(l){try{const e=xf(l);if(!e)throw new Error("Failed to create stream from data");return await wf(e)}catch(e){throw console.error("Error decompressing gzipped data:",e),e}}async function wf(l){const e=l.pipeThrough(new DecompressionStream("gzip")),n=await new Response(e).arrayBuffer();return new Uint8Array(n)}const _f=1347635022,Cf=1,Tf=.15;function Mf(l){const e=l>>15&1,t=l>>10&31,n=l&1023,s=e===1?-1:1;return t===0?s*Math.pow(2,-14)*n/1024:t===31?n!==0?NaN:s*(1/0):s*Math.pow(2,t-15)*(1+n/1024)}function Ef(l){return(l-128)/128}function qt(l){switch(l){case 0:return 0;case 1:return 3;case 2:return 8;case 3:return 15;default:return console.error(`[SPZ: ERROR] Unsupported SH degree: ${l}`),0}}const bf=function(){let l=[];const e=new ce,t=oe.OFFSET.X,n=oe.OFFSET.Y,s=oe.OFFSET.Z,r=oe.OFFSET.SCALE0,i=oe.OFFSET.SCALE1,o=oe.OFFSET.SCALE2,a=oe.OFFSET.ROTATION0,c=oe.OFFSET.ROTATION1,d=oe.OFFSET.ROTATION2,u=oe.OFFSET.ROTATION3,f=oe.OFFSET.FDC0,h=oe.OFFSET.FDC1,g=oe.OFFSET.FDC2,p=oe.OFFSET.OPACITY,m=[qt(0),qt(1),qt(2),qt(3)],A=[0,1,2,9,10,11,12,13,24,25,26,27,28,29,30,3,4,5,14,15,16,17,18,31,32,33,34,35,36,37,6,7,8,19,20,21,22,23,38,39,40,41,42,43,44];return function(y,v,x){x=Math.min(v,x);const w=oe.createSplat(x);y.scale[0]!==void 0?(w[r]=y.scale[0],w[i]=y.scale[1],w[o]=y.scale[2]):(w[r]=.01,w[i]=.01,w[o]=.01),y.color[0]!==void 0?(w[f]=y.color[0],w[h]=y.color[1],w[g]=y.color[2]):l[RED]!==void 0?(w[f]=l[RED]*255,w[h]=l[GREEN]*255,w[g]=l[BLUE]*255):(w[f]=0,w[h]=0,w[g]=0),y.alpha!==void 0&&(w[p]=y.alpha),w[f]=Le(Math.floor(w[f]),0,255),w[h]=Le(Math.floor(w[h]),0,255),w[g]=Le(Math.floor(w[g]),0,255),w[p]=Le(Math.floor(w[p]),0,255);let T=m[x],C=m[v];for(let E=0;E<3;++E)for(let I=0;I<15;++I){const P=A[E*15+I];I<T&&I<C&&(w[oe.OFFSET.FRC0+P]=y.sh[E*C+I])}return e.set(y.rotation[3],y.rotation[0],y.rotation[1],y.rotation[2]),e.normalize(),w[a]=e.x,w[c]=e.y,w[d]=e.z,w[u]=e.w,w[t]=y.position[0],w[n]=y.position[1],w[s]=y.position[2],w}}();function If(l,e,t,n){return!(l.positions.length!==e*3*(n?2:3)||l.scales.length!==e*3||l.rotations.length!==e*3||l.alphas.length!==e||l.colors.length!==e*3||l.sh.length!==e*t*3)}function So(l,e,t,n,s){e=Math.min(e,l.shDegree);const r=l.numPoints,i=qt(l.shDegree),o=l.positions.length===r*3*2;if(!If(l,r,i,o))return null;const a={position:[],scale:[],rotation:[],alpha:void 0,color:[],sh:[]};let c;o&&(c=new Uint16Array(l.positions.buffer,l.positions.byteOffset,r*3));const d=1/(1<<l.fractionalBits),u=qt(l.shDegree),f=.28209479177387814;for(let h=0;h<r;h++){if(o)for(let y=0;y<3;y++)a.position[y]=Mf(c[h*3+y]);else for(let y=0;y<3;y++){const v=h*9+y*3;let x=l.positions[v];x|=l.positions[v+1]<<8,x|=l.positions[v+2]<<16,x|=x&8388608?4278190080:0,a.position[y]=x*d}for(let y=0;y<3;y++)a.scale[y]=Math.exp(l.scales[h*3+y]/16-10);const g=l.rotations.subarray(h*3,h*3+3),p=[g[0]/127.5-1,g[1]/127.5-1,g[2]/127.5-1];a.rotation[0]=p[0],a.rotation[1]=p[1],a.rotation[2]=p[2];const m=p[0]*p[0]+p[1]*p[1]+p[2]*p[2];a.rotation[3]=Math.sqrt(Math.max(0,1-m)),a.alpha=Math.floor(l.alphas[h]);for(let y=0;y<3;y++)a.color[y]=Math.floor(((l.colors[h*3+y]/255-.5)/Tf*f+.5)*255);for(let y=0;y<3;y++)for(let v=0;v<u;v++)a.sh[y*u+v]=Ef(l.sh[u*3*h+v*3+y]);const A=bf(a,l.shDegree,e);if(t){const y=j.CompressionLevels[0].SphericalHarmonicsDegrees[e].BytesPerSplat,v=h*y+s;j.writeSplatDataToSectionBuffer(A,n,v,0,e)}else n.addSplat(A)}}const Rf=16,Bf=1e7;function Pf(l){const e=new DataView(l);let t=0;const n={magic:e.getUint32(t,!0),version:e.getUint32(t+4,!0),numPoints:e.getUint32(t+8,!0),shDegree:e.getUint8(t+12),fractionalBits:e.getUint8(t+13),flags:e.getUint8(t+14),reserved:e.getUint8(t+15)};if(t+=Rf,n.magic!==_f)return console.error("[SPZ ERROR] deserializePackedGaussians: header not found"),null;if(n.version<1||n.version>2)return console.error(`[SPZ ERROR] deserializePackedGaussians: version not supported: ${n.version}`),null;if(n.numPoints>Bf)return console.error(`[SPZ ERROR] deserializePackedGaussians: Too many points: ${n.numPoints}`),null;if(n.shDegree>3)return console.error(`[SPZ ERROR] deserializePackedGaussians: Unsupported SH degree: ${n.shDegree}`),null;const s=n.numPoints,r=qt(n.shDegree),i=n.version===1,o={numPoints:s,shDegree:n.shDegree,fractionalBits:n.fractionalBits,antialiased:(n.flags&Cf)!==0,positions:new Uint8Array(s*3*(i?2:3)),scales:new Uint8Array(s*3),rotations:new Uint8Array(s*3),alphas:new Uint8Array(s),colors:new Uint8Array(s*3),sh:new Uint8Array(s*r*3)};try{const a=new Uint8Array(l);let c=o.positions.length,d=t;if(o.positions.set(a.slice(d,d+c)),d+=c,o.alphas.set(a.slice(d,d+o.alphas.length)),d+=o.alphas.length,o.colors.set(a.slice(d,d+o.colors.length)),d+=o.colors.length,o.scales.set(a.slice(d,d+o.scales.length)),d+=o.scales.length,o.rotations.set(a.slice(d,d+o.rotations.length)),d+=o.rotations.length,o.sh.set(a.slice(d,d+o.sh.length)),d+o.sh.length!==l.byteLength)return console.error("[SPZ ERROR] deserializePackedGaussians: incorrect buffer size"),null}catch(a){return console.error("[SPZ ERROR] deserializePackedGaussians: read error",a),null}return o}async function Df(l){try{const e=await Sf(l);return Pf(e.buffer)}catch(e){return console.error("[SPZ ERROR] loadSpzPacked: decompression error",e),null}}class Zr{static loadFromURL(e,t,n,s,r=!0,i=0,o,a,c,d,u){return t&&t(0,"0%",ze.Downloading),Fs(e,t,!0,o).then(f=>(t&&t(0,"0%",ze.Processing),Zr.loadFromFileData(f,n,s,r,i,a,c,d,u)))}static async loadFromFileData(e,t,n,s,r=0,i,o,a,c){await ut();const d=await Df(e);r=Math.min(d.shDegree,r);const u=new oe(r);if(s)return So(d,r,!1,u,0),qn.getStandardGenerator(t,n,i,o,a,c).generateFromUncompressedSplatArray(u);{const{splatBuffer:f,splatBufferDataOffsetBytes:h}=j.preallocateUncompressed(d.numPoints,r);return So(d,r,!0,f.bufferData,h),f}}}class Ie{static RowSizeBytes=32;static CenterSizeBytes=12;static ScaleSizeBytes=12;static RotationSizeBytes=4;static ColorSizeBytes=4;static parseToUncompressedSplatBufferSection(e,t,n,s,r,i){const o=j.CompressionLevels[0].BytesPerCenter,a=j.CompressionLevels[0].BytesPerScale,c=j.CompressionLevels[0].BytesPerRotation,d=j.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat;for(let u=e;u<=t;u++){const f=u*Ie.RowSizeBytes+s,h=new Float32Array(n,f,3),g=new Float32Array(n,f+Ie.CenterSizeBytes,3),p=new Uint8Array(n,f+Ie.CenterSizeBytes+Ie.ScaleSizeBytes,4),m=new Uint8Array(n,f+Ie.CenterSizeBytes+Ie.ScaleSizeBytes+Ie.RotationSizeBytes,4),A=new ce((m[1]-128)/128,(m[2]-128)/128,(m[3]-128)/128,(m[0]-128)/128);A.normalize();const y=u*d+i,v=new Float32Array(r,y,3),x=new Float32Array(r,y+o,3),w=new Float32Array(r,y+o+a,4),T=new Uint8Array(r,y+o+a+c,4);v[0]=h[0],v[1]=h[1],v[2]=h[2],x[0]=g[0],x[1]=g[1],x[2]=g[2],w[0]=A.w,w[1]=A.x,w[2]=A.y,w[3]=A.z,T[0]=p[0],T[1]=p[1],T[2]=p[2],T[3]=p[3]}}static parseToUncompressedSplatArraySection(e,t,n,s,r){for(let i=e;i<=t;i++){const o=i*Ie.RowSizeBytes+s,a=new Float32Array(n,o,3),c=new Float32Array(n,o+Ie.CenterSizeBytes,3),d=new Uint8Array(n,o+Ie.CenterSizeBytes+Ie.ScaleSizeBytes,4),u=new Uint8Array(n,o+Ie.CenterSizeBytes+Ie.ScaleSizeBytes+Ie.RotationSizeBytes,4),f=new ce((u[1]-128)/128,(u[2]-128)/128,(u[3]-128)/128,(u[0]-128)/128);f.normalize(),r.addSplatFromComonents(a[0],a[1],a[2],c[0],c[1],c[2],f.w,f.x,f.y,f.z,d[0],d[1],d[2],d[3])}}static parseStandardSplatToUncompressedSplatArray(e){const t=e.byteLength/Ie.RowSizeBytes,n=new oe;for(let s=0;s<t;s++){const r=s*Ie.RowSizeBytes,i=new Float32Array(e,r,3),o=new Float32Array(e,r+Ie.CenterSizeBytes,3),a=new Uint8Array(e,r+Ie.CenterSizeBytes+Ie.ScaleSizeBytes,4),c=new Uint8Array(e,r+Ie.CenterSizeBytes+Ie.ScaleSizeBytes+Ie.ColorSizeBytes,4),d=new ce((c[1]-128)/128,(c[2]-128)/128,(c[3]-128)/128,(c[0]-128)/128);d.normalize(),n.addSplatFromComonents(i[0],i[1],i[2],o[0],o[1],o[2],d.w,d.x,d.y,d.z,a[0],a[1],a[2],a[3])}return n}}function wo(l,e,t,n,s,r,i,o){return e?qn.getStandardGenerator(t,n,s,r,i,o).generateFromUncompressedSplatArray(l):j.generateFromUncompressedSplatArrays([l],t,0,new F)}class Jr{static loadFromURL(e,t,n,s,r,i,o=!0,a,c,d,u,f){let h=n?Pe.ProgressiveToSplatBuffer:Pe.ProgressiveToSplatArray;o&&(h=Pe.ProgressiveToSplatArray);const g=j.HeaderSizeBytes+j.SectionHeaderSizeBytes,p=Ee.ProgressiveLoadSectionSize,m=1;let A,y,v,x=0,w=0,T;const C=Nr();let E=0,I=0,P=[];const B=(M,D,_,k)=>{const G=M>=100;if(_&&P.push(_),h===Pe.DownloadBeforeProcessing){G&&C.resolve(P);return}if(!k){if(n)throw new Es("Cannon directly load .splat because no file size info is available.");h=Pe.DownloadBeforeProcessing;return}if(!A){x=k/Ie.RowSizeBytes,A=new ArrayBuffer(k);const O=j.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat,$=g+O*x;h===Pe.ProgressiveToSplatBuffer?(y=new ArrayBuffer($),j.writeHeaderToBuffer({versionMajor:j.CurrentMajorVersion,versionMinor:j.CurrentMinorVersion,maxSectionCount:m,sectionCount:m,maxSplatCount:x,splatCount:w,compressionLevel:0,sceneCenter:new F},y)):T=new oe(0)}if(_){new Uint8Array(A,I,_.byteLength).set(new Uint8Array(_)),I+=_.byteLength;const O=I-E;if(O>p||G){const U=(G?O:p)/Ie.RowSizeBytes,Z=w+U;h===Pe.ProgressiveToSplatBuffer?Ie.parseToUncompressedSplatBufferSection(w,Z-1,A,0,y,g):Ie.parseToUncompressedSplatArraySection(w,Z-1,A,0,T),w=Z,h===Pe.ProgressiveToSplatBuffer&&(v||(j.writeSectionHeaderToBuffer({maxSplatCount:x,splatCount:w,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0},0,y,j.HeaderSizeBytes),v=new j(y,!1)),v.updateLoadedCounts(1,w),s&&s(v,G)),E+=p}}G&&(h===Pe.ProgressiveToSplatBuffer?C.resolve(v):C.resolve(T)),t&&t(M,D,ze.Downloading)};return t&&t(0,"0%",ze.Downloading),Fs(e,B,!1,a).then(()=>(t&&t(0,"0%",ze.Processing),C.promise.then(M=>(t&&t(100,"100%",ze.Done),h===Pe.DownloadBeforeProcessing?new Blob(P).arrayBuffer().then(D=>Jr.loadFromFileData(D,r,i,o,c,d,u,f)):h===Pe.ProgressiveToSplatBuffer?M:ut(()=>wo(M,o,r,i,c,d,u,f))))))}static loadFromFileData(e,t,n,s,r,i,o,a){return ut(()=>{const c=Ie.parseStandardSplatToUncompressedSplatArray(e);return wo(c,s,t,n,r,i,o,a)})}}class kn{static checkVersion(e){const t=j.CurrentMajorVersion,n=j.CurrentMinorVersion,s=j.parseHeader(e);if(s.versionMajor===t&&s.versionMinor>=n||s.versionMajor>t)return!0;throw new Error(`KSplat version not supported: v${s.versionMajor}.${s.versionMinor}. Minimum required: v${t}.${n}`)}static loadFromURL(e,t,n,s,r){let i,o,a,c,d=!1,u=!1,f,h=[],g=!1,p=!1,m=0,A=0,y=0,v=!1,x=!1,w=!1,T=[];const C=Nr(),E=()=>{!d&&!u&&m>=j.HeaderSizeBytes&&(u=!0,new Blob(T).arrayBuffer().then(k=>{a=new ArrayBuffer(j.HeaderSizeBytes),new Uint8Array(a).set(new Uint8Array(k,0,j.HeaderSizeBytes)),kn.checkVersion(a),u=!1,d=!0,c=j.parseHeader(a),window.setTimeout(()=>{B()},1)}))};let I=0;const P=()=>{I===0&&(I++,window.setTimeout(()=>{I--,M()},1))},B=()=>{const _=()=>{p=!0,new Blob(T).arrayBuffer().then(G=>{p=!1,g=!0,f=new ArrayBuffer(c.maxSectionCount*j.SectionHeaderSizeBytes),new Uint8Array(f).set(new Uint8Array(G,j.HeaderSizeBytes,c.maxSectionCount*j.SectionHeaderSizeBytes)),h=j.parseSectionHeaders(c,f,0,!1);let O=0;for(let U=0;U<c.maxSectionCount;U++)O+=h[U].storageSizeBytes;const $=j.HeaderSizeBytes+c.maxSectionCount*j.SectionHeaderSizeBytes+O;if(!i){i=new ArrayBuffer($);let U=0;for(let Z=0;Z<T.length;Z++){const V=T[Z];new Uint8Array(i,U,V.byteLength).set(new Uint8Array(V)),U+=V.byteLength}}y=j.HeaderSizeBytes+j.SectionHeaderSizeBytes*c.maxSectionCount;for(let U=0;U<=h.length&&U<c.maxSectionCount;U++)y+=h[U].storageSizeBytes;P()})};!p&&!g&&d&&m>=j.HeaderSizeBytes+j.SectionHeaderSizeBytes*c.maxSectionCount&&_()},M=()=>{if(w)return;w=!0;const _=()=>{if(w=!1,g){if(x)return;if(v=m>=y,m-A>Ee.ProgressiveLoadSectionSize||v){A+=Ee.ProgressiveLoadSectionSize,x=A>=y,o||(o=new j(i,!1));const G=j.HeaderSizeBytes+j.SectionHeaderSizeBytes*c.maxSectionCount;let O=0,$=0,U=0;for(let z=0;z<c.maxSectionCount;z++){const ne=h[z],te=O+ne.partiallyFilledBucketCount*4+ne.bucketStorageSizeBytes*ne.bucketCount,J=G+te;if(A>=J){$++;const ue=A-J,fe=j.CompressionLevels[c.compressionLevel].SphericalHarmonicsDegrees[ne.sphericalHarmonicsDegree].BytesPerSplat;let q=Math.floor(ue/fe);q=Math.min(q,ne.maxSplatCount),U+=q,o.updateLoadedCounts($,U),o.updateSectionLoadedCounts(z,q)}else break;O+=ne.storageSizeBytes}s(o,x);const Z=A/y*100,V=Z.toFixed(2)+"%";t&&t(Z,V,ze.Downloading),x?C.resolve(o):M()}}};window.setTimeout(_,Ee.ProgressiveLoadSectionDelayDuration)};return Fs(e,(_,k,G)=>{G&&(T.push(G),i&&new Uint8Array(i,m,G.byteLength).set(new Uint8Array(G)),m+=G.byteLength),n?(E(),B(),M()):t&&t(_,k,ze.Downloading)},!n,r).then(_=>(t&&t(0,"0%",ze.Processing),(n?C.promise:kn.loadFromFileData(_)).then(G=>(t&&t(100,"100%",ze.Done),G))))}static loadFromFileData(e){return ut(()=>(kn.checkVersion(e),new j(e)))}static downloadFile=function(){let e;return function(t,n){const s=new Blob([t.bufferData],{type:"application/octet-stream"});e||(e=document.createElement("a"),document.body.appendChild(e)),e.download=n,e.href=URL.createObjectURL(s),e.click()}}()}const tt={Splat:0,KSplat:1,Ply:2,Spz:3},_o=l=>l.endsWith(".ply")?tt.Ply:l.endsWith(".splat")?tt.Splat:l.endsWith(".ksplat")?tt.KSplat:l.endsWith(".spz")?tt.Spz:tt.Ply,Co={type:"change"},lr={type:"start"},To={type:"end"},as=new Bl,Mo=new Pl,Ff=Math.cos(70*Ae.DEG2RAD);class ls extends Dl{constructor(e,t){super(),this.object=e,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new F,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"KeyA",UP:"KeyW",RIGHT:"KeyD",BOTTOM:"KeyS"},this.mouseButtons={LEFT:Yt.ROTATE,MIDDLE:Yt.DOLLY,RIGHT:Yt.PAN},this.touches={ONE:Zt.ROTATE,TWO:Zt.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return o.phi},this.getAzimuthalAngle=function(){return o.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(H){H.addEventListener("keydown",le),this._domElementKeyEvents=H},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",le),this._domElementKeyEvents=null},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,this.clearDampedRotation(),this.clearDampedPan(),n.object.updateProjectionMatrix(),n.dispatchEvent(Co),n.update(),r=s.NONE},this.clearDampedRotation=function(){a.theta=0,a.phi=0},this.clearDampedPan=function(){d.set(0,0,0)},this.update=function(){const H=new F,ae=new ce().setFromUnitVectors(e.up,new F(0,1,0)),be=ae.clone().invert(),Re=new F,Be=new ce,mt=new F,lt=2*Math.PI;return function(){ae.setFromUnitVectors(e.up,new F(0,1,0)),be.copy(ae).invert();const Xt=n.object.position;H.copy(Xt).sub(n.target),H.applyQuaternion(ae),o.setFromVector3(H),n.autoRotate&&r===s.NONE&&B(I()),n.enableDamping?(o.theta+=a.theta*n.dampingFactor,o.phi+=a.phi*n.dampingFactor):(o.theta+=a.theta,o.phi+=a.phi);let $e=n.minAzimuthAngle,Qe=n.maxAzimuthAngle;isFinite($e)&&isFinite(Qe)&&($e<-Math.PI?$e+=lt:$e>Math.PI&&($e-=lt),Qe<-Math.PI?Qe+=lt:Qe>Math.PI&&(Qe-=lt),$e<=Qe?o.theta=Math.max($e,Math.min(Qe,o.theta)):o.theta=o.theta>($e+Qe)/2?Math.max($e,o.theta):Math.min(Qe,o.theta)),o.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,o.phi)),o.makeSafe(),n.enableDamping===!0?n.target.addScaledVector(d,n.dampingFactor):n.target.add(d),n.zoomToCursor&&T||n.object.isOrthographicCamera?o.radius=U(o.radius):o.radius=U(o.radius*c),H.setFromSpherical(o),H.applyQuaternion(be),Xt.copy(n.target).add(H),n.object.lookAt(n.target),n.enableDamping===!0?(a.theta*=1-n.dampingFactor,a.phi*=1-n.dampingFactor,d.multiplyScalar(1-n.dampingFactor)):(a.set(0,0,0),d.set(0,0,0));let it=!1;if(n.zoomToCursor&&T){let yt=null;if(n.object.isPerspectiveCamera){const Dt=H.length();yt=U(Dt*c);const Kt=Dt-yt;n.object.position.addScaledVector(x,Kt),n.object.updateMatrixWorld()}else if(n.object.isOrthographicCamera){const Dt=new F(w.x,w.y,0);Dt.unproject(n.object),n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/c)),n.object.updateProjectionMatrix(),it=!0;const Kt=new F(w.x,w.y,0);Kt.unproject(n.object),n.object.position.sub(Kt).add(Dt),n.object.updateMatrixWorld(),yt=H.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),n.zoomToCursor=!1;yt!==null&&(this.screenSpacePanning?n.target.set(0,0,-1).transformDirection(n.object.matrix).multiplyScalar(yt).add(n.object.position):(as.origin.copy(n.object.position),as.direction.set(0,0,-1).transformDirection(n.object.matrix),Math.abs(n.object.up.dot(as.direction))<Ff?e.lookAt(n.target):(Mo.setFromNormalAndCoplanarPoint(n.object.up,n.target),as.intersectPlane(Mo,n.target))))}else n.object.isOrthographicCamera&&(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/c)),n.object.updateProjectionMatrix(),it=!0);return c=1,T=!1,it||Re.distanceToSquared(n.object.position)>i||8*(1-Be.dot(n.object.quaternion))>i||mt.distanceToSquared(n.target)>0?(n.dispatchEvent(Co),Re.copy(n.object.position),Be.copy(n.object.quaternion),mt.copy(n.target),it=!1,!0):!1}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",Ce),n.domElement.removeEventListener("pointerdown",b),n.domElement.removeEventListener("pointercancel",K),n.domElement.removeEventListener("wheel",se),n.domElement.removeEventListener("pointermove",L),n.domElement.removeEventListener("pointerup",K),n._domElementKeyEvents!==null&&(n._domElementKeyEvents.removeEventListener("keydown",le),n._domElementKeyEvents=null)};const n=this,s={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let r=s.NONE;const i=1e-6,o=new ui,a=new ui;let c=1;const d=new F,u=new ge,f=new ge,h=new ge,g=new ge,p=new ge,m=new ge,A=new ge,y=new ge,v=new ge,x=new F,w=new ge;let T=!1;const C=[],E={};function I(){return 2*Math.PI/60/60*n.autoRotateSpeed}function P(){return Math.pow(.95,n.zoomSpeed)}function B(H){a.theta-=H}function M(H){a.phi-=H}const D=function(){const H=new F;return function(be,Re){H.setFromMatrixColumn(Re,0),H.multiplyScalar(-be),d.add(H)}}(),_=function(){const H=new F;return function(be,Re){n.screenSpacePanning===!0?H.setFromMatrixColumn(Re,1):(H.setFromMatrixColumn(Re,0),H.crossVectors(n.object.up,H)),H.multiplyScalar(be),d.add(H)}}(),k=function(){const H=new F;return function(be,Re){const Be=n.domElement;if(n.object.isPerspectiveCamera){const mt=n.object.position;H.copy(mt).sub(n.target);let lt=H.length();lt*=Math.tan(n.object.fov/2*Math.PI/180),D(2*be*lt/Be.clientHeight,n.object.matrix),_(2*Re*lt/Be.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(D(be*(n.object.right-n.object.left)/n.object.zoom/Be.clientWidth,n.object.matrix),_(Re*(n.object.top-n.object.bottom)/n.object.zoom/Be.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function G(H){n.object.isPerspectiveCamera||n.object.isOrthographicCamera?c/=H:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function O(H){n.object.isPerspectiveCamera||n.object.isOrthographicCamera?c*=H:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function $(H){if(!n.zoomToCursor)return;T=!0;const ae=n.domElement.getBoundingClientRect(),be=H.clientX-ae.left,Re=H.clientY-ae.top,Be=ae.width,mt=ae.height;w.x=be/Be*2-1,w.y=-(Re/mt)*2+1,x.set(w.x,w.y,1).unproject(e).sub(e.position).normalize()}function U(H){return Math.max(n.minDistance,Math.min(n.maxDistance,H))}function Z(H){u.set(H.clientX,H.clientY)}function V(H){$(H),A.set(H.clientX,H.clientY)}function z(H){g.set(H.clientX,H.clientY)}function ne(H){f.set(H.clientX,H.clientY),h.subVectors(f,u).multiplyScalar(n.rotateSpeed);const ae=n.domElement;B(2*Math.PI*h.x/ae.clientHeight),M(2*Math.PI*h.y/ae.clientHeight),u.copy(f),n.update()}function te(H){y.set(H.clientX,H.clientY),v.subVectors(y,A),v.y>0?G(P()):v.y<0&&O(P()),A.copy(y),n.update()}function J(H){p.set(H.clientX,H.clientY),m.subVectors(p,g).multiplyScalar(n.panSpeed),k(m.x,m.y),g.copy(p),n.update()}function ue(H){$(H),H.deltaY<0?O(P()):H.deltaY>0&&G(P()),n.update()}function me(H){let ae=!1;switch(H.code){case n.keys.UP:H.ctrlKey||H.metaKey||H.shiftKey?M(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):k(0,n.keyPanSpeed),ae=!0;break;case n.keys.BOTTOM:H.ctrlKey||H.metaKey||H.shiftKey?M(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):k(0,-n.keyPanSpeed),ae=!0;break;case n.keys.LEFT:H.ctrlKey||H.metaKey||H.shiftKey?B(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):k(n.keyPanSpeed,0),ae=!0;break;case n.keys.RIGHT:H.ctrlKey||H.metaKey||H.shiftKey?B(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):k(-n.keyPanSpeed,0),ae=!0;break}ae&&(H.preventDefault(),n.update())}function de(){if(C.length===1)u.set(C[0].pageX,C[0].pageY);else{const H=.5*(C[0].pageX+C[1].pageX),ae=.5*(C[0].pageY+C[1].pageY);u.set(H,ae)}}function fe(){if(C.length===1)g.set(C[0].pageX,C[0].pageY);else{const H=.5*(C[0].pageX+C[1].pageX),ae=.5*(C[0].pageY+C[1].pageY);g.set(H,ae)}}function q(){const H=C[0].pageX-C[1].pageX,ae=C[0].pageY-C[1].pageY,be=Math.sqrt(H*H+ae*ae);A.set(0,be)}function X(){n.enableZoom&&q(),n.enablePan&&fe()}function ie(){n.enableZoom&&q(),n.enableRotate&&de()}function ee(H){if(C.length==1)f.set(H.pageX,H.pageY);else{const be=Ye(H),Re=.5*(H.pageX+be.x),Be=.5*(H.pageY+be.y);f.set(Re,Be)}h.subVectors(f,u).multiplyScalar(n.rotateSpeed);const ae=n.domElement;B(2*Math.PI*h.x/ae.clientHeight),M(2*Math.PI*h.y/ae.clientHeight),u.copy(f)}function S(H){if(C.length===1)p.set(H.pageX,H.pageY);else{const ae=Ye(H),be=.5*(H.pageX+ae.x),Re=.5*(H.pageY+ae.y);p.set(be,Re)}m.subVectors(p,g).multiplyScalar(n.panSpeed),k(m.x,m.y),g.copy(p)}function N(H){const ae=Ye(H),be=H.pageX-ae.x,Re=H.pageY-ae.y,Be=Math.sqrt(be*be+Re*Re);y.set(0,Be),v.set(0,Math.pow(y.y/A.y,n.zoomSpeed)),G(v.y),A.copy(y)}function W(H){n.enableZoom&&N(H),n.enablePan&&S(H)}function R(H){n.enableZoom&&N(H),n.enableRotate&&ee(H)}function b(H){n.enabled!==!1&&(C.length===0&&(n.domElement.setPointerCapture(H.pointerId),n.domElement.addEventListener("pointermove",L),n.domElement.addEventListener("pointerup",K)),ve(H),H.pointerType==="touch"?re(H):Y(H))}function L(H){n.enabled!==!1&&(H.pointerType==="touch"?pe(H):Q(H))}function K(H){Xe(H),C.length===0&&(n.domElement.releasePointerCapture(H.pointerId),n.domElement.removeEventListener("pointermove",L),n.domElement.removeEventListener("pointerup",K)),n.dispatchEvent(To),r=s.NONE}function Y(H){let ae;switch(H.button){case 0:ae=n.mouseButtons.LEFT;break;case 1:ae=n.mouseButtons.MIDDLE;break;case 2:ae=n.mouseButtons.RIGHT;break;default:ae=-1}switch(ae){case Yt.DOLLY:if(n.enableZoom===!1)return;V(H),r=s.DOLLY;break;case Yt.ROTATE:if(H.ctrlKey||H.metaKey||H.shiftKey){if(n.enablePan===!1)return;z(H),r=s.PAN}else{if(n.enableRotate===!1)return;Z(H),r=s.ROTATE}break;case Yt.PAN:if(H.ctrlKey||H.metaKey||H.shiftKey){if(n.enableRotate===!1)return;Z(H),r=s.ROTATE}else{if(n.enablePan===!1)return;z(H),r=s.PAN}break;default:r=s.NONE}r!==s.NONE&&n.dispatchEvent(lr)}function Q(H){switch(r){case s.ROTATE:if(n.enableRotate===!1)return;ne(H);break;case s.DOLLY:if(n.enableZoom===!1)return;te(H);break;case s.PAN:if(n.enablePan===!1)return;J(H);break}}function se(H){n.enabled===!1||n.enableZoom===!1||r!==s.NONE||(H.preventDefault(),n.dispatchEvent(lr),ue(H),n.dispatchEvent(To))}function le(H){n.enabled===!1||n.enablePan===!1||me(H)}function re(H){switch(Ke(H),C.length){case 1:switch(n.touches.ONE){case Zt.ROTATE:if(n.enableRotate===!1)return;de(),r=s.TOUCH_ROTATE;break;case Zt.PAN:if(n.enablePan===!1)return;fe(),r=s.TOUCH_PAN;break;default:r=s.NONE}break;case 2:switch(n.touches.TWO){case Zt.DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;X(),r=s.TOUCH_DOLLY_PAN;break;case Zt.DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;ie(),r=s.TOUCH_DOLLY_ROTATE;break;default:r=s.NONE}break;default:r=s.NONE}r!==s.NONE&&n.dispatchEvent(lr)}function pe(H){switch(Ke(H),r){case s.TOUCH_ROTATE:if(n.enableRotate===!1)return;ee(H),n.update();break;case s.TOUCH_PAN:if(n.enablePan===!1)return;S(H),n.update();break;case s.TOUCH_DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;W(H),n.update();break;case s.TOUCH_DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;R(H),n.update();break;default:r=s.NONE}}function Ce(H){n.enabled!==!1&&H.preventDefault()}function ve(H){C.push(H)}function Xe(H){delete E[H.pointerId];for(let ae=0;ae<C.length;ae++)if(C[ae].pointerId==H.pointerId){C.splice(ae,1);return}}function Ke(H){let ae=E[H.pointerId];ae===void 0&&(ae=new ge,E[H.pointerId]=ae),ae.set(H.pageX,H.pageY)}function Ye(H){const ae=H.pointerId===C[0].pointerId?C[1]:C[0];return E[ae.pointerId]}n.domElement.addEventListener("contextmenu",Ce),n.domElement.addEventListener("pointerdown",b),n.domElement.addEventListener("pointercancel",K),n.domElement.addEventListener("wheel",se,{passive:!1}),this.update()}}const Lf=(l,e,t,n,s)=>{const r=performance.now();let i=l.style.display==="none"?0:parseFloat(l.style.opacity);isNaN(i)&&(i=1);const o=window.setInterval(()=>{const c=performance.now()-r;let d=Math.min(c/n,1);d>.999&&(d=1);let u;e?(u=(1-d)*i,u<1e-4&&(u=0)):u=(1-i)*d+i,u>0?(l.style.display=t,l.style.opacity=u):l.style.display="none",d>=1&&(s&&s(),window.clearInterval(o))},16);return o},kf=500;class $r{static elementIDGen=0;constructor(e,t){this.taskIDGen=0,this.elementID=$r.elementIDGen++,this.tasks=[],this.message=e||"Loading...",this.container=t||document.body,this.spinnerContainerOuter=document.createElement("div"),this.spinnerContainerOuter.className=`spinnerOuterContainer${this.elementID}`,this.spinnerContainerOuter.style.display="none",this.spinnerContainerPrimary=document.createElement("div"),this.spinnerContainerPrimary.className=`spinnerContainerPrimary${this.elementID}`,this.spinnerPrimary=document.createElement("div"),this.spinnerPrimary.classList.add(`spinner${this.elementID}`,`spinnerPrimary${this.elementID}`),this.messageContainerPrimary=document.createElement("div"),this.messageContainerPrimary.classList.add(`messageContainer${this.elementID}`,`messageContainerPrimary${this.elementID}`),this.messageContainerPrimary.innerHTML=this.message,this.spinnerContainerMin=document.createElement("div"),this.spinnerContainerMin.className=`spinnerContainerMin${this.elementID}`,this.spinnerMin=document.createElement("div"),this.spinnerMin.classList.add(`spinner${this.elementID}`,`spinnerMin${this.elementID}`),this.messageContainerMin=document.createElement("div"),this.messageContainerMin.classList.add(`messageContainer${this.elementID}`,`messageContainerMin${this.elementID}`),this.messageContainerMin.innerHTML=this.message,this.spinnerContainerPrimary.appendChild(this.spinnerPrimary),this.spinnerContainerPrimary.appendChild(this.messageContainerPrimary),this.spinnerContainerOuter.appendChild(this.spinnerContainerPrimary),this.spinnerContainerMin.appendChild(this.spinnerMin),this.spinnerContainerMin.appendChild(this.messageContainerMin),this.spinnerContainerOuter.appendChild(this.spinnerContainerMin);const n=document.createElement("style");n.innerHTML=`

            .spinnerOuterContainer${this.elementID} {
                width: 100%;
                height: 100%;
                margin: 0;
                top: 0;
                left: 0;
                position: absolute;
                pointer-events: none;
            }

            .messageContainer${this.elementID} {
                height: 20px;
                font-family: arial;
                font-size: 12pt;
                color: #ffffff;
                text-align: center;
                vertical-align: middle;
            }

            .spinner${this.elementID} {
                padding: 15px;
                background: #07e8d6;
                z-index:99999;
            
                aspect-ratio: 1;
                border-radius: 50%;
                --_m: 
                    conic-gradient(#0000,#000),
                    linear-gradient(#000 0 0) content-box;
                -webkit-mask: var(--_m);
                    mask: var(--_m);
                -webkit-mask-composite: source-out;
                    mask-composite: subtract;
                box-sizing: border-box;
                animation: load 1s linear infinite;
            }

            .spinnerContainerPrimary${this.elementID} {
                z-index:99999;
                background-color: rgba(128, 128, 128, 0.75);
                border: #666666 1px solid;
                border-radius: 5px;
                padding-top: 20px;
                padding-bottom: 10px;
                margin: 0;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-80px, -80px);
                width: 180px;
                pointer-events: auto;
            }

            .spinnerPrimary${this.elementID} {
                width: 120px;
                margin-left: 30px;
            }

            .messageContainerPrimary${this.elementID} {
                padding-top: 15px;
            }

            .spinnerContainerMin${this.elementID} {
                z-index:99999;
                background-color: rgba(128, 128, 128, 0.75);
                border: #666666 1px solid;
                border-radius: 5px;
                padding-top: 20px;
                padding-bottom: 15px;
                margin: 0;
                position: absolute;
                bottom: 50px;
                left: 50%;
                transform: translate(-50%, 0);
                display: flex;
                flex-direction: left;
                pointer-events: auto;
                min-width: 250px;
            }

            .messageContainerMin${this.elementID} {
                margin-right: 15px;
            }

            .spinnerMin${this.elementID} {
                width: 50px;
                height: 50px;
                margin-left: 15px;
                margin-right: 25px;
            }

            .messageContainerMin${this.elementID} {
                padding-top: 15px;
            }
            
            @keyframes load {
                to{transform: rotate(1turn)}
            }

        `,this.spinnerContainerOuter.appendChild(n),this.container.appendChild(this.spinnerContainerOuter),this.setMinimized(!1,!0),this.fadeTransitions=[]}addTask(e){const t={message:e,id:this.taskIDGen++};return this.tasks.push(t),this.update(),t.id}removeTask(e){let t=0;for(let n of this.tasks){if(n.id===e){this.tasks.splice(t,1);break}t++}this.update()}removeAllTasks(){this.tasks=[],this.update()}setMessageForTask(e,t){for(let n of this.tasks)if(n.id===e){n.message=t;break}this.update()}update(){this.tasks.length>0?(this.show(),this.setMessage(this.tasks[this.tasks.length-1].message)):this.hide()}show(){this.spinnerContainerOuter.style.display="block",this.visible=!0}hide(){this.spinnerContainerOuter.style.display="none",this.visible=!1}setContainer(e){this.container&&this.spinnerContainerOuter.parentElement===this.container&&this.container.removeChild(this.spinnerContainerOuter),e&&(this.container=e,this.container.appendChild(this.spinnerContainerOuter),this.spinnerContainerOuter.style.zIndex=this.container.style.zIndex+1)}setMinimized(e,t){const n=(s,r,i,o,a)=>{i?s.style.display=r?o:"none":this.fadeTransitions[a]=Lf(s,!r,o,kf,()=>{this.fadeTransitions[a]=null})};n(this.spinnerContainerPrimary,!e,t,"block",0),n(this.spinnerContainerMin,e,t,"flex",1),this.minimized=e}setMessage(e){this.messageContainerPrimary.innerHTML=e,this.messageContainerMin.innerHTML=e}}class Of{constructor(e){this.idGen=0,this.tasks=[],this.container=e||document.body,this.progressBarContainerOuter=document.createElement("div"),this.progressBarContainerOuter.className="progressBarOuterContainer",this.progressBarContainerOuter.style.display="none",this.progressBarBox=document.createElement("div"),this.progressBarBox.className="progressBarBox",this.progressBarBackground=document.createElement("div"),this.progressBarBackground.className="progressBarBackground",this.progressBar=document.createElement("div"),this.progressBar.className="progressBar",this.progressBarBackground.appendChild(this.progressBar),this.progressBarBox.appendChild(this.progressBarBackground),this.progressBarContainerOuter.appendChild(this.progressBarBox);const t=document.createElement("style");t.innerHTML=`

            .progressBarOuterContainer {
                width: 100%;
                height: 100%;
                margin: 0;
                top: 0;
                left: 0;
                position: absolute;
                pointer-events: none;
            }

            .progressBarBox {
                z-index:99999;
                padding: 7px 9px 5px 7px;
                background-color: rgba(190, 190, 190, 0.75);
                border: #555555 1px solid;
                border-radius: 15px;
                margin: 0;
                position: absolute;
                bottom: 50px;
                left: 50%;
                transform: translate(-50%, 0);
                width: 180px;
                height: 30px;
                pointer-events: auto;
            }

            .progressBarBackground {
                width: 100%;
                height: 25px;
                border-radius:10px;
                background-color: rgba(128, 128, 128, 0.75);
                border: #444444 1px solid;
                box-shadow: inset 0 0 10px #333333;
            }

            .progressBar {
                height: 25px;
                width: 0px;
                border-radius:10px;
                background-color: rgba(0, 200, 0, 0.75);
                box-shadow: inset 0 0 10px #003300;
            }

        `,this.progressBarContainerOuter.appendChild(t),this.container.appendChild(this.progressBarContainerOuter)}show(){this.progressBarContainerOuter.style.display="block"}hide(){this.progressBarContainerOuter.style.display="none"}setProgress(e){this.progressBar.style.width=e+"%"}setContainer(e){this.container&&this.progressBarContainerOuter.parentElement===this.container&&this.container.removeChild(this.progressBarContainerOuter),e&&(this.container=e,this.container.appendChild(this.progressBarContainerOuter),this.progressBarContainerOuter.style.zIndex=this.container.style.zIndex+1)}}class Uf{constructor(e){this.container=e||document.body,this.infoCells={};const t=[["Camera position","cameraPosition"],["Camera look-at","cameraLookAt"],["Camera up","cameraUp"],["Camera mode","orthographicCamera"],["Cursor position","cursorPosition"],["FPS","fps"],["Rendering:","renderSplatCount"],["Sort time","sortTime"],["Render window","renderWindow"],["Focal adjustment","focalAdjustment"],["Splat scale","splatScale"],["Point cloud mode","pointCloudMode"]];this.infoPanelContainer=document.createElement("div");const n=document.createElement("style");n.innerHTML=`

            .infoPanel {
                width: 430px;
                padding: 10px;
                background-color: rgba(50, 50, 50, 0.85);
                border: #555555 2px solid;
                color: #dddddd;
                border-radius: 10px;
                z-index: 9999;
                font-family: arial;
                font-size: 11pt;
                text-align: left;
                margin: 0;
                top: 10px;
                left:10px;
                position: absolute;
                pointer-events: auto;
            }

            .info-panel-cell {
                margin-bottom: 5px;
                padding-bottom: 2px;
            }

            .label-cell {
                font-weight: bold;
                font-size: 12pt;
                width: 140px;
            }

        `,this.infoPanelContainer.append(n),this.infoPanel=document.createElement("div"),this.infoPanel.className="infoPanel";const s=document.createElement("div");s.style.display="table";for(let r of t){const i=document.createElement("div");i.style.display="table-row",i.className="info-panel-row";const o=document.createElement("div");o.style.display="table-cell",o.innerHTML=`${r[0]}: `,o.classList.add("info-panel-cell","label-cell");const a=document.createElement("div");a.style.display="table-cell",a.style.width="10px",a.innerHTML=" ",a.className="info-panel-cell";const c=document.createElement("div");c.style.display="table-cell",c.innerHTML="",c.className="info-panel-cell",this.infoCells[r[1]]=c,i.appendChild(o),i.appendChild(a),i.appendChild(c),s.appendChild(i)}this.infoPanel.appendChild(s),this.infoPanelContainer.append(this.infoPanel),this.infoPanelContainer.style.display="none",this.container.appendChild(this.infoPanelContainer),this.visible=!1}update=function(e,t,n,s,r,i,o,a,c,d,u,f,h,g){const p=`${t.x.toFixed(5)}, ${t.y.toFixed(5)}, ${t.z.toFixed(5)}`;if(this.infoCells.cameraPosition.innerHTML!==p&&(this.infoCells.cameraPosition.innerHTML=p),n){const A=n,y=`${A.x.toFixed(5)}, ${A.y.toFixed(5)}, ${A.z.toFixed(5)}`;this.infoCells.cameraLookAt.innerHTML!==y&&(this.infoCells.cameraLookAt.innerHTML=y)}const m=`${s.x.toFixed(5)}, ${s.y.toFixed(5)}, ${s.z.toFixed(5)}`;if(this.infoCells.cameraUp.innerHTML!==m&&(this.infoCells.cameraUp.innerHTML=m),this.infoCells.orthographicCamera.innerHTML=r?"Orthographic":"Perspective",i){const A=i,y=`${A.x.toFixed(5)}, ${A.y.toFixed(5)}, ${A.z.toFixed(5)}`;this.infoCells.cursorPosition.innerHTML=y}else this.infoCells.cursorPosition.innerHTML="N/A";this.infoCells.fps.innerHTML=o,this.infoCells.renderWindow.innerHTML=`${e.x} x ${e.y}`,this.infoCells.renderSplatCount.innerHTML=`${c} splats out of ${a} (${d.toFixed(2)}%)`,this.infoCells.sortTime.innerHTML=`${u.toFixed(3)} ms`,this.infoCells.focalAdjustment.innerHTML=`${f.toFixed(3)}`,this.infoCells.splatScale.innerHTML=`${h.toFixed(3)}`,this.infoCells.pointCloudMode.innerHTML=`${g}`};setContainer(e){this.container&&this.infoPanelContainer.parentElement===this.container&&this.container.removeChild(this.infoPanelContainer),e&&(this.container=e,this.container.appendChild(this.infoPanelContainer),this.infoPanelContainer.style.zIndex=this.container.style.zIndex+1)}show(){this.infoPanelContainer.style.display="block",this.visible=!0}hide(){this.infoPanelContainer.style.display="none",this.visible=!1}}const Eo=new F;class Nf extends Ze{constructor(e=new F(0,0,1),t=new F(0,0,0),n=1,s=.1,r=16776960,i=n*.2,o=i*.2){super(),this.type="ArrowHelper";const a=new fi(s,s,n,32);a.translate(0,n/2,0);const c=new fi(0,o,i,32);c.translate(0,n,0),this.position.copy(t),this.line=new Oe(a,new rt({color:r,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Oe(c,new rt({color:r,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{Eo.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(Eo,t)}}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class On{constructor(e){this.threeScene=e,this.splatRenderTarget=null,this.renderTargetCopyQuad=null,this.renderTargetCopyCamera=null,this.meshCursor=null,this.focusMarker=null,this.controlPlane=null,this.debugRoot=null,this.secondaryDebugRoot=null}updateSplatRenderTargetForRenderDimensions(e,t){this.destroySplatRendertarget(),this.splatRenderTarget=new Fl(e,t,{format:Ct,stencilBuffer:!1,depthBuffer:!0}),this.splatRenderTarget.depthTexture=new Ll(e,t),this.splatRenderTarget.depthTexture.format=kl,this.splatRenderTarget.depthTexture.type=Pn}destroySplatRendertarget(){this.splatRenderTarget&&(this.splatRenderTarget=null)}setupRenderTargetCopyObjects(){const e={sourceColorTexture:{type:"t",value:null},sourceDepthTexture:{type:"t",value:null}},t=new mn({vertexShader:`
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4( position.xy, 0.0, 1.0 );    
                }
            `,fragmentShader:`
                #include <common>
                #include <packing>
                varying vec2 vUv;
                uniform sampler2D sourceColorTexture;
                uniform sampler2D sourceDepthTexture;
                void main() {
                    vec4 color = texture2D(sourceColorTexture, vUv);
                    float fragDepth = texture2D(sourceDepthTexture, vUv).x;
                    gl_FragDepth = fragDepth;
                    gl_FragColor = vec4(color.rgb, color.a * 2.0);
              }
            `,uniforms:e,depthWrite:!1,depthTest:!1,transparent:!0,blending:Ol,blendSrc:di,blendSrcAlpha:di,blendDst:hi,blendDstAlpha:hi});t.extensions.fragDepth=!0,this.renderTargetCopyQuad=new Oe(new _s(2,2),t),this.renderTargetCopyCamera=new Lr(-1,1,1,-1,0,1)}destroyRenderTargetCopyObjects(){this.renderTargetCopyQuad&&(dn(this.renderTargetCopyQuad),this.renderTargetCopyQuad=null)}setupMeshCursor(){if(!this.meshCursor){const e=new Ul(.5,1.5,32),t=new rt({color:16777215}),n=new Oe(e,t);n.rotation.set(0,0,Math.PI),n.position.set(0,1,0);const s=new Oe(e,t);s.position.set(0,-1,0);const r=new Oe(e,t);r.rotation.set(0,0,Math.PI/2),r.position.set(1,0,0);const i=new Oe(e,t);i.rotation.set(0,0,-Math.PI/2),i.position.set(-1,0,0),this.meshCursor=new Ze,this.meshCursor.add(n),this.meshCursor.add(s),this.meshCursor.add(r),this.meshCursor.add(i),this.meshCursor.scale.set(.1,.1,.1),this.threeScene.add(this.meshCursor),this.meshCursor.visible=!1}}destroyMeshCursor(){this.meshCursor&&(dn(this.meshCursor),this.threeScene.remove(this.meshCursor),this.meshCursor=null)}setMeshCursorVisibility(e){this.meshCursor.visible=e}getMeschCursorVisibility(){return this.meshCursor.visible}setMeshCursorPosition(e){this.meshCursor.position.copy(e)}positionAndOrientMeshCursor(e,t){this.meshCursor.position.copy(e),this.meshCursor.up.copy(t.up),this.meshCursor.lookAt(t.position)}setupFocusMarker(){if(!this.focusMarker){const e=new vr(.5,32,32),t=On.buildFocusMarkerMaterial();t.depthTest=!1,t.depthWrite=!1,t.transparent=!0,this.focusMarker=new Oe(e,t)}}destroyFocusMarker(){this.focusMarker&&(dn(this.focusMarker),this.focusMarker=null)}updateFocusMarker=function(){const e=new F,t=new he,n=new F;return function(s,r,i){t.copy(r.matrixWorld).invert(),e.copy(s).applyMatrix4(t),e.normalize().multiplyScalar(10),e.applyMatrix4(r.matrixWorld),n.copy(r.position).sub(s);const o=n.length();this.focusMarker.position.copy(s),this.focusMarker.scale.set(o,o,o),this.focusMarker.material.uniforms.realFocusPosition.value.copy(s),this.focusMarker.material.uniforms.viewport.value.copy(i),this.focusMarker.material.uniformsNeedUpdate=!0}}();setFocusMarkerVisibility(e){this.focusMarker.visible=e}setFocusMarkerOpacity(e){this.focusMarker.material.uniforms.opacity.value=e,this.focusMarker.material.uniformsNeedUpdate=!0}getFocusMarkerOpacity(){return this.focusMarker.material.uniforms.opacity.value}setupControlPlane(){if(!this.controlPlane){const e=new _s(1,1);e.rotateX(-Math.PI/2);const t=new rt({color:16777215});t.transparent=!0,t.opacity=.6,t.depthTest=!1,t.depthWrite=!1,t.side=Sn;const n=new Oe(e,t),s=new F(0,1,0);s.normalize();const r=new F(0,0,0),i=.5,o=.01,a=56576,c=new Nf(s,r,i,o,a,.1,.03);this.controlPlane=new Ze,this.controlPlane.add(n),this.controlPlane.add(c)}}destroyControlPlane(){this.controlPlane&&(dn(this.controlPlane),this.controlPlane=null)}setControlPlaneVisibility(e){this.controlPlane.visible=e}positionAndOrientControlPlane=function(){const e=new ce,t=new F(0,1,0);return function(n,s){e.setFromUnitVectors(t,s),this.controlPlane.position.copy(n),this.controlPlane.quaternion.copy(e)}}();addDebugMeshes(){this.debugRoot=this.createDebugMeshes(),this.secondaryDebugRoot=this.createSecondaryDebugMeshes(),this.threeScene.add(this.debugRoot),this.threeScene.add(this.secondaryDebugRoot)}destroyDebugMeshes(){for(let e of[this.debugRoot,this.secondaryDebugRoot])e&&(dn(e),this.threeScene.remove(e));this.debugRoot=null,this.secondaryDebugRoot=null}createDebugMeshes(e){const t=new vr(1,32,32),n=new Ze,s=(r,i)=>{let o=new Oe(t,On.buildDebugMaterial(r));o.renderOrder=e,n.add(o),o.position.fromArray(i)};return s(16711680,[-50,0,0]),s(16711680,[50,0,0]),s(65280,[0,0,-50]),s(65280,[0,0,50]),s(16755200,[5,0,5]),n}createSecondaryDebugMeshes(e){const t=new Nl(3,3,3),n=new Ze;let s=12303291;const r=o=>{let a=new Oe(t,On.buildDebugMaterial(s));a.renderOrder=e,n.add(a),a.position.fromArray(o)};let i=10;return r([-i,0,-i]),r([-i,0,i]),r([i,0,-i]),r([i,0,i]),n}static buildDebugMaterial(e){const t=`
            #include <common>
            varying float ndcDepth;

            void main() {
                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);
                ndcDepth = gl_Position.z / gl_Position.w;
                gl_Position.x = gl_Position.x / gl_Position.w;
                gl_Position.y = gl_Position.y / gl_Position.w;
                gl_Position.z = 0.0;
                gl_Position.w = 1.0;
    
            }
        `,n=`
            #include <common>
            uniform vec3 color;
            varying float ndcDepth;
            void main() {
                gl_FragDepth = (ndcDepth + 1.0) / 2.0;
                gl_FragColor = vec4(color.rgb, 0.0);
            }
        `,s={color:{type:"v3",value:new Se(e)}},r=new mn({uniforms:s,vertexShader:t,fragmentShader:n,transparent:!1,depthTest:!0,depthWrite:!0,side:Ss});return r.extensions.fragDepth=!0,r}static buildFocusMarkerMaterial(e){const t=`
            #include <common>

            uniform vec2 viewport;
            uniform vec3 realFocusPosition;

            varying vec4 ndcPosition;
            varying vec4 ndcCenter;
            varying vec4 ndcFocusPosition;

            void main() {
                float radius = 0.01;

                vec4 viewPosition = modelViewMatrix * vec4(position.xyz, 1.0);
                vec4 viewCenter = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);

                vec4 viewFocusPosition = modelViewMatrix * vec4(realFocusPosition, 1.0);

                ndcPosition = projectionMatrix * viewPosition;
                ndcPosition = ndcPosition * vec4(1.0 / ndcPosition.w);
                ndcCenter = projectionMatrix * viewCenter;
                ndcCenter = ndcCenter * vec4(1.0 / ndcCenter.w);

                ndcFocusPosition = projectionMatrix * viewFocusPosition;
                ndcFocusPosition = ndcFocusPosition * vec4(1.0 / ndcFocusPosition.w);

                gl_Position = projectionMatrix * viewPosition;

            }
        `,n=`
            #include <common>
            uniform vec3 color;
            uniform vec2 viewport;
            uniform float opacity;

            varying vec4 ndcPosition;
            varying vec4 ndcCenter;
            varying vec4 ndcFocusPosition;

            void main() {
                vec2 screenPosition = vec2(ndcPosition) * viewport;
                vec2 screenCenter = vec2(ndcCenter) * viewport;

                vec2 screenVec = screenPosition - screenCenter;

                float projectedRadius = length(screenVec);

                float lineWidth = 0.0005 * viewport.y;
                float aaRange = 0.0025 * viewport.y;
                float radius = 0.06 * viewport.y;
                float radDiff = abs(projectedRadius - radius) - lineWidth;
                float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); 

                gl_FragColor = vec4(color.rgb, alpha * opacity);
            }
        `,s={color:{type:"v3",value:new Se(e)},realFocusPosition:{type:"v3",value:new F},viewport:{type:"v2",value:new ge},opacity:{value:0}};return new mn({uniforms:s,vertexShader:t,fragmentShader:n,transparent:!0,depthTest:!1,depthWrite:!1,side:Ss})}dispose(){this.destroyMeshCursor(),this.destroyFocusMarker(),this.destroyDebugMeshes(),this.destroyControlPlane(),this.destroyRenderTargetCopyObjects(),this.destroySplatRendertarget()}}const zf=new F(1,0,0),Hf=new F(0,1,0),Vf=new F(0,0,1);class cr{constructor(e=new F,t=new F){this.origin=new F,this.direction=new F,this.setParameters(e,t)}setParameters(e,t){this.origin.copy(e),this.direction.copy(t).normalize()}boxContainsPoint(e,t,n){return!(t.x<e.min.x-n||t.x>e.max.x+n||t.y<e.min.y-n||t.y>e.max.y+n||t.z<e.min.z-n||t.z>e.max.z+n)}intersectBox=function(){const e=new F,t=[],n=[],s=[];return function(r,i){if(n[0]=this.origin.x,n[1]=this.origin.y,n[2]=this.origin.z,s[0]=this.direction.x,s[1]=this.direction.y,s[2]=this.direction.z,this.boxContainsPoint(r,this.origin,1e-4))return i&&(i.origin.copy(this.origin),i.normal.set(0,0,0),i.distance=-1),!0;for(let o=0;o<3;o++){if(s[o]==0)continue;const a=o==0?zf:o==1?Hf:Vf,c=s[o]<0?r.max:r.min;let d=-Math.sign(s[o]);t[0]=o==0?c.x:o==1?c.y:c.z;let u=t[0]-n[o];if(u*d<0){const f=(o+1)%3,h=(o+2)%3;if(t[2]=s[f]/s[o]*u+n[f],t[1]=s[h]/s[o]*u+n[h],e.set(t[o],t[h],t[f]),this.boxContainsPoint(r,e,1e-4))return i&&(i.origin.copy(e),i.normal.copy(a).multiplyScalar(d),i.distance=e.sub(this.origin).length()),!0}}return!1}}();intersectSphere=function(){const e=new F;return function(t,n,s){e.copy(t).sub(this.origin);const r=e.dot(this.direction),i=r*r,a=e.dot(e)-i,c=n*n;if(a>c)return!1;const d=Math.sqrt(c-a),u=r-d,f=r+d;if(f<0)return!1;let h=u<0?f:u;return s&&(s.origin.copy(this.origin).addScaledVector(this.direction,h),s.normal.copy(s.origin).sub(t).normalize(),s.distance=h),!0}}()}class ei{constructor(){this.origin=new F,this.normal=new F,this.distance=0,this.splatIndex=0}set(e,t,n,s){this.origin.copy(e),this.normal.copy(t),this.distance=n,this.splatIndex=s}clone(){const e=new ei;return e.origin.copy(this.origin),e.normal.copy(this.normal),e.distance=this.distance,e.splatIndex=this.splatIndex,e}}const Bt={ThreeD:0,TwoD:1};class Wf{constructor(e,t,n=!1){this.ray=new cr(e,t),this.raycastAgainstTrueSplatEllipsoid=n}setFromCameraAndScreenPosition=function(){const e=new ge;return function(t,n,s){if(e.x=n.x/s.x*2-1,e.y=(s.y-n.y)/s.y*2-1,t.isPerspectiveCamera)this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t;else if(t.isOrthographicCamera)this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t;else throw new Error("Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type")}}();intersectSplatMesh=function(){const e=new he,t=new he,n=new he,s=new cr,r=new F;return function(i,o=[]){const a=i.getSplatTree();if(a){for(let c=0;c<a.subTrees.length;c++){const d=a.subTrees[c];t.copy(i.matrixWorld),i.dynamicMode&&(i.getSceneTransform(c,n),t.multiply(n)),e.copy(t).invert(),s.origin.copy(this.ray.origin).applyMatrix4(e),s.direction.copy(this.ray.origin).add(this.ray.direction),s.direction.applyMatrix4(e).sub(s.origin).normalize();const u=[];d.rootNode&&this.castRayAtSplatTreeNode(s,a,d.rootNode,u),u.forEach(f=>{f.origin.applyMatrix4(t),f.normal.applyMatrix4(t).normalize(),f.distance=r.copy(f.origin).sub(this.ray.origin).length()}),o.push(...u)}return o.sort((c,d)=>c.distance>d.distance?1:-1),o}}}();castRayAtSplatTreeNode=function(){const e=new zt,t=new F,n=new F,s=new ce,r=new ei,i=1e-7,o=new F(0,0,0),a=new he,c=new he,d=new he,u=new he,f=new he,h=new cr;return function(g,p,m,A=[]){if(g.intersectBox(m.boundingBox)){if(m.data&&m.data.indexes&&m.data.indexes.length>0)for(let y=0;y<m.data.indexes.length;y++){const v=m.data.indexes[y],x=p.splatMesh.getSceneIndexForSplat(v);if(p.splatMesh.getScene(x).visible&&(p.splatMesh.getSplatColor(v,e),p.splatMesh.getSplatCenter(v,t),p.splatMesh.getSplatScaleAndRotation(v,n,s),!(n.x<=i||n.y<=i||p.splatMesh.splatRenderMode===Bt.ThreeD&&n.z<=i)))if(this.raycastAgainstTrueSplatEllipsoid){c.makeScale(n.x,n.y,n.z),d.makeRotationFromQuaternion(s);const T=Math.log10(e.w)*2;if(a.makeScale(T,T,T),f.copy(a).multiply(d).multiply(c),u.copy(f).invert(),h.origin.copy(g.origin).sub(t).applyMatrix4(u),h.direction.copy(g.origin).add(g.direction).sub(t),h.direction.applyMatrix4(u).sub(h.origin).normalize(),h.intersectSphere(o,1,r)){const C=r.clone();C.splatIndex=v,C.origin.applyMatrix4(f).add(t),A.push(C)}}else{let T=n.x+n.y,C=2;if(p.splatMesh.splatRenderMode===Bt.ThreeD&&(T+=n.z,C=3),T=T/C,g.intersectSphere(t,T,r)){const E=r.clone();E.splatIndex=v,A.push(E)}}}if(m.children&&m.children.length>0)for(let y of m.children)this.castRayAtSplatTreeNode(g,p,y,A);return A}}}()}class yn{static buildVertexShaderBase(e=!1,t=!1,n=0,s=""){let r=`
        precision highp float;
        #include <common>

        attribute uint splatIndex;
        uniform highp usampler2D centersColorsTexture;
        uniform highp sampler2D sphericalHarmonicsTexture;
        uniform highp sampler2D sphericalHarmonicsTextureR;
        uniform highp sampler2D sphericalHarmonicsTextureG;
        uniform highp sampler2D sphericalHarmonicsTextureB;

        uniform highp usampler2D sceneIndexesTexture;
        uniform vec2 sceneIndexesTextureSize;
        uniform int sceneCount;
    `;return t&&(r+=`
            uniform float sceneOpacity[${Ee.MaxScenes}];
            uniform int sceneVisibility[${Ee.MaxScenes}];
        `),e&&(r+=`
            uniform highp mat4 transforms[${Ee.MaxScenes}];
        `),r+=`
        ${s}
        uniform vec2 focal;
        uniform float orthoZoom;
        uniform int orthographicMode;
        uniform int pointCloudModeEnabled;
        uniform float inverseFocalAdjustment;
        uniform vec2 viewport;
        uniform vec2 basisViewport;
        uniform vec2 centersColorsTextureSize;
        uniform int sphericalHarmonicsDegree;
        uniform vec2 sphericalHarmonicsTextureSize;
        uniform int sphericalHarmonics8BitMode;
        uniform int sphericalHarmonicsMultiTextureMode;
        uniform float visibleRegionRadius;
        uniform float visibleRegionFadeStartRadius;
        uniform float firstRenderTime;
        uniform float currentTime;
        uniform int fadeInComplete;
        uniform vec3 sceneCenter;
        uniform float splatScale;
        uniform float sphericalHarmonics8BitCompressionRangeMin[${Ee.MaxScenes}];
        uniform float sphericalHarmonics8BitCompressionRangeMax[${Ee.MaxScenes}];

        varying vec4 vColor;
        varying vec2 vUv;
        varying vec2 vPosition;

        mat3 quaternionToRotationMatrix(float x, float y, float z, float w) {
            float s = 1.0 / sqrt(w * w + x * x + y * y + z * z);
        
            return mat3(
                1. - 2. * (y * y + z * z),
                2. * (x * y + w * z),
                2. * (x * z - w * y),
                2. * (x * y - w * z),
                1. - 2. * (x * x + z * z),
                2. * (y * z + w * x),
                2. * (x * z + w * y),
                2. * (y * z - w * x),
                1. - 2. * (x * x + y * y)
            );
        }

        const float sqrt8 = sqrt(8.0);
        const float minAlpha = 1.0 / 255.0;

        const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);
        const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));
        const uvec4 shift4 = uvec4(0, 8, 16, 24);
        vec4 uintToRGBAVec (uint u) {
           uvec4 urgba = mask4 & u;
           urgba = urgba >> shift4;
           vec4 rgba = vec4(urgba) * encodeNorm4;
           return rgba;
        }

        vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {
            vec2 samplerUV = vec2(0.0, 0.0);
            float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;
            samplerUV.y = float(floor(d)) / dimensions.y;
            samplerUV.x = fract(d);
            return samplerUV;
        }

        vec2 getDataUVF(in uint sIndex, in float stride, in uint offset, in vec2 dimensions) {
            vec2 samplerUV = vec2(0.0, 0.0);
            float d = float(uint(float(sIndex) * stride) + offset) / dimensions.x;
            samplerUV.y = float(floor(d)) / dimensions.y;
            samplerUV.x = fract(d);
            return samplerUV;
        }

        const float SH_C1 = 0.4886025119029199f;
        const float[5] SH_C2 = float[](1.0925484, -1.0925484, 0.3153916, -1.0925484, 0.5462742);

        void main () {

            uint oddOffset = splatIndex & uint(0x00000001);
            uint doubleOddOffset = oddOffset * uint(2);
            bool isEven = oddOffset == uint(0);
            uint nearestEvenIndex = splatIndex - oddOffset;
            float fOddOffset = float(oddOffset);

            uint sceneIndex = uint(0);
            if (sceneCount > 1) {
                sceneIndex = texture(sceneIndexesTexture, getDataUV(1, 0, sceneIndexesTextureSize)).r;
            }

            uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));
            vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));
            `,t&&(r+=`
                float splatOpacityFromScene = sceneOpacity[sceneIndex];
                int sceneVisible = sceneVisibility[sceneIndex];
                if (splatOpacityFromScene <= 0.01 || sceneVisible == 0) {
                    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);
                    return;
                }
            `),e?r+=`
                mat4 transform = transforms[sceneIndex];
                mat4 transformModelViewMatrix = viewMatrix * transform;
            `:r+="mat4 transformModelViewMatrix = modelViewMatrix;",r+=`
            float sh8BitCompressionRangeMinForScene = sphericalHarmonics8BitCompressionRangeMin[sceneIndex];
            float sh8BitCompressionRangeMaxForScene = sphericalHarmonics8BitCompressionRangeMax[sceneIndex];
            float sh8BitCompressionRangeForScene = sh8BitCompressionRangeMaxForScene - sh8BitCompressionRangeMinForScene;
            float sh8BitCompressionHalfRangeForScene = sh8BitCompressionRangeForScene / 2.0;
            vec3 vec8BitSHShift = vec3(sh8BitCompressionRangeMinForScene);

            vec4 viewCenter = transformModelViewMatrix * vec4(splatCenter, 1.0);

            vec4 clipCenter = projectionMatrix * viewCenter;

            float clip = 1.2 * clipCenter.w;
            if (clipCenter.z < -clip || clipCenter.x < -clip || clipCenter.x > clip || clipCenter.y < -clip || clipCenter.y > clip) {
                gl_Position = vec4(0.0, 0.0, 2.0, 1.0);
                return;
            }

            vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

            vPosition = position.xy;
            vColor = uintToRGBAVec(sampledCenterColor.r);
        `,n>=1&&(r+=`   
            if (sphericalHarmonicsDegree >= 1) {
            `,e?r+=`
                    vec3 worldViewDir = normalize(splatCenter - vec3(inverse(transform) * vec4(cameraPosition, 1.0)));
                `:r+=`
                    vec3 worldViewDir = normalize(splatCenter - cameraPosition);
                `,r+=`
                vec3 sh1;
                vec3 sh2;
                vec3 sh3;
            `,n>=2&&(r+=`
                    vec3 sh4;
                    vec3 sh5;
                    vec3 sh6;
                    vec3 sh7;
                    vec3 sh8;
                `),n===1?r+=`
                    if (sphericalHarmonicsMultiTextureMode == 0) {
                        vec2 shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset, sphericalHarmonicsTextureSize);
                        vec4 sampledSH0123 = texture(sphericalHarmonicsTexture, shUV);
                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(1), sphericalHarmonicsTextureSize);
                        vec4 sampledSH4567 = texture(sphericalHarmonicsTexture, shUV);
                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(2), sphericalHarmonicsTextureSize);
                        vec4 sampledSH891011 = texture(sphericalHarmonicsTexture, shUV);
                        sh1 = vec3(sampledSH0123.rgb) * (1.0 - fOddOffset) + vec3(sampledSH0123.ba, sampledSH4567.r) * fOddOffset;
                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg) * (1.0 - fOddOffset) + vec3(sampledSH4567.gba) * fOddOffset;
                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r) * (1.0 - fOddOffset) + vec3(sampledSH891011.rgb) * fOddOffset;
                    } else {
                        vec2 sampledSH01R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH23R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH01G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH23G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH01B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH23B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;
                        sh1 = vec3(sampledSH01R.rg, sampledSH23R.r);
                        sh2 = vec3(sampledSH01G.rg, sampledSH23G.r);
                        sh3 = vec3(sampledSH01B.rg, sampledSH23B.r);
                    }
                `:n===2&&(r+=`
                    vec4 sampledSH0123;
                    vec4 sampledSH4567;
                    vec4 sampledSH891011;

                    vec4 sampledSH0123R;
                    vec4 sampledSH0123G;
                    vec4 sampledSH0123B;

                    if (sphericalHarmonicsMultiTextureMode == 0) {
                        sampledSH0123 = texture(sphericalHarmonicsTexture, getDataUV(6, 0, sphericalHarmonicsTextureSize));
                        sampledSH4567 = texture(sphericalHarmonicsTexture, getDataUV(6, 1, sphericalHarmonicsTextureSize));
                        sampledSH891011 = texture(sphericalHarmonicsTexture, getDataUV(6, 2, sphericalHarmonicsTextureSize));
                        sh1 = sampledSH0123.rgb;
                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg);
                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r);
                    } else {
                        sampledSH0123R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize));
                        sampledSH0123G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize));
                        sampledSH0123B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize));
                        sh1 = vec3(sampledSH0123R.rgb);
                        sh2 = vec3(sampledSH0123G.rgb);
                        sh3 = vec3(sampledSH0123B.rgb);
                    }
                `),r+=`
                    if (sphericalHarmonics8BitMode == 1) {
                        sh1 = sh1 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                        sh2 = sh2 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                        sh3 = sh3 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                    }
                    float x = worldViewDir.x;
                    float y = worldViewDir.y;
                    float z = worldViewDir.z;
                    vColor.rgb += SH_C1 * (-sh1 * y + sh2 * z - sh3 * x);
            `,n>=2&&(r+=`
                    if (sphericalHarmonicsDegree >= 2) {
                        float xx = x * x;
                        float yy = y * y;
                        float zz = z * z;
                        float xy = x * y;
                        float yz = y * z;
                        float xz = x * z;
                `,n===2&&(r+=`
                        if (sphericalHarmonicsMultiTextureMode == 0) {
                            vec4 sampledSH12131415 = texture(sphericalHarmonicsTexture, getDataUV(6, 3, sphericalHarmonicsTextureSize));
                            vec4 sampledSH16171819 = texture(sphericalHarmonicsTexture, getDataUV(6, 4, sphericalHarmonicsTextureSize));
                            vec4 sampledSH20212223 = texture(sphericalHarmonicsTexture, getDataUV(6, 5, sphericalHarmonicsTextureSize));
                            sh4 = sampledSH891011.gba;
                            sh5 = sampledSH12131415.rgb;
                            sh6 = vec3(sampledSH12131415.a, sampledSH16171819.rg);
                            sh7 = vec3(sampledSH16171819.ba, sampledSH20212223.r);
                            sh8 = sampledSH20212223.gba;
                        } else {
                            vec4 sampledSH4567R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize));
                            vec4 sampledSH4567G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize));
                            vec4 sampledSH4567B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize));
                            sh4 = vec3(sampledSH0123R.a, sampledSH4567R.rg);
                            sh5 = vec3(sampledSH4567R.ba, sampledSH0123G.a);
                            sh6 = vec3(sampledSH4567G.rgb);
                            sh7 = vec3(sampledSH4567G.a, sampledSH0123B.a, sampledSH4567B.r);
                            sh8 = vec3(sampledSH4567B.gba);
                        }
                    `),r+=`
                        if (sphericalHarmonics8BitMode == 1) {
                            sh4 = sh4 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh5 = sh5 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh6 = sh6 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh7 = sh7 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh8 = sh8 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                        }

                        vColor.rgb +=
                            (SH_C2[0] * xy) * sh4 +
                            (SH_C2[1] * yz) * sh5 +
                            (SH_C2[2] * (2.0 * zz - xx - yy)) * sh6 +
                            (SH_C2[3] * xz) * sh7 +
                            (SH_C2[4] * (xx - yy)) * sh8;
                    }
                `),r+=`

                vColor.rgb = clamp(vColor.rgb, vec3(0.), vec3(1.));

            }

            `),r}static getVertexShaderFadeIn(){return`
            if (fadeInComplete == 0) {
                float opacityAdjust = 1.0;
                float centerDist = length(splatCenter - sceneCenter);
                float renderTime = max(currentTime - firstRenderTime, 0.0);

                float fadeDistance = 0.75;
                float distanceLoadFadeInFactor = step(visibleRegionFadeStartRadius, centerDist);
                distanceLoadFadeInFactor = (1.0 - distanceLoadFadeInFactor) +
                                        (1.0 - clamp((centerDist - visibleRegionFadeStartRadius) / fadeDistance, 0.0, 1.0)) *
                                        distanceLoadFadeInFactor;
                opacityAdjust *= distanceLoadFadeInFactor;
                vColor.a *= opacityAdjust;
            }
        `}static getUniforms(e=!1,t=!1,n=0,s=1,r=!1){const i={sceneCenter:{type:"v3",value:new F},fadeInComplete:{type:"i",value:0},orthographicMode:{type:"i",value:0},visibleRegionFadeStartRadius:{type:"f",value:0},visibleRegionRadius:{type:"f",value:0},currentTime:{type:"f",value:0},firstRenderTime:{type:"f",value:0},centersColorsTexture:{type:"t",value:null},sphericalHarmonicsTexture:{type:"t",value:null},sphericalHarmonicsTextureR:{type:"t",value:null},sphericalHarmonicsTextureG:{type:"t",value:null},sphericalHarmonicsTextureB:{type:"t",value:null},sphericalHarmonics8BitCompressionRangeMin:{type:"f",value:[]},sphericalHarmonics8BitCompressionRangeMax:{type:"f",value:[]},focal:{type:"v2",value:new ge},orthoZoom:{type:"f",value:1},inverseFocalAdjustment:{type:"f",value:1},viewport:{type:"v2",value:new ge},basisViewport:{type:"v2",value:new ge},debugColor:{type:"v3",value:new Se},centersColorsTextureSize:{type:"v2",value:new ge(1024,1024)},sphericalHarmonicsDegree:{type:"i",value:n},sphericalHarmonicsTextureSize:{type:"v2",value:new ge(1024,1024)},sphericalHarmonics8BitMode:{type:"i",value:0},sphericalHarmonicsMultiTextureMode:{type:"i",value:0},splatScale:{type:"f",value:s},pointCloudModeEnabled:{type:"i",value:r?1:0},sceneIndexesTexture:{type:"t",value:null},sceneIndexesTextureSize:{type:"v2",value:new ge(1024,1024)},sceneCount:{type:"i",value:1}};for(let o=0;o<Ee.MaxScenes;o++)i.sphericalHarmonics8BitCompressionRangeMin.value.push(-Ee.SphericalHarmonics8BitCompressionRange/2),i.sphericalHarmonics8BitCompressionRangeMax.value.push(Ee.SphericalHarmonics8BitCompressionRange/2);if(t){const o=[];for(let c=0;c<Ee.MaxScenes;c++)o.push(1);i.sceneOpacity={type:"f",value:o};const a=[];for(let c=0;c<Ee.MaxScenes;c++)a.push(1);i.sceneVisibility={type:"i",value:a}}if(e){const o=[];for(let a=0;a<Ee.MaxScenes;a++)o.push(new he);i.transforms={type:"mat4",value:o}}return i}}class bs{static build(e=!1,t=!1,n=!1,s=2048,r=1,i=!1,o=0,a=.3){const c=`
            uniform vec2 covariancesTextureSize;
            uniform highp sampler2D covariancesTexture;
            uniform highp usampler2D covariancesTextureHalfFloat;
            uniform int covariancesAreHalfFloat;

            void fromCovarianceHalfFloatV4(uvec4 val, out vec4 first, out vec4 second) {
                vec2 r = unpackHalf2x16(val.r);
                vec2 g = unpackHalf2x16(val.g);
                vec2 b = unpackHalf2x16(val.b);

                first = vec4(r.x, r.y, g.x, g.y);
                second = vec4(b.x, b.y, 0.0, 0.0);
            }
        `;let d=yn.buildVertexShaderBase(e,t,o,c);d+=bs.buildVertexShaderProjection(n,t,s,a);const u=bs.buildFragmentShader(),f=yn.getUniforms(e,t,o,r,i);return f.covariancesTextureSize={type:"v2",value:new ge(1024,1024)},f.covariancesTexture={type:"t",value:null},f.covariancesTextureHalfFloat={type:"t",value:null},f.covariancesAreHalfFloat={type:"i",value:0},new mn({uniforms:f,vertexShader:d,fragmentShader:u,transparent:!0,alphaTest:1,blending:Ko,depthTest:!0,depthWrite:!1,side:Sn})}static buildVertexShaderProjection(e,t,n,s){let r=`

            vec4 sampledCovarianceA;
            vec4 sampledCovarianceB;
            vec3 cov3D_M11_M12_M13;
            vec3 cov3D_M22_M23_M33;
            if (covariancesAreHalfFloat == 0) {
                sampledCovarianceA = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset,
                                                                            covariancesTextureSize));
                sampledCovarianceB = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset + uint(1),
                                                                            covariancesTextureSize));

                cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rgb) * (1.0 - fOddOffset) +
                                    vec3(sampledCovarianceA.ba, sampledCovarianceB.r) * fOddOffset;
                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg) * (1.0 - fOddOffset) +
                                    vec3(sampledCovarianceB.gba) * fOddOffset;
            } else {
                uvec4 sampledCovarianceU = texture(covariancesTextureHalfFloat, getDataUV(1, 0, covariancesTextureSize));
                fromCovarianceHalfFloatV4(sampledCovarianceU, sampledCovarianceA, sampledCovarianceB);
                cov3D_M11_M12_M13 = sampledCovarianceA.rgb;
                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg);
            }
        
            // Construct the 3D covariance matrix
            mat3 Vrk = mat3(
                cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,
                cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,
                cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z
            );

            mat3 J;
            if (orthographicMode == 1) {
                // Since the projection is linear, we don't need an approximation
                J = transpose(mat3(orthoZoom, 0.0, 0.0,
                                0.0, orthoZoom, 0.0,
                                0.0, 0.0, 0.0));
            } else {
                // Construct the Jacobian of the affine approximation of the projection matrix. It will be used to transform the
                // 3D covariance matrix instead of using the actual projection matrix because that transformation would
                // require a non-linear component (perspective division) which would yield a non-gaussian result.
                float s = 1.0 / (viewCenter.z * viewCenter.z);
                J = mat3(
                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,
                    0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,
                    0., 0., 0.
                );
            }

            // Concatenate the projection approximation with the model-view transformation
            mat3 W = transpose(mat3(transformModelViewMatrix));
            mat3 T = W * J;

            // Transform the 3D covariance matrix (Vrk) to compute the 2D covariance matrix
            mat3 cov2Dm = transpose(T) * Vrk * T;
            `;return e?r+=`
                float detOrig = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];
                cov2Dm[0][0] += ${s};
                cov2Dm[1][1] += ${s};
                float detBlur = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];
                vColor.a *= sqrt(max(detOrig / detBlur, 0.0));
                if (vColor.a < minAlpha) return;
            `:r+=`
                cov2Dm[0][0] += ${s};
                cov2Dm[1][1] += ${s};
            `,r+=`

            // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because
            // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],
            // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't
            // need cov2Dm[1][0] because it is a symetric matrix.
            vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);

            // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix
            // so that we can determine the 2D basis for the splat. This is done using the method described
            // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
            // After calculating the eigen-values and eigen-vectors, we calculate the basis for rendering the splat
            // by normalizing the eigen-vectors and then multiplying them by (sqrt(8) * sqrt(eigen-value)), which is
            // equal to scaling them by sqrt(8) standard deviations.
            //
            // This is a different approach than in the original work at INRIA. In that work they compute the
            // max extents of the projected splat in screen space to form a screen-space aligned bounding rectangle
            // which forms the geometry that is actually rasterized. The dimensions of that bounding box are 3.0
            // times the square root of the maximum eigen-value, or 3 standard deviations. They then use the inverse
            // 2D covariance matrix (called 'conic') in the CUDA rendering thread to determine fragment opacity by
            // calculating the full gaussian: exp(-0.5 * (X - mean) * conic * (X - mean)) * splat opacity
            float a = cov2Dv.x;
            float d = cov2Dv.z;
            float b = cov2Dv.y;
            float D = a * d - b * b;
            float trace = a + d;
            float traceOver2 = 0.5 * trace;
            float term2 = sqrt(max(0.1f, traceOver2 * traceOver2 - D));
            float eigenValue1 = traceOver2 + term2;
            float eigenValue2 = traceOver2 - term2;

            if (pointCloudModeEnabled == 1) {
                eigenValue1 = eigenValue2 = 0.2;
            }

            if (eigenValue2 <= 0.0) return;

            vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));
            // since the eigen vectors are orthogonal, we derive the second one from the first
            vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);

            // We use sqrt(8) standard deviations instead of 3 to eliminate more of the splat with a very low opacity.
            vec2 basisVector1 = eigenVector1 * splatScale * min(sqrt8 * sqrt(eigenValue1), ${parseInt(n)}.0);
            vec2 basisVector2 = eigenVector2 * splatScale * min(sqrt8 * sqrt(eigenValue2), ${parseInt(n)}.0);
            `,t&&(r+=`
                vColor.a *= splatOpacityFromScene;
            `),r+=`
            vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) *
                             basisViewport * 2.0 * inverseFocalAdjustment;

            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
            gl_Position = quadPos;

            // Scale the position data we send to the fragment shader
            vPosition *= sqrt8;
        `,r+=yn.getVertexShaderFadeIn(),r+="}",r}static buildFragmentShader(){let e=`
            precision highp float;
            #include <common>
 
            uniform vec3 debugColor;

            varying vec4 vColor;
            varying vec2 vUv;
            varying vec2 vPosition;
        `;return e+=`
            void main () {
                // Compute the positional squared distance from the center of the splat to the current fragment.
                float A = dot(vPosition, vPosition);
                // Since the positional data in vPosition has been scaled by sqrt(8), the squared result will be
                // scaled by a factor of 8. If the squared result is larger than 8, it means it is outside the ellipse
                // defined by the rectangle formed by vPosition. It also means it's farther
                // away than sqrt(8) standard deviations from the mean.
                if (A > 8.0) discard;
                vec3 color = vColor.rgb;

                // Since the rendered splat is scaled by sqrt(8), the inverse covariance matrix that is part of
                // the gaussian formula becomes the identity matrix. We're then left with (X - mean) * (X - mean),
                // and since 'mean' is zero, we have X * X, which is the same as A:
                float opacity = exp(-0.5 * A) * vColor.a;

                gl_FragColor = vec4(color.rgb, opacity);
            }
        `,e}}class Is{static build(e=!1,t=!1,n=1,s=!1,r=0){const i=`
            uniform vec2 scaleRotationsTextureSize;
            uniform highp sampler2D scaleRotationsTexture;
            varying mat3 vT;
            varying vec2 vQuadCenter;
            varying vec2 vFragCoord;
        `;let o=yn.buildVertexShaderBase(e,t,r,i);o+=Is.buildVertexShaderProjection();const a=Is.buildFragmentShader(),c=yn.getUniforms(e,t,r,n,s);return c.scaleRotationsTexture={type:"t",value:null},c.scaleRotationsTextureSize={type:"v2",value:new ge(1024,1024)},new mn({uniforms:c,vertexShader:o,fragmentShader:a,transparent:!0,alphaTest:1,blending:Ko,depthTest:!0,depthWrite:!1,side:Sn})}static buildVertexShaderProjection(){let e=`

            vec4 scaleRotationA = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,
                                                                            oddOffset, scaleRotationsTextureSize));
            vec4 scaleRotationB = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,
                                                                            oddOffset + uint(1), scaleRotationsTextureSize));

            vec3 scaleRotation123 = vec3(scaleRotationA.rgb) * (1.0 - fOddOffset) +
                                    vec3(scaleRotationA.ba, scaleRotationB.r) * fOddOffset;
            vec3 scaleRotation456 = vec3(scaleRotationA.a, scaleRotationB.rg) * (1.0 - fOddOffset) +
                                    vec3(scaleRotationB.gba) * fOddOffset;

            float missingW = sqrt(1.0 - scaleRotation456.x * scaleRotation456.x - scaleRotation456.y *
                                    scaleRotation456.y - scaleRotation456.z * scaleRotation456.z);
            mat3 R = quaternionToRotationMatrix(scaleRotation456.r, scaleRotation456.g, scaleRotation456.b, missingW);
            mat3 S = mat3(scaleRotation123.r, 0.0, 0.0,
                            0.0, scaleRotation123.g, 0.0,
                            0.0, 0.0, scaleRotation123.b);
            
            mat3 L = R * S;

            mat3x4 splat2World = mat3x4(vec4(L[0], 0.0),
                                        vec4(L[1], 0.0),
                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));

            mat4 world2ndc = transpose(projectionMatrix * transformModelViewMatrix);

            mat3x4 ndc2pix = mat3x4(vec4(viewport.x / 2.0, 0.0, 0.0, (viewport.x - 1.0) / 2.0),
                                    vec4(0.0, viewport.y / 2.0, 0.0, (viewport.y - 1.0) / 2.0),
                                    vec4(0.0, 0.0, 0.0, 1.0));

            mat3 T = transpose(splat2World) * world2ndc * ndc2pix;
            vec3 normal = vec3(viewMatrix * vec4(L[0][2], L[1][2], L[2][2], 0.0));
        `;return e+=`

                mat4 splat2World4 = mat4(vec4(L[0], 0.0),
                                        vec4(L[1], 0.0),
                                        vec4(L[2], 0.0),
                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));

                mat4 Tt = transpose(transpose(splat2World4) * world2ndc);

                vec4 tempPoint1 = Tt * vec4(1.0, 0.0, 0.0, 1.0);
                tempPoint1 /= tempPoint1.w;

                vec4 tempPoint2 = Tt * vec4(0.0, 1.0, 0.0, 1.0);
                tempPoint2 /= tempPoint2.w;

                vec4 center = Tt * vec4(0.0, 0.0, 0.0, 1.0);
                center /= center.w;

                vec2 basisVector1 = tempPoint1.xy - center.xy;
                vec2 basisVector2 = tempPoint2.xy - center.xy;

                vec2 basisVector1Screen = basisVector1 * 0.5 * viewport;
                vec2 basisVector2Screen = basisVector2 * 0.5 * viewport;

                const float minPix = 1.;
                if (length(basisVector1Screen) < minPix || length(basisVector2Screen) < minPix) {
                    
            vec3 T0 = vec3(T[0][0], T[0][1], T[0][2]);
            vec3 T1 = vec3(T[1][0], T[1][1], T[1][2]);
            vec3 T3 = vec3(T[2][0], T[2][1], T[2][2]);

            vec3 tempPoint = vec3(1.0, 1.0, -1.0);
            float distance = (T3.x * T3.x * tempPoint.x) + (T3.y * T3.y * tempPoint.y) + (T3.z * T3.z * tempPoint.z);
            vec3 f = (1.0 / distance) * tempPoint;
            if (abs(distance) < 0.00001) return;

            float pointImageX = (T0.x * T3.x * f.x) + (T0.y * T3.y * f.y) + (T0.z * T3.z * f.z);
            float pointImageY = (T1.x * T3.x * f.x) + (T1.y * T3.y * f.y) + (T1.z * T3.z * f.z);
            vec2 pointImage = vec2(pointImageX, pointImageY);

            float tempX = (T0.x * T0.x * f.x) + (T0.y * T0.y * f.y) + (T0.z * T0.z * f.z);
            float tempY = (T1.x * T1.x * f.x) + (T1.y * T1.y * f.y) + (T1.z * T1.z * f.z);
            vec2 temp = vec2(tempX, tempY);

            vec2 halfExtend = pointImage * pointImage - temp;
            vec2 extent = sqrt(max(vec2(0.0001), halfExtend));
            float radius = max(extent.x, extent.y);

            vec2 ndcOffset = ((position.xy * radius * 3.0) * basisViewport * 2.0);

            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
            gl_Position = quadPos;

            vT = T;
            vQuadCenter = pointImage;
            vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;
        
                } else {
                    vec2 ndcOffset = vec2(position.x * basisVector1 + position.y * basisVector2) * 3.0 * inverseFocalAdjustment;
                    vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
                    gl_Position = quadPos;

                    vT = T;
                    vQuadCenter = center.xy;
                    vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;
                }
            `,e+=yn.getVertexShaderFadeIn(),e+="}",e}static buildFragmentShader(){return`
            precision highp float;
            #include <common>

            uniform vec3 debugColor;

            varying vec4 vColor;
            varying vec2 vUv;
            varying vec2 vPosition;
            varying mat3 vT;
            varying vec2 vQuadCenter;
            varying vec2 vFragCoord;

            void main () {

                const float FilterInvSquare = 2.0;
                const float near_n = 0.2;
                const float T = 1.0;

                vec2 xy = vQuadCenter;
                vec3 Tu = vT[0];
                vec3 Tv = vT[1];
                vec3 Tw = vT[2];
                vec3 k = vFragCoord.x * Tw - Tu;
                vec3 l = vFragCoord.y * Tw - Tv;
                vec3 p = cross(k, l);
                if (p.z == 0.0) discard;
                vec2 s = vec2(p.x / p.z, p.y / p.z);
                float rho3d = (s.x * s.x + s.y * s.y); 
                vec2 d = vec2(xy.x - vFragCoord.x, xy.y - vFragCoord.y);
                float rho2d = FilterInvSquare * (d.x * d.x + d.y * d.y); 

                // compute intersection and depth
                float rho = min(rho3d, rho2d);
                float depth = (rho3d <= rho2d) ? (s.x * Tw.x + s.y * Tw.y) + Tw.z : Tw.z; 
                if (depth < near_n) discard;
                //  vec4 nor_o = collected_normal_opacity[j];
                //  float normal[3] = {nor_o.x, nor_o.y, nor_o.z};
                float opa = vColor.a;

                float power = -0.5f * rho;
                if (power > 0.0f) discard;

                // Eq. (2) from 3D Gaussian splatting paper.
                // Obtain alpha by multiplying with Gaussian opacity
                // and its exponential falloff from mean.
                // Avoid numerical instabilities (see paper appendix). 
                float alpha = min(0.99f, opa * exp(power));
                if (alpha < 1.0f / 255.0f) discard;
                float test_T = T * (1.0 - alpha);
                if (test_T < 0.0001)discard;

                float w = alpha * T;
                gl_FragColor = vec4(vColor.rgb, w);
            }
        `}}class jf{static build(e){const t=new je;t.setIndex([0,1,2,0,2,3]);const n=new Float32Array(4*3),s=new He(n,3);t.setAttribute("position",s),s.setXYZ(0,-1,-1,0),s.setXYZ(1,-1,1,0),s.setXYZ(2,1,1,0),s.setXYZ(3,1,-1,0),s.needsUpdate=!0;const r=new Vl().copy(t),i=new Uint32Array(e),o=new Uo(i,1,!1);return o.setUsage(Go),r.setAttribute("splatIndex",o),r.instanceCount=0,r}}class Qf extends Ze{constructor(e,t=new F,n=new ce,s=new F(1,1,1),r=1,i=1,o=!0){super(),this.splatBuffer=e,this.position.copy(t),this.quaternion.copy(n),this.scale.copy(s),this.transform=new he,this.minimumAlpha=r,this.opacity=i,this.visible=o}copyTransformData(e){this.position.copy(e.position),this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.transform.copy(e.transform)}updateTransform(e){e?(this.matrixWorldAutoUpdate&&this.updateWorldMatrix(!0,!1),this.transform.copy(this.matrixWorld)):(this.matrixAutoUpdate&&this.updateMatrix(),this.transform.copy(this.matrix))}}class ti{static idGen=0;constructor(e,t,n,s){this.min=new F().copy(e),this.max=new F().copy(t),this.boundingBox=new Qt(this.min,this.max),this.center=new F().copy(this.max).sub(this.min).multiplyScalar(.5).add(this.min),this.depth=n,this.children=[],this.data=null,this.id=s||ti.idGen++}}class Un{constructor(e,t){this.maxDepth=e,this.maxCentersPerNode=t,this.sceneDimensions=new F,this.sceneMin=new F,this.sceneMax=new F,this.rootNode=null,this.nodesWithIndexes=[],this.splatMesh=null}static convertWorkerSubTreeNode(e){const t=new F().fromArray(e.min),n=new F().fromArray(e.max),s=new ti(t,n,e.depth,e.id);if(e.data.indexes){s.data={indexes:[]};for(let r of e.data.indexes)s.data.indexes.push(r)}if(e.children)for(let r of e.children)s.children.push(Un.convertWorkerSubTreeNode(r));return s}static convertWorkerSubTree(e,t){const n=new Un(e.maxDepth,e.maxCentersPerNode);n.sceneMin=new F().fromArray(e.sceneMin),n.sceneMax=new F().fromArray(e.sceneMax),n.splatMesh=t,n.rootNode=Un.convertWorkerSubTreeNode(e.rootNode);const s=(r,i)=>{r.children.length===0&&i(r);for(let o of r.children)s(o,i)};return n.nodesWithIndexes=[],s(n.rootNode,r=>{r.data&&r.data.indexes&&r.data.indexes.length>0&&n.nodesWithIndexes.push(r)}),n}}function Gf(l){let e=0;class t{constructor(a,c){this.min=[a[0],a[1],a[2]],this.max=[c[0],c[1],c[2]]}containsPoint(a){return a[0]>=this.min[0]&&a[0]<=this.max[0]&&a[1]>=this.min[1]&&a[1]<=this.max[1]&&a[2]>=this.min[2]&&a[2]<=this.max[2]}}class n{constructor(a,c){this.maxDepth=a,this.maxCentersPerNode=c,this.sceneDimensions=[],this.sceneMin=[],this.sceneMax=[],this.rootNode=null,this.addedIndexes={},this.nodesWithIndexes=[],this.splatMesh=null,this.disposed=!1}}class s{constructor(a,c,d,u){this.min=[a[0],a[1],a[2]],this.max=[c[0],c[1],c[2]],this.center=[(c[0]-a[0])*.5+a[0],(c[1]-a[1])*.5+a[1],(c[2]-a[2])*.5+a[2]],this.depth=d,this.children=[],this.data=null,this.id=u||e++}}processSplatTreeNode=function(o,a,c,d){const u=a.data.indexes.length;if(u<o.maxCentersPerNode||a.depth>o.maxDepth){const y=[];for(let v=0;v<a.data.indexes.length;v++)o.addedIndexes[a.data.indexes[v]]||(y.push(a.data.indexes[v]),o.addedIndexes[a.data.indexes[v]]=!0);a.data.indexes=y,a.data.indexes.sort((v,x)=>v>x?1:-1),o.nodesWithIndexes.push(a);return}const f=[a.max[0]-a.min[0],a.max[1]-a.min[1],a.max[2]-a.min[2]],h=[f[0]*.5,f[1]*.5,f[2]*.5],g=[a.min[0]+h[0],a.min[1]+h[1],a.min[2]+h[2]],p=[new t([g[0]-h[0],g[1],g[2]-h[2]],[g[0],g[1]+h[1],g[2]]),new t([g[0],g[1],g[2]-h[2]],[g[0]+h[0],g[1]+h[1],g[2]]),new t([g[0],g[1],g[2]],[g[0]+h[0],g[1]+h[1],g[2]+h[2]]),new t([g[0]-h[0],g[1],g[2]],[g[0],g[1]+h[1],g[2]+h[2]]),new t([g[0]-h[0],g[1]-h[1],g[2]-h[2]],[g[0],g[1],g[2]]),new t([g[0],g[1]-h[1],g[2]-h[2]],[g[0]+h[0],g[1],g[2]]),new t([g[0],g[1]-h[1],g[2]],[g[0]+h[0],g[1],g[2]+h[2]]),new t([g[0]-h[0],g[1]-h[1],g[2]],[g[0],g[1],g[2]+h[2]])],m=[];for(let y=0;y<p.length;y++)m[y]=[];const A=[0,0,0];for(let y=0;y<u;y++){const v=a.data.indexes[y],x=c[v];A[0]=d[x],A[1]=d[x+1],A[2]=d[x+2];for(let w=0;w<p.length;w++)p[w].containsPoint(A)&&m[w].push(v)}for(let y=0;y<p.length;y++){const v=new s(p[y].min,p[y].max,a.depth+1);v.data={indexes:m[y]},a.children.push(v)}a.data={};for(let y of a.children)processSplatTreeNode(o,y,c,d)};const r=(o,a,c)=>{const d=[0,0,0],u=[0,0,0],f=[],h=Math.floor(o.length/4);for(let p=0;p<h;p++){const m=p*4,A=o[m],y=o[m+1],v=o[m+2],x=Math.round(o[m+3]);(p===0||A<d[0])&&(d[0]=A),(p===0||A>u[0])&&(u[0]=A),(p===0||y<d[1])&&(d[1]=y),(p===0||y>u[1])&&(u[1]=y),(p===0||v<d[2])&&(d[2]=v),(p===0||v>u[2])&&(u[2]=v),f.push(x)}const g=new n(a,c);return g.sceneMin=d,g.sceneMax=u,g.rootNode=new s(g.sceneMin,g.sceneMax,0),g.rootNode.data={indexes:f},g};function i(o,a,c){const d=[];for(let f of o){const h=Math.floor(f.length/4);for(let g=0;g<h;g++){const p=g*4,m=Math.round(f[p+3]);d[m]=p}}const u=[];for(let f of o){const h=r(f,a,c);u.push(h),processSplatTreeNode(h,h.rootNode,d,f)}l.postMessage({subTrees:u})}l.onmessage=o=>{o.data.process&&i(o.data.process.centers,o.data.process.maxDepth,o.data.process.maxCentersPerNode)}}function qf(l,e,t,n,s){l.postMessage({process:{centers:e,maxDepth:n,maxCentersPerNode:s}},t)}function Xf(){return new Worker(URL.createObjectURL(new Blob(["(",Gf.toString(),")(self)"],{type:"application/javascript"})))}class Kf{constructor(e,t){this.maxDepth=e,this.maxCentersPerNode=t,this.subTrees=[],this.splatMesh=null}dispose(){this.diposeSplatTreeWorker(),this.disposed=!0}diposeSplatTreeWorker(){this.splatTreeWorker&&this.splatTreeWorker.terminate(),this.splatTreeWorker=null}processSplatMesh=function(e,t=()=>!0,n,s){this.splatTreeWorker||(this.splatTreeWorker=Xf()),this.splatMesh=e,this.subTrees=[];const r=new F,i=(o,a)=>{const c=new Float32Array(a*4);let d=0;for(let u=0;u<a;u++){const f=u+o;if(t(f)){e.getSplatCenter(f,r);const h=d*4;c[h]=r.x,c[h+1]=r.y,c[h+2]=r.z,c[h+3]=f,d++}}return c};return new Promise(o=>{const a=()=>this.disposed?(this.diposeSplatTreeWorker(),o(),!0):!1;n&&n(!1),ut(()=>{if(a())return;const c=[];if(e.dynamicMode){let d=0;for(let u=0;u<e.scenes.length;u++){const h=e.getScene(u).splatBuffer.getSplatCount(),g=i(d,h);c.push(g),d+=h}}else{const d=i(0,e.getSplatCount());c.push(d)}this.splatTreeWorker.onmessage=d=>{a()||d.data.subTrees&&(s&&s(!1),ut(()=>{if(!a()){for(let u of d.data.subTrees){const f=Un.convertWorkerSubTree(u,e);this.subTrees.push(f)}this.diposeSplatTreeWorker(),s&&s(!0),ut(()=>{o()})}}))},ut(()=>{if(a())return;n&&n(!0);const d=c.map(u=>u.buffer);qf(this.splatTreeWorker,c,d,this.maxDepth,this.maxCentersPerNode)})})})};countLeaves(){let e=0;return this.visitLeaves(()=>{e++}),e}visitLeaves(e){const t=(n,s)=>{n.children.length===0&&s(n);for(let r of n.children)t(r,s)};for(let n of this.subTrees)t(n.rootNode,e)}}function Yf(l){const e={};function t(n){if(e[n]!==void 0)return e[n];let s;switch(n){case"WEBGL_depth_texture":s=l.getExtension("WEBGL_depth_texture")||l.getExtension("MOZ_WEBGL_depth_texture")||l.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":s=l.getExtension("EXT_texture_filter_anisotropic")||l.getExtension("MOZ_EXT_texture_filter_anisotropic")||l.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":s=l.getExtension("WEBGL_compressed_texture_s3tc")||l.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||l.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":s=l.getExtension("WEBGL_compressed_texture_pvrtc")||l.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:s=l.getExtension(n)}return e[n]=s,s}return{has:function(n){return t(n)!==null},init:function(n){n.isWebGL2?(t("EXT_color_buffer_float"),t("WEBGL_clip_cull_distance")):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(n){const s=t(n);return s===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),s}}}function Zf(l,e,t){let n;function s(){if(n!==void 0)return n;if(e.has("EXT_texture_filter_anisotropic")===!0){const C=e.get("EXT_texture_filter_anisotropic");n=l.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function r(C){if(C==="highp"){if(l.getShaderPrecisionFormat(l.VERTEX_SHADER,l.HIGH_FLOAT).precision>0&&l.getShaderPrecisionFormat(l.FRAGMENT_SHADER,l.HIGH_FLOAT).precision>0)return"highp";C="mediump"}return C==="mediump"&&l.getShaderPrecisionFormat(l.VERTEX_SHADER,l.MEDIUM_FLOAT).precision>0&&l.getShaderPrecisionFormat(l.FRAGMENT_SHADER,l.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const i=typeof WebGL2RenderingContext<"u"&&l.constructor.name==="WebGL2RenderingContext";let o=t.precision!==void 0?t.precision:"highp";const a=r(o);a!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",a,"instead."),o=a);const c=i||e.has("WEBGL_draw_buffers"),d=t.logarithmicDepthBuffer===!0,u=l.getParameter(l.MAX_TEXTURE_IMAGE_UNITS),f=l.getParameter(l.MAX_VERTEX_TEXTURE_IMAGE_UNITS),h=l.getParameter(l.MAX_TEXTURE_SIZE),g=l.getParameter(l.MAX_CUBE_MAP_TEXTURE_SIZE),p=l.getParameter(l.MAX_VERTEX_ATTRIBS),m=l.getParameter(l.MAX_VERTEX_UNIFORM_VECTORS),A=l.getParameter(l.MAX_VARYING_VECTORS),y=l.getParameter(l.MAX_FRAGMENT_UNIFORM_VECTORS),v=f>0,x=i||e.has("OES_texture_float"),w=v&&x,T=i?l.getParameter(l.MAX_SAMPLES):0;return{isWebGL2:i,drawBuffers:c,getMaxAnisotropy:s,getMaxPrecision:r,precision:o,logarithmicDepthBuffer:d,maxTextures:u,maxVertexTextures:f,maxTextureSize:h,maxCubemapSize:g,maxAttributes:p,maxVertexUniforms:m,maxVaryings:A,maxFragmentUniforms:y,vertexTextures:v,floatFragmentTextures:x,floatVertexTextures:w,maxSamples:T}}const Nn={Default:0,Gradual:1,Instant:2},vn={None:0,Error:1,Warning:2,Info:3,Debug:4},bo=new je,Jf=new rt,cs=6,$f=4,ep=4,tp=4,np=6,sp=8,ur=4,dr=4,Io=1,rp=.012,ip=.003,Ro=1,Bo=16777216;class Ge extends Oe{constructor(e=Bt.ThreeD,t=!1,n=!1,s=!1,r=1,i=!0,o=!1,a=!1,c=1024,d=vn.None,u=0,f=1,h=.3){super(bo,Jf),this.renderer=void 0,this.splatRenderMode=e,this.dynamicMode=t,this.enableOptionalEffects=n,this.halfPrecisionCovariancesOnGPU=s,this.devicePixelRatio=r,this.enableDistancesComputationOnGPU=i,this.integerBasedDistancesComputation=o,this.antialiased=a,this.kernel2DSize=h,this.maxScreenSpaceSplatSize=c,this.logLevel=d,this.sphericalHarmonicsDegree=u,this.minSphericalHarmonicsDegree=0,this.sceneFadeInRateMultiplier=f,this.scenes=[],this.splatTree=null,this.baseSplatTree=null,this.splatDataTextures={},this.distancesTransformFeedback={id:null,vertexShader:null,fragmentShader:null,program:null,centersBuffer:null,sceneIndexesBuffer:null,outDistancesBuffer:null,centersLoc:-1,modelViewProjLoc:-1,sceneIndexesLoc:-1,transformsLocs:[]},this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSceneIndexMap=[],this.lastBuildSplatCount=0,this.lastBuildScenes=[],this.lastBuildMaxSplatCount=0,this.lastBuildSceneCount=0,this.firstRenderTime=-1,this.finalBuild=!1,this.webGLUtils=null,this.boundingBox=new Qt,this.calculatedSceneCenter=new F,this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.visibleRegionChanging=!1,this.splatScale=1,this.pointCloudModeEnabled=!1,this.disposed=!1,this.lastRenderer=null,this.visible=!1}static buildScenes(e,t,n){const s=[];s.length=t.length;for(let r=0;r<t.length;r++){const i=t[r],o=n[r]||{};let a=o.position||[0,0,0],c=o.rotation||[0,0,0,1],d=o.scale||[1,1,1];const u=new F().fromArray(a),f=new ce().fromArray(c),h=new F().fromArray(d),g=Ge.createScene(i,u,f,h,o.splatAlphaRemovalThreshold||1,o.opacity,o.visible);e.add(g),s[r]=g}return s}static createScene(e,t,n,s,r,i=1,o=!0){return new Qf(e,t,n,s,r,i,o)}static buildSplatIndexMaps(e){const t=[],n=[];let s=0;for(let r=0;r<e.length;r++){const o=e[r].getMaxSplatCount();for(let a=0;a<o;a++)t[s]=a,n[s]=r,s++}return{localSplatIndexMap:t,sceneIndexMap:n}}buildSplatTree=function(e=[],t,n){return new Promise(s=>{this.disposeSplatTree(),this.baseSplatTree=new Kf(8,1e3);const r=performance.now(),i=new zt;this.baseSplatTree.processSplatMesh(this,o=>{this.getSplatColor(o,i);const a=this.getSceneIndexForSplat(o),c=e[a]||1;return i.w>=c},t,n).then(()=>{const o=performance.now()-r;if(this.logLevel>=vn.Info&&console.log("SplatTree build: "+o+" ms"),this.disposed)s();else{this.splatTree=this.baseSplatTree,this.baseSplatTree=null;let a=0,c=0,d=0;this.splatTree.visitLeaves(u=>{const f=u.data.indexes.length;f>0&&(c+=f,d++,a++)}),this.logLevel>=vn.Info&&(console.log(`SplatTree leaves: ${this.splatTree.countLeaves()}`),console.log(`SplatTree leaves with splats:${a}`),c=c/d,console.log(`Avg splat count per node: ${c}`),console.log(`Total splat count: ${this.getSplatCount()}`)),s()}})})};build(e,t,n=!0,s=!1,r,i,o=!0){this.sceneOptions=t,this.finalBuild=s;const a=Ge.getTotalMaxSplatCountForSplatBuffers(e),c=Ge.buildScenes(this,e,t);if(n)for(let p=0;p<this.scenes.length&&p<c.length;p++){const m=c[p],A=this.getScene(p);m.copyTransformData(A)}this.scenes=c;let d=3;for(let p of e){const m=p.getMinSphericalHarmonicsDegree();m<d&&(d=m)}this.minSphericalHarmonicsDegree=Math.min(d,this.sphericalHarmonicsDegree);let u=!1;if(e.length!==this.lastBuildScenes.length)u=!0;else for(let p=0;p<e.length;p++)if(e[p]!==this.lastBuildScenes[p].splatBuffer){u=!0;break}let f=!0;if((this.scenes.length!==1||this.lastBuildSceneCount!==this.scenes.length||this.lastBuildMaxSplatCount!==a||u)&&(f=!1),!f){this.boundingBox=new Qt,o||(this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.firstRenderTime=-1),this.lastBuildScenes=[],this.lastBuildSplatCount=0,this.lastBuildMaxSplatCount=0,this.disposeMeshData(),this.geometry=jf.build(a),this.splatRenderMode===Bt.ThreeD?this.material=bs.build(this.dynamicMode,this.enableOptionalEffects,this.antialiased,this.maxScreenSpaceSplatSize,this.splatScale,this.pointCloudModeEnabled,this.minSphericalHarmonicsDegree,this.kernel2DSize):this.material=Is.build(this.dynamicMode,this.enableOptionalEffects,this.splatScale,this.pointCloudModeEnabled,this.minSphericalHarmonicsDegree);const p=Ge.buildSplatIndexMaps(e);this.globalSplatIndexToLocalSplatIndexMap=p.localSplatIndexMap,this.globalSplatIndexToSceneIndexMap=p.sceneIndexMap}const h=this.getSplatCount(!0);this.enableDistancesComputationOnGPU&&this.setupDistancesComputationTransformFeedback();const g=this.refreshGPUDataFromSplatBuffers(f);for(let p=0;p<this.scenes.length;p++)this.lastBuildScenes[p]=this.scenes[p];return this.lastBuildSplatCount=h,this.lastBuildMaxSplatCount=this.getMaxSplatCount(),this.lastBuildSceneCount=this.scenes.length,s&&this.scenes.length>0&&this.buildSplatTree(t.map(p=>p.splatAlphaRemovalThreshold||1),r,i).then(()=>{this.onSplatTreeReadyCallback&&this.onSplatTreeReadyCallback(this.splatTree),this.onSplatTreeReadyCallback=null}),this.visible=this.scenes.length>0,g}freeIntermediateSplatData(){const e=t=>{delete t.source.data,delete t.image,t.onUpdate=null};delete this.splatDataTextures.baseData.covariances,delete this.splatDataTextures.baseData.centers,delete this.splatDataTextures.baseData.colors,delete this.splatDataTextures.baseData.sphericalHarmonics,delete this.splatDataTextures.centerColors.data,delete this.splatDataTextures.covariances.data,this.splatDataTextures.sphericalHarmonics&&delete this.splatDataTextures.sphericalHarmonics.data,this.splatDataTextures.sceneIndexes&&delete this.splatDataTextures.sceneIndexes.data,this.splatDataTextures.centerColors.texture.needsUpdate=!0,this.splatDataTextures.centerColors.texture.onUpdate=()=>{e(this.splatDataTextures.centerColors.texture)},this.splatDataTextures.covariances.texture.needsUpdate=!0,this.splatDataTextures.covariances.texture.onUpdate=()=>{e(this.splatDataTextures.covariances.texture)},this.splatDataTextures.sphericalHarmonics&&(this.splatDataTextures.sphericalHarmonics.texture?(this.splatDataTextures.sphericalHarmonics.texture.needsUpdate=!0,this.splatDataTextures.sphericalHarmonics.texture.onUpdate=()=>{e(this.splatDataTextures.sphericalHarmonics.texture)}):this.splatDataTextures.sphericalHarmonics.textures.forEach(t=>{t.needsUpdate=!0,t.onUpdate=()=>{e(t)}})),this.splatDataTextures.sceneIndexes&&(this.splatDataTextures.sceneIndexes.texture.needsUpdate=!0,this.splatDataTextures.sceneIndexes.texture.onUpdate=()=>{e(this.splatDataTextures.sceneIndexes.texture)})}dispose(){this.disposeMeshData(),this.disposeTextures(),this.disposeSplatTree(),this.enableDistancesComputationOnGPU&&(this.computeDistancesOnGPUSyncTimeout&&(clearTimeout(this.computeDistancesOnGPUSyncTimeout),this.computeDistancesOnGPUSyncTimeout=null),this.disposeDistancesComputationGPUResources()),this.scenes=[],this.distancesTransformFeedback={id:null,vertexShader:null,fragmentShader:null,program:null,centersBuffer:null,sceneIndexesBuffer:null,outDistancesBuffer:null,centersLoc:-1,modelViewProjLoc:-1,sceneIndexesLoc:-1,transformsLocs:[]},this.renderer=null,this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSceneIndexMap=[],this.lastBuildSplatCount=0,this.lastBuildScenes=[],this.lastBuildMaxSplatCount=0,this.lastBuildSceneCount=0,this.firstRenderTime=-1,this.finalBuild=!1,this.webGLUtils=null,this.boundingBox=new Qt,this.calculatedSceneCenter=new F,this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.visibleRegionChanging=!1,this.splatScale=1,this.pointCloudModeEnabled=!1,this.disposed=!0,this.lastRenderer=null,this.visible=!1}disposeMeshData(){this.geometry&&this.geometry!==bo&&(this.geometry.dispose(),this.geometry=null),this.material&&(this.material.dispose(),this.material=null)}disposeTextures(){for(let e in this.splatDataTextures)if(this.splatDataTextures.hasOwnProperty(e)){const t=this.splatDataTextures[e];t.texture&&(t.texture.dispose(),t.texture=null)}this.splatDataTextures=null}disposeSplatTree(){this.splatTree&&(this.splatTree.dispose(),this.splatTree=null),this.baseSplatTree&&(this.baseSplatTree.dispose(),this.baseSplatTree=null)}getSplatTree(){return this.splatTree}onSplatTreeReady(e){this.onSplatTreeReadyCallback=e}getDataForDistancesComputation(e,t){const n=this.integerBasedDistancesComputation?this.getIntegerCenters(e,t,!0):this.getFloatCenters(e,t,!0),s=this.getSceneIndexes(e,t);return{centers:n,sceneIndexes:s}}refreshGPUDataFromSplatBuffers(e){const t=this.getSplatCount(!0);this.refreshDataTexturesFromSplatBuffers(e);const n=e?this.lastBuildSplatCount:0,{centers:s,sceneIndexes:r}=this.getDataForDistancesComputation(n,t-1);return this.enableDistancesComputationOnGPU&&this.refreshGPUBuffersForDistancesComputation(s,r,e),{from:n,to:t-1,count:t-n,centers:s,sceneIndexes:r}}refreshGPUBuffersForDistancesComputation(e,t,n=!1){const s=n?this.lastBuildSplatCount:0;this.updateGPUCentersBufferForDistancesComputation(n,e,s),this.updateGPUTransformIndexesBufferForDistancesComputation(n,t,s)}refreshDataTexturesFromSplatBuffers(e){const t=this.getSplatCount(!0),n=this.lastBuildSplatCount,s=t-1;e?this.updateBaseDataFromSplatBuffers(n,s):(this.setupDataTextures(),this.updateBaseDataFromSplatBuffers()),this.updateDataTexturesFromBaseData(n,s),this.updateVisibleRegion(e)}setupDataTextures(){const e=this.getMaxSplatCount(),t=this.getSplatCount(!0);this.disposeTextures();const n=(C,E)=>{const I=new ge(4096,1024);for(;I.x*I.y*C<e*E;)I.y*=2;return I},s=C=>C>=1?np:ep,r=C=>{const E=s(C),I=n(E,6);return{elementsPerTexelStored:E,texSize:I}};let i=this.getTargetCovarianceCompressionLevel();const o=0,a=this.getTargetSphericalHarmonicsCompressionLevel();let c,d,u;if(this.splatRenderMode===Bt.ThreeD){const C=r(i);C.texSize.x*C.texSize.y>Bo&&i===0&&(i=1),c=new Float32Array(e*cs)}else d=new Float32Array(e*3),u=new Float32Array(e*4);const f=new Float32Array(e*3),h=new Uint8Array(e*4);let g=Float32Array;a===1?g=Uint16Array:a===2&&(g=Uint8Array);const p=An(this.minSphericalHarmonicsDegree),m=this.minSphericalHarmonicsDegree?new g(e*p):void 0,A=n(dr,4),y=new Uint32Array(A.x*A.y*dr);Ge.updateCenterColorsPaddedData(0,t-1,f,h,y);const v=new wt(y,A.x,A.y,Os,Pn);if(v.internalFormat="RGBA32UI",v.needsUpdate=!0,this.material.uniforms.centersColorsTexture.value=v,this.material.uniforms.centersColorsTextureSize.value.copy(A),this.material.uniformsNeedUpdate=!0,this.splatDataTextures={baseData:{covariances:c,scales:d,rotations:u,centers:f,colors:h,sphericalHarmonics:m},centerColors:{data:y,texture:v,size:A}},this.splatRenderMode===Bt.ThreeD){const C=r(i),E=C.elementsPerTexelStored,I=C.texSize;let P=i>=1?Uint32Array:Float32Array;const B=i>=1?sp:tp,M=new P(I.x*I.y*B);i===0?M.set(c):Ge.updatePaddedCompressedCovariancesTextureData(c,M,0,0,c.length);let D;if(i>=1)D=new wt(M,I.x,I.y,Os,Pn),D.internalFormat="RGBA32UI",this.material.uniforms.covariancesTextureHalfFloat.value=D;else{D=new wt(M,I.x,I.y,Ct,Ut),this.material.uniforms.covariancesTexture.value=D;const _=new wt(new Uint32Array(32),2,2,Os,Pn);_.internalFormat="RGBA32UI",this.material.uniforms.covariancesTextureHalfFloat.value=_,_.needsUpdate=!0}D.needsUpdate=!0,this.material.uniforms.covariancesAreHalfFloat.value=i>=1?1:0,this.material.uniforms.covariancesTextureSize.value.copy(I),this.splatDataTextures.covariances={data:M,texture:D,size:I,compressionLevel:i,elementsPerTexelStored:E,elementsPerTexelAllocated:B}}else{const E=n(ur,6);let I=Float32Array,P=Ut;const B=new I(E.x*E.y*ur);Ge.updateScaleRotationsPaddedData(0,t-1,d,u,B);const M=new wt(B,E.x,E.y,Ct,P);M.needsUpdate=!0,this.material.uniforms.scaleRotationsTexture.value=M,this.material.uniforms.scaleRotationsTextureSize.value.copy(E),this.splatDataTextures.scaleRotations={data:B,texture:M,size:E,compressionLevel:o}}if(m){const C=a===2?Wl:jl;let E=p;E%2!==0&&E++;const I=4,P=Ct;let B=n(I,E);if(B.x*B.y<=Bo){const M=B.x*B.y*I,D=new g(M);for(let k=0;k<t;k++){const G=p*k,O=E*k;for(let $=0;$<p;$++)D[O+$]=m[G+$]}const _=new wt(D,B.x,B.y,P,C);_.needsUpdate=!0,this.material.uniforms.sphericalHarmonicsTexture.value=_,this.splatDataTextures.sphericalHarmonics={componentCount:p,paddedComponentCount:E,data:D,textureCount:1,texture:_,size:B,compressionLevel:a,elementsPerTexel:I}}else{const M=p/3;E=M,E%2!==0&&E++,B=n(I,E);const D=B.x*B.y*I,_=[this.material.uniforms.sphericalHarmonicsTextureR,this.material.uniforms.sphericalHarmonicsTextureG,this.material.uniforms.sphericalHarmonicsTextureB],k=[],G=[];for(let O=0;O<3;O++){const $=new g(D);k.push($);for(let Z=0;Z<t;Z++){const V=p*Z,z=E*Z;if(M>=3){for(let ne=0;ne<3;ne++)$[z+ne]=m[V+O*3+ne];if(M>=8)for(let ne=0;ne<5;ne++)$[z+3+ne]=m[V+9+O*5+ne]}}const U=new wt($,B.x,B.y,P,C);G.push(U),U.needsUpdate=!0,_[O].value=U}this.material.uniforms.sphericalHarmonicsMultiTextureMode.value=1,this.splatDataTextures.sphericalHarmonics={componentCount:p,componentCountPerChannel:M,paddedComponentCount:E,data:k,textureCount:3,textures:G,size:B,compressionLevel:a,elementsPerTexel:I}}this.material.uniforms.sphericalHarmonicsTextureSize.value.copy(B),this.material.uniforms.sphericalHarmonics8BitMode.value=a===2?1:0;for(let M=0;M<this.scenes.length;M++){const D=this.scenes[M].splatBuffer;this.material.uniforms.sphericalHarmonics8BitCompressionRangeMin.value[M]=D.minSphericalHarmonicsCoeff,this.material.uniforms.sphericalHarmonics8BitCompressionRangeMax.value[M]=D.maxSphericalHarmonicsCoeff}this.material.uniformsNeedUpdate=!0}const x=n(Io,4),w=new Uint32Array(x.x*x.y*Io);for(let C=0;C<t;C++)w[C]=this.globalSplatIndexToSceneIndexMap[C];const T=new wt(w,x.x,x.y,zl,Pn);T.internalFormat="R32UI",T.needsUpdate=!0,this.material.uniforms.sceneIndexesTexture.value=T,this.material.uniforms.sceneIndexesTextureSize.value.copy(x),this.material.uniformsNeedUpdate=!0,this.splatDataTextures.sceneIndexes={data:w,texture:T,size:x},this.material.uniforms.sceneCount.value=this.scenes.length}updateBaseDataFromSplatBuffers(e,t){const n=this.splatDataTextures.covariances,s=n?n.compressionLevel:void 0,r=this.splatDataTextures.scaleRotations,i=r?r.compressionLevel:void 0,o=this.splatDataTextures.sphericalHarmonics,a=o?o.compressionLevel:0;this.fillSplatDataArrays(this.splatDataTextures.baseData.covariances,this.splatDataTextures.baseData.scales,this.splatDataTextures.baseData.rotations,this.splatDataTextures.baseData.centers,this.splatDataTextures.baseData.colors,this.splatDataTextures.baseData.sphericalHarmonics,void 0,s,i,a,e,t,e)}updateDataTexturesFromBaseData(e,t){const n=this.splatDataTextures.covariances,s=n?n.compressionLevel:void 0,r=this.splatDataTextures.scaleRotations,i=r?r.compressionLevel:void 0,o=this.splatDataTextures.sphericalHarmonics,a=o?o.compressionLevel:0,c=this.splatDataTextures.centerColors,d=c.data,u=c.texture;Ge.updateCenterColorsPaddedData(e,t,this.splatDataTextures.baseData.centers,this.splatDataTextures.baseData.colors,d);const f=this.renderer?this.renderer.properties.get(u):null;if(!f||!f.__webglTexture?u.needsUpdate=!0:this.updateDataTexture(d,c.texture,c.size,f,dr,$f,4,e,t),n){const y=n.texture,v=e*cs,x=t*cs;if(s===0)for(let T=v;T<=x;T++){const C=this.splatDataTextures.baseData.covariances[T];n.data[T]=C}else Ge.updatePaddedCompressedCovariancesTextureData(this.splatDataTextures.baseData.covariances,n.data,e*n.elementsPerTexelAllocated,v,x);const w=this.renderer?this.renderer.properties.get(y):null;!w||!w.__webglTexture?y.needsUpdate=!0:s===0?this.updateDataTexture(n.data,n.texture,n.size,w,n.elementsPerTexelStored,cs,4,e,t):this.updateDataTexture(n.data,n.texture,n.size,w,n.elementsPerTexelAllocated,n.elementsPerTexelAllocated,2,e,t)}if(r){const y=r.data,v=r.texture,x=6,w=i===0?4:2;Ge.updateScaleRotationsPaddedData(e,t,this.splatDataTextures.baseData.scales,this.splatDataTextures.baseData.rotations,y);const T=this.renderer?this.renderer.properties.get(v):null;!T||!T.__webglTexture?v.needsUpdate=!0:this.updateDataTexture(y,r.texture,r.size,T,ur,x,w,e,t)}const h=this.splatDataTextures.baseData.sphericalHarmonics;if(h){let y=4;a===1?y=2:a===2&&(y=1);const v=(T,C,E,I,P)=>{const B=this.renderer?this.renderer.properties.get(T):null;!B||!B.__webglTexture?T.needsUpdate=!0:this.updateDataTexture(I,T,C,B,E,P,y,e,t)},x=o.componentCount,w=o.paddedComponentCount;if(o.textureCount===1){const T=o.data;for(let C=e;C<=t;C++){const E=x*C,I=w*C;for(let P=0;P<x;P++)T[I+P]=h[E+P]}v(o.texture,o.size,o.elementsPerTexel,T,w)}else{const T=o.componentCountPerChannel;for(let C=0;C<3;C++){const E=o.data[C];for(let I=e;I<=t;I++){const P=x*I,B=w*I;if(T>=3){for(let M=0;M<3;M++)E[B+M]=h[P+C*3+M];if(T>=8)for(let M=0;M<5;M++)E[B+3+M]=h[P+9+C*5+M]}}v(o.textures[C],o.size,o.elementsPerTexel,E,w)}}}const g=this.splatDataTextures.sceneIndexes,p=g.data;for(let y=this.lastBuildSplatCount;y<=t;y++)p[y]=this.globalSplatIndexToSceneIndexMap[y];const m=g.texture,A=this.renderer?this.renderer.properties.get(m):null;!A||!A.__webglTexture?m.needsUpdate=!0:this.updateDataTexture(p,g.texture,g.size,A,1,1,1,this.lastBuildSplatCount,t)}getTargetCovarianceCompressionLevel(){return this.halfPrecisionCovariancesOnGPU?1:0}getTargetSphericalHarmonicsCompressionLevel(){return Math.max(1,this.getMaximumSplatBufferCompressionLevel())}getMaximumSplatBufferCompressionLevel(){let e;for(let t=0;t<this.scenes.length;t++){const s=this.getScene(t).splatBuffer;(t===0||s.compressionLevel>e)&&(e=s.compressionLevel)}return e}getMinimumSplatBufferCompressionLevel(){let e;for(let t=0;t<this.scenes.length;t++){const s=this.getScene(t).splatBuffer;(t===0||s.compressionLevel<e)&&(e=s.compressionLevel)}return e}static computeTextureUpdateRegion(e,t,n,s,r){const i=r/s,o=e*i,a=Math.floor(o/n),c=a*n*s,d=t*i,u=Math.floor(d/n),f=u*n*s+n*s;return{dataStart:c,dataEnd:f,startRow:a,endRow:u}}updateDataTexture(e,t,n,s,r,i,o,a,c){const d=this.renderer.getContext(),u=Ge.computeTextureUpdateRegion(a,c,n.x,r,i),f=u.dataEnd-u.dataStart,h=new e.constructor(e.buffer,u.dataStart*o,f),g=u.endRow-u.startRow+1,p=this.webGLUtils.convert(t.type),m=this.webGLUtils.convert(t.format,t.colorSpace),A=d.getParameter(d.TEXTURE_BINDING_2D);d.bindTexture(d.TEXTURE_2D,s.__webglTexture),d.texSubImage2D(d.TEXTURE_2D,0,0,u.startRow,n.x,g,m,p,h),d.bindTexture(d.TEXTURE_2D,A)}static updatePaddedCompressedCovariancesTextureData(e,t,n,s,r){let i=new DataView(t.buffer),o=n,a=0;for(let c=s;c<=r;c+=2)i.setUint16(o*2,e[c],!0),i.setUint16(o*2+2,e[c+1],!0),o+=2,a++,a>=3&&(o+=2,a=0)}static updateCenterColorsPaddedData(e,t,n,s,r){for(let i=e;i<=t;i++){const o=i*4,a=i*3,c=i*4;r[c]=Lh(s,o),r[c+1]=sr(n[a]),r[c+2]=sr(n[a+1]),r[c+3]=sr(n[a+2])}}static updateScaleRotationsPaddedData(e,t,n,s,r){for(let o=e;o<=t;o++){const a=o*3,c=o*4,d=o*6;r[d]=n[a],r[d+1]=n[a+1],r[d+2]=n[a+2],r[d+3]=s[c],r[d+4]=s[c+1],r[d+5]=s[c+2]}}updateVisibleRegion(e){const t=this.getSplatCount(!0),n=new F;if(!e){const r=new F;this.scenes.forEach(i=>{r.add(i.splatBuffer.sceneCenter)}),r.multiplyScalar(1/this.scenes.length),this.calculatedSceneCenter.copy(r),this.material.uniforms.sceneCenter.value.copy(this.calculatedSceneCenter),this.material.uniformsNeedUpdate=!0}const s=e?this.lastBuildSplatCount:0;for(let r=s;r<t;r++){this.getSplatCenter(r,n,!0);const i=n.sub(this.calculatedSceneCenter).length();i>this.maxSplatDistanceFromSceneCenter&&(this.maxSplatDistanceFromSceneCenter=i)}this.maxSplatDistanceFromSceneCenter-this.visibleRegionBufferRadius>Ro&&(this.visibleRegionBufferRadius=this.maxSplatDistanceFromSceneCenter,this.visibleRegionRadius=Math.max(this.visibleRegionBufferRadius-Ro,0)),this.finalBuild&&(this.visibleRegionRadius=this.visibleRegionBufferRadius=this.maxSplatDistanceFromSceneCenter),this.updateVisibleRegionFadeDistance()}updateVisibleRegionFadeDistance(e=Nn.Default){const t=rp*this.sceneFadeInRateMultiplier,n=ip*this.sceneFadeInRateMultiplier,s=this.finalBuild?t:n,r=e===Nn.Default?s:n;this.visibleRegionFadeStartRadius=(this.visibleRegionRadius-this.visibleRegionFadeStartRadius)*r+this.visibleRegionFadeStartRadius;const o=(this.visibleRegionBufferRadius>0?this.visibleRegionFadeStartRadius/this.visibleRegionBufferRadius:0)>.99,a=o||e===Nn.Instant?1:0;this.material.uniforms.visibleRegionFadeStartRadius.value=this.visibleRegionFadeStartRadius,this.material.uniforms.visibleRegionRadius.value=this.visibleRegionRadius,this.material.uniforms.firstRenderTime.value=this.firstRenderTime,this.material.uniforms.currentTime.value=performance.now(),this.material.uniforms.fadeInComplete.value=a,this.material.uniformsNeedUpdate=!0,this.visibleRegionChanging=!o}updateRenderIndexes(e,t){const n=this.geometry;n.attributes.splatIndex.set(e),n.attributes.splatIndex.needsUpdate=!0,t>0&&this.firstRenderTime===-1&&(this.firstRenderTime=performance.now()),n.instanceCount=t,n.setDrawRange(0,t)}updateTransforms(){for(let e=0;e<this.scenes.length;e++)this.getScene(e).updateTransform(this.dynamicMode)}updateUniforms=function(){const e=new ge;return function(t,n,s,r,i,o){if(this.getSplatCount()>0){if(e.set(t.x*this.devicePixelRatio,t.y*this.devicePixelRatio),this.material.uniforms.viewport.value.copy(e),this.material.uniforms.basisViewport.value.set(1/e.x,1/e.y),this.material.uniforms.focal.value.set(n,s),this.material.uniforms.orthographicMode.value=r?1:0,this.material.uniforms.orthoZoom.value=i,this.material.uniforms.inverseFocalAdjustment.value=o,this.dynamicMode)for(let c=0;c<this.scenes.length;c++)this.material.uniforms.transforms.value[c].copy(this.getScene(c).transform);if(this.enableOptionalEffects)for(let c=0;c<this.scenes.length;c++)this.material.uniforms.sceneOpacity.value[c]=Le(this.getScene(c).opacity,0,1),this.material.uniforms.sceneVisibility.value[c]=this.getScene(c).visible?1:0,this.material.uniformsNeedUpdate=!0;this.material.uniformsNeedUpdate=!0}}}();setSplatScale(e=1){this.splatScale=e,this.material.uniforms.splatScale.value=e,this.material.uniformsNeedUpdate=!0}getSplatScale(){return this.splatScale}setPointCloudModeEnabled(e){this.pointCloudModeEnabled=e,this.material.uniforms.pointCloudModeEnabled.value=e?1:0,this.material.uniformsNeedUpdate=!0}getPointCloudModeEnabled(){return this.pointCloudModeEnabled}getSplatDataTextures(){return this.splatDataTextures}getSplatCount(e=!1){return e?Ge.getTotalSplatCountForScenes(this.scenes):this.lastBuildSplatCount}static getTotalSplatCountForScenes(e){let t=0;for(let n of e)n&&n.splatBuffer&&(t+=n.splatBuffer.getSplatCount());return t}static getTotalSplatCountForSplatBuffers(e){let t=0;for(let n of e)t+=n.getSplatCount();return t}getMaxSplatCount(){return Ge.getTotalMaxSplatCountForScenes(this.scenes)}static getTotalMaxSplatCountForScenes(e){let t=0;for(let n of e)n&&n.splatBuffer&&(t+=n.splatBuffer.getMaxSplatCount());return t}static getTotalMaxSplatCountForSplatBuffers(e){let t=0;for(let n of e)t+=n.getMaxSplatCount();return t}disposeDistancesComputationGPUResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.vao&&(e.deleteVertexArray(this.distancesTransformFeedback.vao),this.distancesTransformFeedback.vao=null),this.distancesTransformFeedback.program&&(e.deleteProgram(this.distancesTransformFeedback.program),e.deleteShader(this.distancesTransformFeedback.vertexShader),e.deleteShader(this.distancesTransformFeedback.fragmentShader),this.distancesTransformFeedback.program=null,this.distancesTransformFeedback.vertexShader=null,this.distancesTransformFeedback.fragmentShader=null),this.disposeDistancesComputationGPUBufferResources(),this.distancesTransformFeedback.id&&(e.deleteTransformFeedback(this.distancesTransformFeedback.id),this.distancesTransformFeedback.id=null)}disposeDistancesComputationGPUBufferResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.centersBuffer&&(this.distancesTransformFeedback.centersBuffer=null,e.deleteBuffer(this.distancesTransformFeedback.centersBuffer)),this.distancesTransformFeedback.outDistancesBuffer&&(e.deleteBuffer(this.distancesTransformFeedback.outDistancesBuffer),this.distancesTransformFeedback.outDistancesBuffer=null)}setRenderer(e){if(e!==this.renderer){this.renderer=e;const t=this.renderer.getContext(),n=new Yf(t),s=new Zf(t,n,{});if(n.init(s),this.webGLUtils=new Hl(t,n),this.enableDistancesComputationOnGPU&&this.getSplatCount()>0){this.setupDistancesComputationTransformFeedback();const{centers:r,sceneIndexes:i}=this.getDataForDistancesComputation(0,this.getSplatCount()-1);this.refreshGPUBuffersForDistancesComputation(r,i)}}}setupDistancesComputationTransformFeedback=function(){let e;return function(){const t=this.getMaxSplatCount();if(!this.renderer)return;const n=this.lastRenderer!==this.renderer,s=e!==t;if(!n&&!s)return;n?this.disposeDistancesComputationGPUResources():s&&this.disposeDistancesComputationGPUBufferResources();const r=this.renderer.getContext(),i=(f,h,g)=>{const p=f.createShader(h);if(!p)return console.error("Fatal error: gl could not create a shader object."),null;if(f.shaderSource(p,g),f.compileShader(p),!f.getShaderParameter(p,f.COMPILE_STATUS)){let A="unknown";h===f.VERTEX_SHADER?A="vertex shader":h===f.FRAGMENT_SHADER&&(A="fragement shader");const y=f.getShaderInfoLog(p);return console.error("Failed to compile "+A+" with these errors:"+y),f.deleteShader(p),null}return p};let o;this.integerBasedDistancesComputation?(o=`#version 300 es
                in ivec4 center;
                flat out int distance;`,this.dynamicMode?o+=`
                        in uint sceneIndex;
                        uniform ivec4 transforms[${Ee.MaxScenes}];
                        void main(void) {
                            ivec4 transform = transforms[sceneIndex];
                            distance = center.x * transform.x + center.y * transform.y + center.z * transform.z + transform.w * center.w;
                        }
                    `:o+=`
                        uniform ivec3 modelViewProj;
                        void main(void) {
                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;
                        }
                    `):(o=`#version 300 es
                in vec4 center;
                flat out float distance;`,this.dynamicMode?o+=`
                        in uint sceneIndex;
                        uniform mat4 transforms[${Ee.MaxScenes}];
                        void main(void) {
                            vec4 transformedCenter = transforms[sceneIndex] * vec4(center.xyz, 1.0);
                            distance = transformedCenter.z;
                        }
                    `:o+=`
                        uniform vec3 modelViewProj;
                        void main(void) {
                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;
                        }
                    `);const a=`#version 300 es
                precision lowp float;
                out vec4 fragColor;
                void main(){}
            `,c=r.getParameter(r.VERTEX_ARRAY_BINDING),d=r.getParameter(r.CURRENT_PROGRAM),u=d?r.getProgramParameter(d,r.DELETE_STATUS):!1;if(n&&(this.distancesTransformFeedback.vao=r.createVertexArray()),r.bindVertexArray(this.distancesTransformFeedback.vao),n){const f=r.createProgram(),h=i(r,r.VERTEX_SHADER,o),g=i(r,r.FRAGMENT_SHADER,a);if(!h||!g)throw new Error("Could not compile shaders for distances computation on GPU.");if(r.attachShader(f,h),r.attachShader(f,g),r.transformFeedbackVaryings(f,["distance"],r.SEPARATE_ATTRIBS),r.linkProgram(f),!r.getProgramParameter(f,r.LINK_STATUS)){const m=r.getProgramInfoLog(f);throw console.error("Fatal error: Failed to link program: "+m),r.deleteProgram(f),r.deleteShader(g),r.deleteShader(h),new Error("Could not link shaders for distances computation on GPU.")}this.distancesTransformFeedback.program=f,this.distancesTransformFeedback.vertexShader=h,this.distancesTransformFeedback.vertexShader=g}if(r.useProgram(this.distancesTransformFeedback.program),this.distancesTransformFeedback.centersLoc=r.getAttribLocation(this.distancesTransformFeedback.program,"center"),this.dynamicMode){this.distancesTransformFeedback.sceneIndexesLoc=r.getAttribLocation(this.distancesTransformFeedback.program,"sceneIndex");for(let f=0;f<this.scenes.length;f++)this.distancesTransformFeedback.transformsLocs[f]=r.getUniformLocation(this.distancesTransformFeedback.program,`transforms[${f}]`)}else this.distancesTransformFeedback.modelViewProjLoc=r.getUniformLocation(this.distancesTransformFeedback.program,"modelViewProj");(n||s)&&(this.distancesTransformFeedback.centersBuffer=r.createBuffer(),r.bindBuffer(r.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),r.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?r.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,r.INT,0,0):r.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,4,r.FLOAT,!1,0,0),this.dynamicMode&&(this.distancesTransformFeedback.sceneIndexesBuffer=r.createBuffer(),r.bindBuffer(r.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),r.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc),r.vertexAttribIPointer(this.distancesTransformFeedback.sceneIndexesLoc,1,r.UNSIGNED_INT,0,0))),(n||s)&&(this.distancesTransformFeedback.outDistancesBuffer=r.createBuffer()),r.bindBuffer(r.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),r.bufferData(r.ARRAY_BUFFER,t*4,r.STATIC_READ),n&&(this.distancesTransformFeedback.id=r.createTransformFeedback()),r.bindTransformFeedback(r.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),r.bindBufferBase(r.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),d&&u!==!0&&r.useProgram(d),c&&r.bindVertexArray(c),this.lastRenderer=this.renderer,e=t}}();updateGPUCentersBufferForDistancesComputation(e,t,n){if(!this.renderer)return;const s=this.renderer.getContext(),r=s.getParameter(s.VERTEX_ARRAY_BINDING);s.bindVertexArray(this.distancesTransformFeedback.vao);const i=this.integerBasedDistancesComputation?Uint32Array:Float32Array,o=16,a=n*o;if(s.bindBuffer(s.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),e)s.bufferSubData(s.ARRAY_BUFFER,a,t);else{const c=new i(this.getMaxSplatCount()*o);c.set(t),s.bufferData(s.ARRAY_BUFFER,c,s.STATIC_DRAW)}s.bindBuffer(s.ARRAY_BUFFER,null),r&&s.bindVertexArray(r)}updateGPUTransformIndexesBufferForDistancesComputation(e,t,n){if(!this.renderer||!this.dynamicMode)return;const s=this.renderer.getContext(),r=s.getParameter(s.VERTEX_ARRAY_BINDING);s.bindVertexArray(this.distancesTransformFeedback.vao);const i=n*4;if(s.bindBuffer(s.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),e)s.bufferSubData(s.ARRAY_BUFFER,i,t);else{const o=new Uint32Array(this.getMaxSplatCount()*4);o.set(t),s.bufferData(s.ARRAY_BUFFER,o,s.STATIC_DRAW)}s.bindBuffer(s.ARRAY_BUFFER,null),r&&s.bindVertexArray(r)}getSceneIndexes(e,t){let n;const s=t-e+1;n=new Uint32Array(s);for(let r=e;r<=t;r++)n[r]=this.globalSplatIndexToSceneIndexMap[r];return n}fillTransformsArray=function(){const e=[];return function(t){e.length!==t.length&&(e.length=t.length);for(let n=0;n<this.scenes.length;n++){const r=this.getScene(n).transform.elements;for(let i=0;i<16;i++)e[n*16+i]=r[i]}t.set(e)}}();computeDistancesOnGPU=function(){const e=new he;return function(t,n){if(!this.renderer)return;const s=this.renderer.getContext(),r=s.getParameter(s.VERTEX_ARRAY_BINDING),i=s.getParameter(s.CURRENT_PROGRAM),o=i?s.getProgramParameter(i,s.DELETE_STATUS):!1;if(s.bindVertexArray(this.distancesTransformFeedback.vao),s.useProgram(this.distancesTransformFeedback.program),s.enable(s.RASTERIZER_DISCARD),this.dynamicMode)for(let d=0;d<this.scenes.length;d++)if(e.copy(this.getScene(d).transform),e.premultiply(t),this.integerBasedDistancesComputation){const u=Ge.getIntegerMatrixArray(e),f=[u[2],u[6],u[10],u[14]];s.uniform4i(this.distancesTransformFeedback.transformsLocs[d],f[0],f[1],f[2],f[3])}else s.uniformMatrix4fv(this.distancesTransformFeedback.transformsLocs[d],!1,e.elements);else if(this.integerBasedDistancesComputation){const d=Ge.getIntegerMatrixArray(t),u=[d[2],d[6],d[10]];s.uniform3i(this.distancesTransformFeedback.modelViewProjLoc,u[0],u[1],u[2])}else{const d=[t.elements[2],t.elements[6],t.elements[10]];s.uniform3f(this.distancesTransformFeedback.modelViewProjLoc,d[0],d[1],d[2])}s.bindBuffer(s.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),s.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?s.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,s.INT,0,0):s.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,4,s.FLOAT,!1,0,0),this.dynamicMode&&(s.bindBuffer(s.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),s.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc),s.vertexAttribIPointer(this.distancesTransformFeedback.sceneIndexesLoc,1,s.UNSIGNED_INT,0,0)),s.bindTransformFeedback(s.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),s.beginTransformFeedback(s.POINTS),s.drawArrays(s.POINTS,0,this.getSplatCount()),s.endTransformFeedback(),s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER,0,null),s.bindTransformFeedback(s.TRANSFORM_FEEDBACK,null),s.disable(s.RASTERIZER_DISCARD);const a=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);s.flush();const c=new Promise(d=>{const u=()=>{if(this.disposed)d();else switch(s.clientWaitSync(a,0,0)){case s.TIMEOUT_EXPIRED:return this.computeDistancesOnGPUSyncTimeout=setTimeout(u),this.computeDistancesOnGPUSyncTimeout;case s.WAIT_FAILED:throw new Error("should never get here");default:this.computeDistancesOnGPUSyncTimeout=null,s.deleteSync(a);const p=s.getParameter(s.VERTEX_ARRAY_BINDING);s.bindVertexArray(this.distancesTransformFeedback.vao),s.bindBuffer(s.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),s.getBufferSubData(s.ARRAY_BUFFER,0,n),s.bindBuffer(s.ARRAY_BUFFER,null),p&&s.bindVertexArray(p),d()}};this.computeDistancesOnGPUSyncTimeout=setTimeout(u)});return i&&o!==!0&&s.useProgram(i),r&&s.bindVertexArray(r),c}}();getLocalSplatParameters(e,t,n){n==null&&(n=!this.dynamicMode),t.splatBuffer=this.getSplatBufferForSplat(e),t.localIndex=this.getSplatLocalIndex(e),t.sceneTransform=n?this.getSceneTransformForSplat(e):null}fillSplatDataArrays(e,t,n,s,r,i,o,a=0,c=0,d=1,u,f,h=0,g){const p=new F;p.x=void 0,p.y=void 0,this.splatRenderMode===Bt.ThreeD?p.z=void 0:p.z=1;const m=new he;let A=0,y=this.scenes.length-1;g!=null&&g>=0&&g<=this.scenes.length&&(A=g,y=g);for(let v=A;v<=y;v++){o==null&&(o=!this.dynamicMode);const x=this.getScene(v),w=x.splatBuffer;let T;if(o&&(this.getSceneTransform(v,m),T=m),e&&w.fillSplatCovarianceArray(e,T,u,f,h,a),t||n){if(!t||!n)throw new Error('SplatMesh::fillSplatDataArrays() -> "scales" and "rotations" must both be valid.');w.fillSplatScaleRotationArray(t,n,T,u,f,h,c,p)}s&&w.fillSplatCenterArray(s,T,u,f,h),r&&w.fillSplatColorArray(r,x.minimumAlpha,u,f,h),i&&w.fillSphericalHarmonicsArray(i,this.minSphericalHarmonicsDegree,T,u,f,h,d),h+=w.getSplatCount()}}getIntegerCenters(e,t,n=!1){const s=t-e+1,r=new Float32Array(s*3);this.fillSplatDataArrays(null,null,null,r,null,null,void 0,void 0,void 0,void 0,e);let i,o=n?4:3;i=new Int32Array(s*o);for(let a=0;a<s;a++){for(let c=0;c<3;c++)i[a*o+c]=Math.round(r[a*3+c]*1e3);n&&(i[a*o+3]=1e3)}return i}getFloatCenters(e,t,n=!1){const s=t-e+1,r=new Float32Array(s*3);if(this.fillSplatDataArrays(null,null,null,r,null,null,void 0,void 0,void 0,void 0,e),!n)return r;let i=new Float32Array(s*4);for(let o=0;o<s;o++){for(let a=0;a<3;a++)i[o*4+a]=r[o*3+a];i[o*4+3]=1}return i}getSplatCenter=function(){const e={};return function(t,n,s){this.getLocalSplatParameters(t,e,s),e.splatBuffer.getSplatCenter(e.localIndex,n,e.sceneTransform)}}();getSplatScaleAndRotation=function(){const e={},t=new F;return function(n,s,r,i){this.getLocalSplatParameters(n,e,i),t.x=void 0,t.y=void 0,t.z=void 0,this.splatRenderMode===Bt.TwoD&&(t.z=0),e.splatBuffer.getSplatScaleAndRotation(e.localIndex,s,r,e.sceneTransform,t)}}();getSplatColor=function(){const e={};return function(t,n){this.getLocalSplatParameters(t,e),e.splatBuffer.getSplatColor(e.localIndex,n)}}();getSceneTransform(e,t){const n=this.getScene(e);n.updateTransform(this.dynamicMode),t.copy(n.transform)}getScene(e){if(e<0||e>=this.scenes.length)throw new Error("SplatMesh::getScene() -> Invalid scene index.");return this.scenes[e]}getSceneCount(){return this.scenes.length}getSplatBufferForSplat(e){return this.getScene(this.globalSplatIndexToSceneIndexMap[e]).splatBuffer}getSceneIndexForSplat(e){return this.globalSplatIndexToSceneIndexMap[e]}getSceneTransformForSplat(e){return this.getScene(this.globalSplatIndexToSceneIndexMap[e]).transform}getSplatLocalIndex(e){return this.globalSplatIndexToLocalSplatIndexMap[e]}static getIntegerMatrixArray(e){const t=e.elements,n=[];for(let s=0;s<16;s++)n[s]=Math.round(t[s]*1e3);return n}computeBoundingBox(e=!1,t){let n=this.getSplatCount();if(t!=null){if(t<0||t>=this.scenes.length)throw new Error("SplatMesh::computeBoundingBox() -> Invalid scene index.");n=this.scenes[t].splatBuffer.getSplatCount()}const s=new Float32Array(n*3);this.fillSplatDataArrays(null,null,null,s,null,null,e,void 0,void 0,void 0,void 0,t);const r=new F,i=new F;for(let o=0;o<n;o++){const a=o*3,c=s[a],d=s[a+1],u=s[a+2];(o===0||c<r.x)&&(r.x=c),(o===0||d<r.y)&&(r.y=d),(o===0||u<r.z)&&(r.z=u),(o===0||c>i.x)&&(i.x=c),(o===0||d>i.y)&&(i.y=d),(o===0||u>i.z)&&(i.z=u)}return new Qt(r,i)}}var op="AGFzbQEAAAAADwhkeWxpbmsuMAEEAAAAAAEbA2AAAGAQf39/f39/f39/f39/f39/fwBgAAF/AhIBA2VudgZtZW1vcnkCAwCAgAQDBAMAAQIHVAQRX193YXNtX2NhbGxfY3RvcnMAABhfX3dhc21fYXBwbHlfZGF0YV9yZWxvY3MAAAtzb3J0SW5kZXhlcwABE2Vtc2NyaXB0ZW5fdGxzX2luaXQAAgqWEAMDAAELihAEAXwDewN/A30gCyAKayEMAkACQCAOBEAgDQRAQfj///8HIQpBiICAgHghDSALIAxNDQMgDCEBA0AgAyABQQJ0IgVqIAIgACAFaigCAEECdGooAgAiBTYCACAFIAogBSAKSBshCiAFIA0gBSANShshDSABQQFqIgEgC0cNAAsMAwsgDwRAIAsgDE0NAkF/IQ9B+P///wchCkGIgICAeCENIAwhAgNAIA8gByAAIAJBAnQiFWooAgAiFkECdGooAgAiFEcEQAJ/IAX9CQI4IAggFEEGdGoiDv0JAgwgDioCHP0gASAOKgIs/SACIA4qAjz9IAP95gEgBf0JAiggDv0JAgggDioCGP0gASAOKgIo/SACIA4qAjj9IAP95gEgBf0JAgggDv0JAgAgDioCEP0gASAOKgIg/SACIA4qAjD9IAP95gEgBf0JAhggDv0JAgQgDioCFP0gASAOKgIk/SACIA4qAjT9IAP95gH95AH95AH95AEiEf1f/QwAAAAAAECPQAAAAAAAQI9AIhL98gEiE/0hASIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAshDgJ/IBP9IQAiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgL/REgDv0cAQJ/IBEgEf0NCAkKCwwNDg8AAAAAAAAAAP1fIBL98gEiEf0hACIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAv9HAICfyAR/SEBIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4C/0cAyESIBQhDwsgAyAVaiABIBZBBHRq/QAAACAS/bUBIhH9GwAgEf0bAWogEf0bAmogEf0bA2oiDjYCACAOIAogCiAOShshCiAOIA0gDSAOSBshDSACQQFqIgIgC0cNAAsMAwsCfyAFKgIIu/0UIAUqAhi7/SIB/QwAAAAAAECPQAAAAAAAQI9A/fIBIhH9IQEiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIQ4CfyAR/SEAIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyECAn8gBSoCKLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEFQfj///8HIQpBiICAgHghDSALIAxNDQIgAv0RIA79HAEgBf0cAiESIAwhBQNAIAMgBUECdCICaiABIAAgAmooAgBBBHRq/QAAACAS/bUBIhH9GwAgEf0bAWogEf0bAmoiAjYCACACIAogAiAKSBshCiACIA0gAiANShshDSAFQQFqIgUgC0cNAAsMAgsgDQRAQfj///8HIQpBiICAgHghDSALIAxNDQIgDCEBA0AgAyABQQJ0IgVqAn8gAiAAIAVqKAIAQQJ0aioCALtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyIONgIAIAogDiAKIA5IGyEKIA0gDiANIA5KGyENIAFBAWoiASALRw0ACwwCCyAPRQRAIAsgDE0NASAFKgIoIRcgBSoCGCEYIAUqAgghGUH4////ByEKQYiAgIB4IQ0gDCEFA0ACfyAXIAEgACAFQQJ0IgdqKAIAQQR0aiICKgIIlCAZIAIqAgCUIBggAioCBJSSkrtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEOIAMgB2ogDjYCACAKIA4gCiAOSBshCiANIA4gDSAOShshDSAFQQFqIgUgC0cNAAsMAgsgCyAMTQ0AQX8hD0H4////ByEKQYiAgIB4IQ0gDCECA0AgDyAHIAAgAkECdCIUaigCAEECdCIVaigCACIORwRAIAX9CQI4IAggDkEGdGoiD/0JAgwgDyoCHP0gASAPKgIs/SACIA8qAjz9IAP95gEgBf0JAiggD/0JAgggDyoCGP0gASAPKgIo/SACIA8qAjj9IAP95gEgBf0JAgggD/0JAgAgDyoCEP0gASAPKgIg/SACIA8qAjD9IAP95gEgBf0JAhggD/0JAgQgDyoCFP0gASAPKgIk/SACIA8qAjT9IAP95gH95AH95AH95AEhESAOIQ8LIAMgFGoCfyAR/R8DIAEgFUECdCIOQQxyaioCAJQgEf0fAiABIA5BCHJqKgIAlCAR/R8AIAEgDmoqAgCUIBH9HwEgASAOQQRyaioCAJSSkpK7RAAAAAAAALBAoiIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAsiDjYCACAKIA4gCiAOSBshCiANIA4gDSAOShshDSACQQFqIgIgC0cNAAsMAQtBiICAgHghDUH4////ByEKCyALIAxLBEAgCUEBa7MgDbIgCrKTlSEXIAwhDQNAAn8gFyADIA1BAnRqIgEoAgAgCmuylCIYi0MAAABPXQRAIBioDAELQYCAgIB4CyEOIAEgDjYCACAEIA5BAnRqIgEgASgCAEEBajYCACANQQFqIg0gC0cNAAsLIAlBAk8EQCAEKAIAIQ1BASEKA0AgBCAKQQJ0aiIBIAEoAgAgDWoiDTYCACAKQQFqIgogCUcNAAsLIAxBAEoEQCAMIQoDQCAGIApBAWsiAUECdCICaiAAIAJqKAIANgIAIApBAUshAiABIQogAg0ACwsgCyAMSgRAIAshCgNAIAYgCyAEIAMgCkEBayIKQQJ0IgFqKAIAQQJ0aiICKAIAIgVrQQJ0aiAAIAFqKAIANgIAIAIgBUEBazYCACAKIAxKDQALCwsEAEEACw==",Po="AGFzbQEAAAAADwhkeWxpbmsuMAEEAAAAAAEXAmAAAGAQf39/f39/f39/f39/f39/fwACEgEDZW52Bm1lbW9yeQIDAICABAMDAgABBz4DEV9fd2FzbV9jYWxsX2N0b3JzAAAYX193YXNtX2FwcGx5X2RhdGFfcmVsb2NzAAALc29ydEluZGV4ZXMAAQqiDwICAAucDwMBfAd9Bn8gCyAKayEMAkACQCAOBEAgDQRAQfj///8HIQpBiICAgHghDSALIAxNDQMgDCEFA0AgAyAFQQJ0IgFqIAIgACABaigCAEECdGooAgAiATYCACABIAogASAKSBshCiABIA0gASANShshDSAFQQFqIgUgC0cNAAsMAwsgDwRAIAsgDE0NAkF/IQ9B+P///wchCkGIgICAeCENIAwhAgNAIA8gByAAIAJBAnQiGmooAgBBAnQiG2ooAgAiDkcEQAJ/IAUqAjgiESAIIA5BBnRqIg8qAjyUIAUqAigiEiAPKgI4lCAFKgIIIhMgDyoCMJQgBSoCGCIUIA8qAjSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIRgCfyARIA8qAiyUIBIgDyoCKJQgEyAPKgIglCAUIA8qAiSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIRkCfyARIA8qAhyUIBIgDyoCGJQgEyAPKgIQlCAUIA8qAhSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIRwCfyARIA8qAgyUIBIgDyoCCJQgEyAPKgIAlCAUIA8qAgSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIR0gDiEPCyADIBpqIAEgG0ECdGoiDigCBCAcbCAOKAIAIB1saiAOKAIIIBlsaiAOKAIMIBhsaiIONgIAIA4gCiAKIA5KGyEKIA4gDSANIA5IGyENIAJBAWoiAiALRw0ACwwDCwJ/IAUqAii7RAAAAAAAQI9AoiIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAshAgJ/IAUqAhi7RAAAAAAAQI9AoiIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAshByALIAxNAn8gBSoCCLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEPQfj///8HIQpBiICAgHghDQ0CIAwhBQNAIAMgBUECdCIIaiABIAAgCGooAgBBBHRqIggoAgQgB2wgCCgCACAPbGogCCgCCCACbGoiCDYCACAIIAogCCAKSBshCiAIIA0gCCANShshDSAFQQFqIgUgC0cNAAsMAgsgDQRAQfj///8HIQpBiICAgHghDSALIAxNDQIgDCEFA0AgAyAFQQJ0IgFqAn8gAiAAIAFqKAIAQQJ0aioCALtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyIONgIAIAogDiAKIA5IGyEKIA0gDiANIA5KGyENIAVBAWoiBSALRw0ACwwCCyAPRQRAIAsgDE0NASAFKgIoIREgBSoCGCESIAUqAgghE0H4////ByEKQYiAgIB4IQ0gDCEFA0ACfyARIAEgACAFQQJ0IgdqKAIAQQR0aiICKgIIlCATIAIqAgCUIBIgAioCBJSSkrtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEOIAMgB2ogDjYCACAKIA4gCiAOSBshCiANIA4gDSAOShshDSAFQQFqIgUgC0cNAAsMAgsgCyAMTQ0AQX8hD0H4////ByEKQYiAgIB4IQ0gDCECA0AgDyAHIAAgAkECdCIYaigCAEECdCIZaigCACIORwRAIAUqAjgiESAIIA5BBnRqIg8qAjyUIAUqAigiEiAPKgI4lCAFKgIIIhMgDyoCMJQgBSoCGCIUIA8qAjSUkpKSIRUgESAPKgIslCASIA8qAiiUIBMgDyoCIJQgFCAPKgIklJKSkiEWIBEgDyoCHJQgEiAPKgIYlCATIA8qAhCUIBQgDyoCFJSSkpIhFyARIA8qAgyUIBIgDyoCCJQgEyAPKgIAlCAUIA8qAgSUkpKSIREgDiEPCyADIBhqAn8gFSABIBlBAnRqIg4qAgyUIBYgDioCCJQgESAOKgIAlCAXIA4qAgSUkpKSu0QAAAAAAACwQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIg42AgAgCiAOIAogDkgbIQogDSAOIA0gDkobIQ0gAkEBaiICIAtHDQALDAELQYiAgIB4IQ1B+P///wchCgsgCyAMSwRAIAlBAWuzIA2yIAqyk5UhESAMIQ0DQAJ/IBEgAyANQQJ0aiIBKAIAIAprspQiEotDAAAAT10EQCASqAwBC0GAgICAeAshDiABIA42AgAgBCAOQQJ0aiIBIAEoAgBBAWo2AgAgDUEBaiINIAtHDQALCyAJQQJPBEAgBCgCACENQQEhCgNAIAQgCkECdGoiASABKAIAIA1qIg02AgAgCkEBaiIKIAlHDQALCyAMQQBKBEAgDCEKA0AgBiAKQQFrIgFBAnQiAmogACACaigCADYCACAKQQFLIAEhCg0ACwsgCyAMSgRAIAshCgNAIAYgCyAEIAMgCkEBayIKQQJ0IgFqKAIAQQJ0aiICKAIAIgVrQQJ0aiAAIAFqKAIANgIAIAIgBUEBazYCACAKIAxKDQALCws=",ap="AGFzbQEAAAAADwhkeWxpbmsuMAEEAAAAAAEXAmAAAGAQf39/f39/f39/f39/f39/fwACDwEDZW52Bm1lbW9yeQIAAAMDAgABBz4DEV9fd2FzbV9jYWxsX2N0b3JzAAAYX193YXNtX2FwcGx5X2RhdGFfcmVsb2NzAAALc29ydEluZGV4ZXMAAQrrDwICAAvlDwQBfAN7B30DfyALIAprIQwCQAJAIA4EQCANBEBB+P///wchCkGIgICAeCENIAsgDE0NAyAMIQUDQCADIAVBAnQiAWogAiAAIAFqKAIAQQJ0aigCACIBNgIAIAEgCiABIApIGyEKIAEgDSABIA1KGyENIAVBAWoiBSALRw0ACwwDCyAPBEAgCyAMTQ0CQX8hD0H4////ByEKQYiAgIB4IQ0gDCECA0AgDyAHIAAgAkECdCIcaigCACIdQQJ0aigCACIbRwRAAn8gBf0JAjggCCAbQQZ0aiIO/QkCDCAOKgIc/SABIA4qAiz9IAIgDioCPP0gA/3mASAF/QkCKCAO/QkCCCAOKgIY/SABIA4qAij9IAIgDioCOP0gA/3mASAF/QkCCCAO/QkCACAOKgIQ/SABIA4qAiD9IAIgDioCMP0gA/3mASAF/QkCGCAO/QkCBCAOKgIU/SABIA4qAiT9IAIgDioCNP0gA/3mAf3kAf3kAf3kASIR/V/9DAAAAAAAQI9AAAAAAABAj0AiEv3yASIT/SEBIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEOAn8gE/0hACIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAv9ESAO/RwBAn8gESAR/Q0ICQoLDA0ODwABAgMAAQID/V8gEv3yASIR/SEAIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4C/0cAgJ/IBH9IQEiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgL/RwDIRIgGyEPCyADIBxqIAEgHUEEdGr9AAAAIBL9tQEiEf0bACAR/RsBaiAR/RsCaiAR/RsDaiIONgIAIA4gCiAKIA5KGyEKIA4gDSANIA5IGyENIAJBAWoiAiALRw0ACwwDCwJ/IAUqAgi7/RQgBSoCGLv9IgH9DAAAAAAAQI9AAAAAAABAj0D98gEiEf0hASIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAshDgJ/IBH9IQAiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLAn8gBSoCKLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEFQfj///8HIQpBiICAgHghDSALIAxNDQL9ESAO/RwBIAX9HAIhEiAMIQUDQCADIAVBAnQiAmogASAAIAJqKAIAQQR0av0AAAAgEv21ASIR/RsAIBH9GwFqIBH9GwJqIgI2AgAgAiAKIAIgCkgbIQogAiANIAIgDUobIQ0gBUEBaiIFIAtHDQALDAILIA0EQEH4////ByEKQYiAgIB4IQ0gCyAMTQ0CIAwhBQNAIAMgBUECdCIBagJ/IAIgACABaigCAEECdGoqAgC7RAAAAAAAALBAoiIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAsiDjYCACAKIA4gCiAOSBshCiANIA4gDSAOShshDSAFQQFqIgUgC0cNAAsMAgsgD0UEQCALIAxNDQEgBSoCKCEUIAUqAhghFSAFKgIIIRZB+P///wchCkGIgICAeCENIAwhBQNAAn8gFCABIAAgBUECdCIHaigCAEEEdGoiAioCCJQgFiACKgIAlCAVIAIqAgSUkpK7RAAAAAAAALBAoiIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAshDiADIAdqIA42AgAgCiAOIAogDkgbIQogDSAOIA0gDkobIQ0gBUEBaiIFIAtHDQALDAILIAsgDE0NAEF/IQ9B+P///wchCkGIgICAeCENIAwhAgNAIA8gByAAIAJBAnQiG2ooAgBBAnQiHGooAgAiDkcEQCAFKgI4IhQgCCAOQQZ0aiIPKgI8lCAFKgIoIhUgDyoCOJQgBSoCCCIWIA8qAjCUIAUqAhgiFyAPKgI0lJKSkiEYIBQgDyoCLJQgFSAPKgIolCAWIA8qAiCUIBcgDyoCJJSSkpIhGSAUIA8qAhyUIBUgDyoCGJQgFiAPKgIQlCAXIA8qAhSUkpKSIRogFCAPKgIMlCAVIA8qAgiUIBYgDyoCAJQgFyAPKgIElJKSkiEUIA4hDwsgAyAbagJ/IBggASAcQQJ0aiIOKgIMlCAZIA4qAgiUIBQgDioCAJQgGiAOKgIElJKSkrtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyIONgIAIAogDiAKIA5IGyEKIA0gDiANIA5KGyENIAJBAWoiAiALRw0ACwwBC0GIgICAeCENQfj///8HIQoLIAsgDEsEQCAJQQFrsyANsiAKspOVIRQgDCENA0ACfyAUIAMgDUECdGoiASgCACAKa7KUIhWLQwAAAE9dBEAgFagMAQtBgICAgHgLIQ4gASAONgIAIAQgDkECdGoiASABKAIAQQFqNgIAIA1BAWoiDSALRw0ACwsgCUECTwRAIAQoAgAhDUEBIQoDQCAEIApBAnRqIgEgASgCACANaiINNgIAIApBAWoiCiAJRw0ACwsgDEEASgRAIAwhCgNAIAYgCkEBayIBQQJ0IgJqIAAgAmooAgA2AgAgCkEBSyABIQoNAAsLIAsgDEoEQCALIQoDQCAGIAsgBCADIApBAWsiCkECdCIBaigCAEECdGoiAigCACIFa0ECdGogACABaigCADYCACACIAVBAWs2AgAgCiAMSg0ACwsL",lp="AGFzbQEAAAAADwhkeWxpbmsuMAEEAAAAAAEXAmAAAGAQf39/f39/f39/f39/f39/fwACDwEDZW52Bm1lbW9yeQIAAAMDAgABBz4DEV9fd2FzbV9jYWxsX2N0b3JzAAAYX193YXNtX2FwcGx5X2RhdGFfcmVsb2NzAAALc29ydEluZGV4ZXMAAQqiDwICAAucDwMBfAd9Bn8gCyAKayEMAkACQCAOBEAgDQRAQfj///8HIQpBiICAgHghDSALIAxNDQMgDCEFA0AgAyAFQQJ0IgFqIAIgACABaigCAEECdGooAgAiATYCACABIAogASAKSBshCiABIA0gASANShshDSAFQQFqIgUgC0cNAAsMAwsgDwRAIAsgDE0NAkF/IQ9B+P///wchCkGIgICAeCENIAwhAgNAIA8gByAAIAJBAnQiGmooAgBBAnQiG2ooAgAiDkcEQAJ/IAUqAjgiESAIIA5BBnRqIg8qAjyUIAUqAigiEiAPKgI4lCAFKgIIIhMgDyoCMJQgBSoCGCIUIA8qAjSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIRgCfyARIA8qAiyUIBIgDyoCKJQgEyAPKgIglCAUIA8qAiSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIRkCfyARIA8qAhyUIBIgDyoCGJQgEyAPKgIQlCAUIA8qAhSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIRwCfyARIA8qAgyUIBIgDyoCCJQgEyAPKgIAlCAUIA8qAgSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIR0gDiEPCyADIBpqIAEgG0ECdGoiDigCBCAcbCAOKAIAIB1saiAOKAIIIBlsaiAOKAIMIBhsaiIONgIAIA4gCiAKIA5KGyEKIA4gDSANIA5IGyENIAJBAWoiAiALRw0ACwwDCwJ/IAUqAii7RAAAAAAAQI9AoiIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAshAgJ/IAUqAhi7RAAAAAAAQI9AoiIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAshByALIAxNAn8gBSoCCLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEPQfj///8HIQpBiICAgHghDQ0CIAwhBQNAIAMgBUECdCIIaiABIAAgCGooAgBBBHRqIggoAgQgB2wgCCgCACAPbGogCCgCCCACbGoiCDYCACAIIAogCCAKSBshCiAIIA0gCCANShshDSAFQQFqIgUgC0cNAAsMAgsgDQRAQfj///8HIQpBiICAgHghDSALIAxNDQIgDCEFA0AgAyAFQQJ0IgFqAn8gAiAAIAFqKAIAQQJ0aioCALtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyIONgIAIAogDiAKIA5IGyEKIA0gDiANIA5KGyENIAVBAWoiBSALRw0ACwwCCyAPRQRAIAsgDE0NASAFKgIoIREgBSoCGCESIAUqAgghE0H4////ByEKQYiAgIB4IQ0gDCEFA0ACfyARIAEgACAFQQJ0IgdqKAIAQQR0aiICKgIIlCATIAIqAgCUIBIgAioCBJSSkrtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEOIAMgB2ogDjYCACAKIA4gCiAOSBshCiANIA4gDSAOShshDSAFQQFqIgUgC0cNAAsMAgsgCyAMTQ0AQX8hD0H4////ByEKQYiAgIB4IQ0gDCECA0AgDyAHIAAgAkECdCIYaigCAEECdCIZaigCACIORwRAIAUqAjgiESAIIA5BBnRqIg8qAjyUIAUqAigiEiAPKgI4lCAFKgIIIhMgDyoCMJQgBSoCGCIUIA8qAjSUkpKSIRUgESAPKgIslCASIA8qAiiUIBMgDyoCIJQgFCAPKgIklJKSkiEWIBEgDyoCHJQgEiAPKgIYlCATIA8qAhCUIBQgDyoCFJSSkpIhFyARIA8qAgyUIBIgDyoCCJQgEyAPKgIAlCAUIA8qAgSUkpKSIREgDiEPCyADIBhqAn8gFSABIBlBAnRqIg4qAgyUIBYgDioCCJQgESAOKgIAlCAXIA4qAgSUkpKSu0QAAAAAAACwQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIg42AgAgCiAOIAogDkgbIQogDSAOIA0gDkobIQ0gAkEBaiICIAtHDQALDAELQYiAgIB4IQ1B+P///wchCgsgCyAMSwRAIAlBAWuzIA2yIAqyk5UhESAMIQ0DQAJ/IBEgAyANQQJ0aiIBKAIAIAprspQiEotDAAAAT10EQCASqAwBC0GAgICAeAshDiABIA42AgAgBCAOQQJ0aiIBIAEoAgBBAWo2AgAgDUEBaiINIAtHDQALCyAJQQJPBEAgBCgCACENQQEhCgNAIAQgCkECdGoiASABKAIAIA1qIg02AgAgCkEBaiIKIAlHDQALCyAMQQBKBEAgDCEKA0AgBiAKQQFrIgFBAnQiAmogACACaigCADYCACAKQQFLIAEhCg0ACwsgCyAMSgRAIAshCgNAIAYgCyAEIAMgCkEBayIKQQJ0IgFqKAIAQQJ0aiICKAIAIgVrQQJ0aiAAIAFqKAIANgIAIAIgBUEBazYCACAKIAxKDQALCws=";function cp(l){let e,t,n,s,r,i,o,a,c,d,u,f,h,g,p,m,A,y,v,x;function w(T,C,E,I,P,B,M){const D=performance.now();if(!n&&(new Uint32Array(t,o,P.byteLength/x.BytesPerInt).set(P),new Float32Array(t,d,M.byteLength/x.BytesPerFloat).set(M),I)){let $;s?$=new Int32Array(t,u,B.byteLength/x.BytesPerInt):$=new Float32Array(t,u,B.byteLength/x.BytesPerFloat),$.set(B)}m||(m=new Uint32Array(y)),new Float32Array(t,p,16).set(E),new Uint32Array(t,h,y).set(m),e.exports.sortIndexes(o,g,u,f,h,p,a,c,d,y,T,C,i,I,s,r);const _={sortDone:!0,splatSortCount:T,splatRenderCount:C,sortTime:0};if(!n){const G=new Uint32Array(t,a,C);(!A||A.length<C)&&(A=new Uint32Array(C)),A.set(G),_.sortedIndexes=A}const k=performance.now();_.sortTime=k-D,l.postMessage(_)}l.onmessage=T=>{if(T.data.centers)centers=T.data.centers,sceneIndexes=T.data.sceneIndexes,s?new Int32Array(t,g+T.data.range.from*x.BytesPerInt*4,T.data.range.count*4).set(new Int32Array(centers)):new Float32Array(t,g+T.data.range.from*x.BytesPerFloat*4,T.data.range.count*4).set(new Float32Array(centers)),r&&new Uint32Array(t,c+T.data.range.from*4,T.data.range.count).set(new Uint32Array(sceneIndexes)),v=T.data.range.from+T.data.range.count;else if(T.data.sort){const C=Math.min(T.data.sort.splatRenderCount||0,v),E=Math.min(T.data.sort.splatSortCount||0,v),I=T.data.sort.usePrecomputedDistances;let P,B,M;n||(P=T.data.sort.indexesToSort,M=T.data.sort.transforms,I&&(B=T.data.sort.precomputedDistances)),w(E,C,T.data.sort.modelViewProj,I,P,B,M)}else if(T.data.init){x=T.data.init.Constants,i=T.data.init.splatCount,n=T.data.init.useSharedMemory,s=T.data.init.integerBasedSort,r=T.data.init.dynamicMode,y=T.data.init.distanceMapRange,v=0;const C=s?x.BytesPerInt*4:x.BytesPerFloat*4,E=new Uint8Array(T.data.init.sorterWasmBytes),I=16*x.BytesPerFloat,P=i*x.BytesPerInt,B=i*C,M=I,D=s?i*x.BytesPerInt:i*x.BytesPerFloat,_=i*x.BytesPerInt,k=i*x.BytesPerInt,G=s?y*x.BytesPerInt*2:y*x.BytesPerFloat*2,O=r?i*x.BytesPerInt:0,$=r?x.MaxScenes*I:0,U=x.MemoryPageSize*32,Z=P+B+M+D+_+G+k+O+$+U,V=Math.floor(Z/x.MemoryPageSize)+1,z={module:{},env:{memory:new WebAssembly.Memory({initial:V,maximum:V,shared:!0})}};WebAssembly.compile(E).then(ne=>WebAssembly.instantiate(ne,z)).then(ne=>{e=ne,o=0,g=o+P,p=g+B,u=p+M,f=u+D,h=f+_,a=h+G,c=a+k,d=c+O,t=z.env.memory.buffer,n?l.postMessage({sortSetupPhase1Complete:!0,indexesToSortBuffer:t,indexesToSortOffset:o,sortedIndexesBuffer:t,sortedIndexesOffset:a,precomputedDistancesBuffer:t,precomputedDistancesOffset:u,transformsBuffer:t,transformsOffset:d}):l.postMessage({sortSetupPhase1Complete:!0})})}}}function up(l,e,t,n,s,r=Ee.DefaultSplatSortDistanceMapPrecision){const i=new Worker(URL.createObjectURL(new Blob(["(",cp.toString(),")(self)"],{type:"application/javascript"})));let o=op;const a=zr()?Pa():null;!t&&!e?(o=Po,a&&a.major<=16&&a.minor<4&&(o=lp)):t?e||a&&a.major<=16&&a.minor<4&&(o=ap):o=Po;const c=atob(o),d=new Uint8Array(c.length);for(let u=0;u<c.length;u++)d[u]=c.charCodeAt(u);return i.postMessage({init:{sorterWasmBytes:d.buffer,splatCount:l,useSharedMemory:e,integerBasedSort:n,dynamicMode:s,distanceMapRange:1<<r,Constants:{BytesPerFloat:Ee.BytesPerFloat,BytesPerInt:Ee.BytesPerInt,MemoryPageSize:Ee.MemoryPageSize,MaxScenes:Ee.MaxScenes}}}),i}const ln={None:0,VR:1,AR:2};class wn{static createButton(e,t={}){const n=document.createElement("button");function s(){let c=null;async function d(h){h.addEventListener("end",u),await e.xr.setSession(h),n.textContent="EXIT VR",c=h}function u(){c.removeEventListener("end",u),n.textContent="ENTER VR",c=null}n.style.display="",n.style.cursor="pointer",n.style.left="calc(50% - 50px)",n.style.width="100px",n.textContent="ENTER VR";const f={...t,optionalFeatures:["local-floor","bounded-floor","layers",...t.optionalFeatures||[]]};n.onmouseenter=function(){n.style.opacity="1.0"},n.onmouseleave=function(){n.style.opacity="0.5"},n.onclick=function(){c===null?navigator.xr.requestSession("immersive-vr",f).then(d):(c.end(),navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-vr",f).then(d).catch(h=>{console.warn(h)}))},navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-vr",f).then(d).catch(h=>{console.warn(h)})}function r(){n.style.display="",n.style.cursor="auto",n.style.left="calc(50% - 75px)",n.style.width="150px",n.onmouseenter=null,n.onmouseleave=null,n.onclick=null}function i(){r(),n.textContent="VR NOT SUPPORTED"}function o(c){r(),console.warn("Exception when trying to call xr.isSessionSupported",c),n.textContent="VR NOT ALLOWED"}function a(c){c.style.position="absolute",c.style.bottom="20px",c.style.padding="12px 6px",c.style.border="1px solid #fff",c.style.borderRadius="4px",c.style.background="rgba(0,0,0,0.1)",c.style.color="#fff",c.style.font="normal 13px sans-serif",c.style.textAlign="center",c.style.opacity="0.5",c.style.outline="none",c.style.zIndex="999"}if("xr"in navigator)return n.id="VRButton",n.style.display="none",a(n),navigator.xr.isSessionSupported("immersive-vr").then(function(c){c?s():i(),c&&wn.xrSessionIsGranted&&n.click()}).catch(o),n;{const c=document.createElement("a");return window.isSecureContext===!1?(c.href=document.location.href.replace(/^http:/,"https:"),c.innerHTML="WEBXR NEEDS HTTPS"):(c.href="https://immersiveweb.dev/",c.innerHTML="WEBXR NOT AVAILABLE"),c.style.left="calc(50% - 90px)",c.style.width="180px",c.style.textDecoration="none",a(c),c}}static registerSessionGrantedListener(){if(typeof navigator<"u"&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",()=>{wn.xrSessionIsGranted=!0})}}}wn.xrSessionIsGranted=!1;wn.registerSessionGrantedListener();class dp{static createButton(e,t={}){const n=document.createElement("button");function s(){if(t.domOverlay===void 0){const f=document.createElement("div");f.style.display="none",document.body.appendChild(f);const h=document.createElementNS("http://www.w3.org/2000/svg","svg");h.setAttribute("width",38),h.setAttribute("height",38),h.style.position="absolute",h.style.right="20px",h.style.top="20px",h.addEventListener("click",function(){c.end()}),f.appendChild(h);const g=document.createElementNS("http://www.w3.org/2000/svg","path");g.setAttribute("d","M 12,12 L 28,28 M 28,12 12,28"),g.setAttribute("stroke","#fff"),g.setAttribute("stroke-width",2),h.appendChild(g),t.optionalFeatures===void 0&&(t.optionalFeatures=[]),t.optionalFeatures.push("dom-overlay"),t.domOverlay={root:f}}let c=null;async function d(f){f.addEventListener("end",u),e.xr.setReferenceSpaceType("local"),await e.xr.setSession(f),n.textContent="STOP AR",t.domOverlay.root.style.display="",c=f}function u(){c.removeEventListener("end",u),n.textContent="START AR",t.domOverlay.root.style.display="none",c=null}n.style.display="",n.style.cursor="pointer",n.style.left="calc(50% - 50px)",n.style.width="100px",n.textContent="START AR",n.onmouseenter=function(){n.style.opacity="1.0"},n.onmouseleave=function(){n.style.opacity="0.5"},n.onclick=function(){c===null?navigator.xr.requestSession("immersive-ar",t).then(d):(c.end(),navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-ar",t).then(d).catch(f=>{console.warn(f)}))},navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-ar",t).then(d).catch(f=>{console.warn(f)})}function r(){n.style.display="",n.style.cursor="auto",n.style.left="calc(50% - 75px)",n.style.width="150px",n.onmouseenter=null,n.onmouseleave=null,n.onclick=null}function i(){r(),n.textContent="AR NOT SUPPORTED"}function o(c){r(),console.warn("Exception when trying to call xr.isSessionSupported",c),n.textContent="AR NOT ALLOWED"}function a(c){c.style.position="absolute",c.style.bottom="20px",c.style.padding="12px 6px",c.style.border="1px solid #fff",c.style.borderRadius="4px",c.style.background="rgba(0,0,0,0.1)",c.style.color="#fff",c.style.font="normal 13px sans-serif",c.style.textAlign="center",c.style.opacity="0.5",c.style.outline="none",c.style.zIndex="999"}if("xr"in navigator)return n.id="ARButton",n.style.display="none",a(n),navigator.xr.isSessionSupported("immersive-ar").then(function(c){c?s():i()}).catch(o),n;{const c=document.createElement("a");return window.isSecureContext===!1?(c.href=document.location.href.replace(/^http:/,"https:"),c.innerHTML="WEBXR NEEDS HTTPS"):(c.href="https://immersiveweb.dev/",c.innerHTML="WEBXR NOT AVAILABLE"),c.style.left="calc(50% - 90px)",c.style.width="180px",c.style.textDecoration="none",a(c),c}}}const hr={Always:0,OnChange:1,Never:2},hp=50,fp=.75,pp=15e5,mp=10,gp=2.5,Ap=60;class fn{constructor(e={}){if(e.cameraUp||(e.cameraUp=[0,1,0]),this.cameraUp=new F().fromArray(e.cameraUp),e.initialCameraPosition||(e.initialCameraPosition=[0,10,15]),this.initialCameraPosition=new F().fromArray(e.initialCameraPosition),e.initialCameraLookAt||(e.initialCameraLookAt=[0,0,0]),this.initialCameraLookAt=new F().fromArray(e.initialCameraLookAt),this.dropInMode=e.dropInMode||!1,(e.selfDrivenMode===void 0||e.selfDrivenMode===null)&&(e.selfDrivenMode=!0),this.selfDrivenMode=e.selfDrivenMode&&!this.dropInMode,this.selfDrivenUpdateFunc=this.selfDrivenUpdate.bind(this),e.useBuiltInControls===void 0&&(e.useBuiltInControls=!0),this.useBuiltInControls=e.useBuiltInControls,this.rootElement=e.rootElement,this.ignoreDevicePixelRatio=e.ignoreDevicePixelRatio||!1,this.devicePixelRatio=this.ignoreDevicePixelRatio?1:window.devicePixelRatio||1,this.halfPrecisionCovariancesOnGPU=e.halfPrecisionCovariancesOnGPU||!1,this.threeScene=e.threeScene,this.renderer=e.renderer,this.camera=e.camera,this.gpuAcceleratedSort=e.gpuAcceleratedSort||!1,(e.integerBasedSort===void 0||e.integerBasedSort===null)&&(e.integerBasedSort=!0),this.integerBasedSort=e.integerBasedSort,(e.sharedMemoryForWorkers===void 0||e.sharedMemoryForWorkers===null)&&(e.sharedMemoryForWorkers=!0),this.sharedMemoryForWorkers=e.sharedMemoryForWorkers,this.dynamicScene=!!e.dynamicScene,this.antialiased=e.antialiased||!1,this.kernel2DSize=e.kernel2DSize===void 0?.3:e.kernel2DSize,this.webXRMode=e.webXRMode||ln.None,this.webXRMode!==ln.None&&(this.gpuAcceleratedSort=!1),this.webXRActive=!1,this.webXRSessionInit=e.webXRSessionInit||{},this.renderMode=e.renderMode||hr.Always,this.sceneRevealMode=e.sceneRevealMode||Nn.Default,this.focalAdjustment=e.focalAdjustment||1,this.maxScreenSpaceSplatSize=e.maxScreenSpaceSplatSize||1024,this.logLevel=e.logLevel||vn.None,this.sphericalHarmonicsDegree=e.sphericalHarmonicsDegree||0,this.enableOptionalEffects=e.enableOptionalEffects||!1,(e.enableSIMDInSort===void 0||e.enableSIMDInSort===null)&&(e.enableSIMDInSort=!0),this.enableSIMDInSort=e.enableSIMDInSort,(e.inMemoryCompressionLevel===void 0||e.inMemoryCompressionLevel===null)&&(e.inMemoryCompressionLevel=0),this.inMemoryCompressionLevel=e.inMemoryCompressionLevel,(e.optimizeSplatData===void 0||e.optimizeSplatData===null)&&(e.optimizeSplatData=!0),this.optimizeSplatData=e.optimizeSplatData,(e.freeIntermediateSplatData===void 0||e.freeIntermediateSplatData===null)&&(e.freeIntermediateSplatData=!1),this.freeIntermediateSplatData=e.freeIntermediateSplatData,zr()){const n=Pa();n.major<17&&(this.enableSIMDInSort=!1),n.major<16&&(this.sharedMemoryForWorkers=!1)}(e.splatRenderMode===void 0||e.splatRenderMode===null)&&(e.splatRenderMode=Bt.ThreeD),this.splatRenderMode=e.splatRenderMode,this.sceneFadeInRateMultiplier=e.sceneFadeInRateMultiplier||1,this.splatSortDistanceMapPrecision=e.splatSortDistanceMapPrecision||Ee.DefaultSplatSortDistanceMapPrecision;const t=this.integerBasedSort?20:24;this.splatSortDistanceMapPrecision=Le(this.splatSortDistanceMapPrecision,10,t),this.onSplatMeshChangedCallback=null,this.createSplatMesh(),this.controls=null,this.perspectiveControls=null,this.orthographicControls=null,this.orthographicCamera=null,this.perspectiveCamera=null,this.showMeshCursor=!1,this.showControlPlane=!1,this.showInfo=!1,this.sceneHelper=null,this.sortWorker=null,this.sortRunning=!1,this.splatRenderCount=0,this.splatSortCount=0,this.lastSplatSortCount=0,this.sortWorkerIndexesToSort=null,this.sortWorkerSortedIndexes=null,this.sortWorkerPrecomputedDistances=null,this.sortWorkerTransforms=null,this.preSortMessages=[],this.runAfterNextSort=[],this.selfDrivenModeRunning=!1,this.splatRenderReady=!1,this.raycaster=new Wf,this.infoPanel=null,this.startInOrthographicMode=!1,this.currentFPS=0,this.lastSortTime=0,this.consecutiveRenderFrames=0,this.previousCameraTarget=new F,this.nextCameraTarget=new F,this.mousePosition=new ge,this.mouseDownPosition=new ge,this.mouseDownTime=null,this.resizeObserver=null,this.mouseMoveListener=null,this.mouseDownListener=null,this.mouseUpListener=null,this.keyDownListener=null,this.sortPromise=null,this.sortPromiseResolver=null,this.splatSceneDownloadPromises={},this.splatSceneDownloadAndBuildPromise=null,this.splatSceneRemovalPromise=null,this.loadingSpinner=new $r(null,this.rootElement||document.body),this.loadingSpinner.hide(),this.loadingProgressBar=new Of(this.rootElement||document.body),this.loadingProgressBar.hide(),this.infoPanel=new Uf(this.rootElement||document.body),this.infoPanel.hide(),this.usingExternalCamera=!!(this.dropInMode||this.camera),this.usingExternalRenderer=!!(this.dropInMode||this.renderer),this.initialized=!1,this.disposing=!1,this.disposed=!1,this.disposePromise=null,this.dropInMode||this.init()}createSplatMesh(){this.splatMesh=new Ge(this.splatRenderMode,this.dynamicScene,this.enableOptionalEffects,this.halfPrecisionCovariancesOnGPU,this.devicePixelRatio,this.gpuAcceleratedSort,this.integerBasedSort,this.antialiased,this.maxScreenSpaceSplatSize,this.logLevel,this.sphericalHarmonicsDegree,this.sceneFadeInRateMultiplier,this.kernel2DSize),this.splatMesh.frustumCulled=!1,this.onSplatMeshChangedCallback&&this.onSplatMeshChangedCallback()}init(){this.initialized||(this.rootElement||(this.usingExternalRenderer?this.rootElement=this.renderer.domElement||document.body:(this.rootElement=document.createElement("div"),this.rootElement.style.width="100%",this.rootElement.style.height="100%",this.rootElement.style.position="absolute",document.body.appendChild(this.rootElement))),this.setupCamera(),this.setupRenderer(),this.setupWebXR(this.webXRSessionInit),this.setupControls(),this.setupEventHandlers(),this.threeScene=this.threeScene||new qo,this.sceneHelper=new On(this.threeScene),this.sceneHelper.setupMeshCursor(),this.sceneHelper.setupFocusMarker(),this.sceneHelper.setupControlPlane(),this.loadingProgressBar.setContainer(this.rootElement),this.loadingSpinner.setContainer(this.rootElement),this.infoPanel.setContainer(this.rootElement),this.initialized=!0)}setupCamera(){if(!this.usingExternalCamera){const e=new ge;this.getRenderDimensions(e),this.perspectiveCamera=new Ps(hp,e.x/e.y,.1,1e3),this.orthographicCamera=new Lr(e.x/-2,e.x/2,e.y/2,e.y/-2,.1,1e3),this.camera=this.startInOrthographicMode?this.orthographicCamera:this.perspectiveCamera,this.camera.position.copy(this.initialCameraPosition),this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt)}}setupRenderer(){if(!this.usingExternalRenderer){const e=new ge;this.getRenderDimensions(e),this.renderer=new Xo({antialias:!1,precision:"highp"}),this.renderer.setPixelRatio(this.devicePixelRatio),this.renderer.autoClear=!0,this.renderer.setClearColor(new Se(0),0),this.renderer.setSize(e.x,e.y),this.resizeObserver=new ResizeObserver(()=>{this.getRenderDimensions(e),this.renderer.setSize(e.x,e.y),this.forceRenderNextFrame()}),this.resizeObserver.observe(this.rootElement),this.rootElement.appendChild(this.renderer.domElement)}}setupWebXR(e){this.webXRMode&&(this.webXRMode===ln.VR?this.rootElement.appendChild(wn.createButton(this.renderer,e)):this.webXRMode===ln.AR&&this.rootElement.appendChild(dp.createButton(this.renderer,e)),this.renderer.xr.addEventListener("sessionstart",t=>{this.webXRActive=!0}),this.renderer.xr.addEventListener("sessionend",t=>{this.webXRActive=!1}),this.renderer.xr.enabled=!0,this.camera.position.copy(this.initialCameraPosition),this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt))}setupControls(){if(this.useBuiltInControls&&this.webXRMode===ln.None){this.usingExternalCamera?this.camera.isOrthographicCamera?this.orthographicControls=new ls(this.camera,this.renderer.domElement):this.perspectiveControls=new ls(this.camera,this.renderer.domElement):(this.perspectiveControls=new ls(this.perspectiveCamera,this.renderer.domElement),this.orthographicControls=new ls(this.orthographicCamera,this.renderer.domElement));for(let e of[this.orthographicControls,this.perspectiveControls])e&&(e.listenToKeyEvents(window),e.rotateSpeed=.5,e.maxPolarAngle=Math.PI*.75,e.minPolarAngle=.1,e.enableDamping=!0,e.dampingFactor=.05,e.target.copy(this.initialCameraLookAt),e.update());this.controls=this.camera.isOrthographicCamera?this.orthographicControls:this.perspectiveControls,this.controls.update()}}setupEventHandlers(){this.useBuiltInControls&&this.webXRMode===ln.None&&(this.mouseMoveListener=this.onMouseMove.bind(this),this.renderer.domElement.addEventListener("pointermove",this.mouseMoveListener,!1),this.mouseDownListener=this.onMouseDown.bind(this),this.renderer.domElement.addEventListener("pointerdown",this.mouseDownListener,!1),this.mouseUpListener=this.onMouseUp.bind(this),this.renderer.domElement.addEventListener("pointerup",this.mouseUpListener,!1),this.keyDownListener=this.onKeyDown.bind(this),window.addEventListener("keydown",this.keyDownListener,!1))}removeEventHandlers(){this.useBuiltInControls&&(this.renderer.domElement.removeEventListener("pointermove",this.mouseMoveListener),this.mouseMoveListener=null,this.renderer.domElement.removeEventListener("pointerdown",this.mouseDownListener),this.mouseDownListener=null,this.renderer.domElement.removeEventListener("pointerup",this.mouseUpListener),this.mouseUpListener=null,window.removeEventListener("keydown",this.keyDownListener),this.keyDownListener=null)}setRenderMode(e){this.renderMode=e}setActiveSphericalHarmonicsDegrees(e){this.splatMesh.material.uniforms.sphericalHarmonicsDegree.value=e,this.splatMesh.material.uniformsNeedUpdate=!0}onSplatMeshChanged(e){this.onSplatMeshChangedCallback=e}onKeyDown=function(){const e=new F,t=new he,n=new he;return function(s){switch(e.set(0,0,-1),e.transformDirection(this.camera.matrixWorld),t.makeRotationAxis(e,Math.PI/128),n.makeRotationAxis(e,-Math.PI/128),s.code){case"KeyG":this.focalAdjustment+=.02,this.forceRenderNextFrame();break;case"KeyF":this.focalAdjustment-=.02,this.forceRenderNextFrame();break;case"ArrowLeft":this.camera.up.transformDirection(t);break;case"ArrowRight":this.camera.up.transformDirection(n);break;case"KeyC":this.showMeshCursor=!this.showMeshCursor;break;case"KeyU":this.showControlPlane=!this.showControlPlane;break;case"KeyI":this.showInfo=!this.showInfo,this.showInfo?this.infoPanel.show():this.infoPanel.hide();break;case"KeyO":this.usingExternalCamera||this.setOrthographicMode(!this.camera.isOrthographicCamera);break;case"KeyP":this.usingExternalCamera||this.splatMesh.setPointCloudModeEnabled(!this.splatMesh.getPointCloudModeEnabled());break;case"Equal":this.usingExternalCamera||this.splatMesh.setSplatScale(this.splatMesh.getSplatScale()+.05);break;case"Minus":this.usingExternalCamera||this.splatMesh.setSplatScale(Math.max(this.splatMesh.getSplatScale()-.05,0));break}}}();onMouseMove(e){this.mousePosition.set(e.offsetX,e.offsetY)}onMouseDown(){this.mouseDownPosition.copy(this.mousePosition),this.mouseDownTime=on()}onMouseUp=function(){const e=new ge;return function(t){e.copy(this.mousePosition).sub(this.mouseDownPosition),on()-this.mouseDownTime<.5&&e.length()<2&&this.onMouseClick(t)}}();onMouseClick(e){this.mousePosition.set(e.offsetX,e.offsetY),this.checkForFocalPointChange()}checkForFocalPointChange=function(){const e=new ge,t=new F,n=[];return function(){if(!this.transitioningCameraTarget&&(this.getRenderDimensions(e),n.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,e),this.raycaster.intersectSplatMesh(this.splatMesh,n),n.length>0)){const r=n[0].origin;t.copy(r).sub(this.camera.position),t.length()>fp&&(this.previousCameraTarget.copy(this.controls.target),this.nextCameraTarget.copy(r),this.transitioningCameraTarget=!0,this.transitioningCameraTargetStartTime=on())}}}();getRenderDimensions(e){this.rootElement?(e.x=this.rootElement.offsetWidth,e.y=this.rootElement.offsetHeight):this.renderer.getSize(e)}setOrthographicMode(e){if(e===this.camera.isOrthographicCamera)return;const t=this.camera,n=e?this.orthographicCamera:this.perspectiveCamera;if(n.position.copy(t.position),n.up.copy(t.up),n.rotation.copy(t.rotation),n.quaternion.copy(t.quaternion),n.matrix.copy(t.matrix),this.camera=n,this.controls){const s=o=>{o.saveState(),o.reset()},r=this.controls,i=e?this.orthographicControls:this.perspectiveControls;s(i),s(r),i.target.copy(r.target),e?fn.setCameraZoomFromPosition(n,t,r):fn.setCameraPositionFromZoom(n,t,i),this.controls=i,this.camera.lookAt(this.controls.target)}}static setCameraPositionFromZoom=function(){const e=new F;return function(t,n,s){const r=1/(n.zoom*.001);e.copy(s.target).sub(t.position).normalize().multiplyScalar(r).negate(),t.position.copy(s.target).add(e)}}();static setCameraZoomFromPosition=function(){const e=new F;return function(t,n,s){const r=e.copy(s.target).sub(n.position).length();t.zoom=1/(r*.001)}}();updateSplatMesh=function(){const e=new ge;return function(){if(!this.splatMesh)return;if(this.splatMesh.getSplatCount()>0){this.splatMesh.updateVisibleRegionFadeDistance(this.sceneRevealMode),this.splatMesh.updateTransforms(),this.getRenderDimensions(e);const n=this.camera.projectionMatrix.elements[0]*.5*this.devicePixelRatio*e.x,s=this.camera.projectionMatrix.elements[5]*.5*this.devicePixelRatio*e.y,r=this.camera.isOrthographicCamera?1/this.devicePixelRatio:1,i=this.focalAdjustment*r,o=1/i;this.adjustForWebXRStereo(e),this.splatMesh.updateUniforms(e,n*i,s*i,this.camera.isOrthographicCamera,this.camera.zoom||1,o)}}}();adjustForWebXRStereo(e){if(this.camera&&this.webXRActive){const n=this.renderer.xr.getCamera().projectionMatrix.elements[0],s=this.camera.projectionMatrix.elements[0];e.x*=s/n}}isLoadingOrUnloading(){return Object.keys(this.splatSceneDownloadPromises).length>0||this.splatSceneDownloadAndBuildPromise!==null||this.splatSceneRemovalPromise!==null}isDisposingOrDisposed(){return this.disposing||this.disposed}addSplatSceneDownloadPromise(e){this.splatSceneDownloadPromises[e.id]=e}removeSplatSceneDownloadPromise(e){delete this.splatSceneDownloadPromises[e.id]}setSplatSceneDownloadAndBuildPromise(e){this.splatSceneDownloadAndBuildPromise=e}clearSplatSceneDownloadAndBuildPromise(){this.splatSceneDownloadAndBuildPromise=null}addSplatScene(e,t={}){if(this.isLoadingOrUnloading())throw new Error("Cannot add splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot add splat scene after dispose() is called.");t.progressiveLoad&&this.splatMesh.scenes&&this.splatMesh.scenes.length>0&&(console.log('addSplatScene(): "progressiveLoad" option ignore because there are multiple splat scenes'),t.progressiveLoad=!1);const n=t.format!==void 0&&t.format!==null?t.format:_o(e),s=fn.isProgressivelyLoadable(n)&&t.progressiveLoad,r=t.showLoadingUI!==void 0&&t.showLoadingUI!==null?t.showLoadingUI:!0;let i=null;r&&(this.loadingSpinner.removeAllTasks(),i=this.loadingSpinner.addTask("Downloading..."));const o=()=>{this.loadingProgressBar.hide(),this.loadingSpinner.removeAllTasks()},a=(p,m,A)=>{if(r)if(A===ze.Downloading)if(p==100)this.loadingSpinner.setMessageForTask(i,"Download complete!");else if(s)this.loadingSpinner.setMessageForTask(i,"Downloading splats...");else{const y=m?`: ${m}`:"...";this.loadingSpinner.setMessageForTask(i,`Downloading${y}`)}else A===ze.Processing&&this.loadingSpinner.setMessageForTask(i,"Processing splats...")};let c=!1,d=0;const u=(p,m)=>{r&&((p&&s||m&&!s)&&(this.loadingSpinner.removeTask(i),!m&&!c&&this.loadingProgressBar.show()),s&&(m?(c=!0,this.loadingProgressBar.hide()):this.loadingProgressBar.setProgress(d)))},f=(p,m,A)=>{d=p,a(p,m,A),t.onProgress&&t.onProgress(p,m,A)},h=(p,m,A)=>{!s&&t.onProgress&&t.onProgress(0,"0%",ze.Processing);const y={rotation:t.rotation||t.orientation,position:t.position,scale:t.scale,splatAlphaRemovalThreshold:t.splatAlphaRemovalThreshold};return this.addSplatBuffers([p],[y],A,m&&r,r,s,s).then(()=>{!s&&t.onProgress&&t.onProgress(100,"100%",ze.Processing),u(m,A)})};return(s?this.downloadAndBuildSingleSplatSceneProgressiveLoad.bind(this):this.downloadAndBuildSingleSplatSceneStandardLoad.bind(this))(e,n,t.splatAlphaRemovalThreshold,h.bind(this),f,o.bind(this),t.headers)}downloadAndBuildSingleSplatSceneStandardLoad(e,t,n,s,r,i,o){const a=this.downloadSplatSceneToSplatBuffer(e,n,r,!1,void 0,t,o),c=rr(a.abortHandler);return a.then(d=>(this.removeSplatSceneDownloadPromise(a),s(d,!0,!0).then(()=>{c.resolve(),this.clearSplatSceneDownloadAndBuildPromise()}))).catch(d=>{i&&i(),this.clearSplatSceneDownloadAndBuildPromise(),this.removeSplatSceneDownloadPromise(a),c.reject(this.updateError(d,`Viewer::addSplatScene -> Could not load file ${e}`))}),this.addSplatSceneDownloadPromise(a),this.setSplatSceneDownloadAndBuildPromise(c.promise),c.promise}downloadAndBuildSingleSplatSceneProgressiveLoad(e,t,n,s,r,i,o){let a=0,c=!1;const d=[],u=()=>{if(d.length>0&&!c&&!this.isDisposingOrDisposed()){c=!0;const m=d.shift();s(m.splatBuffer,m.firstBuild,m.finalBuild).then(()=>{c=!1,m.firstBuild?g.resolve():m.finalBuild&&(p.resolve(),this.clearSplatSceneDownloadAndBuildPromise()),d.length>0&&ut(()=>u())})}},f=(m,A)=>{this.isDisposingOrDisposed()||(A||d.length===0||m.getSplatCount()>d[0].splatBuffer.getSplatCount())&&(d.push({splatBuffer:m,firstBuild:a===0,finalBuild:A}),a++,u())},h=this.downloadSplatSceneToSplatBuffer(e,n,r,!0,f,t,o),g=rr(h.abortHandler),p=rr();return this.addSplatSceneDownloadPromise(h),this.setSplatSceneDownloadAndBuildPromise(p.promise),h.then(()=>{this.removeSplatSceneDownloadPromise(h)}).catch(m=>{this.clearSplatSceneDownloadAndBuildPromise(),this.removeSplatSceneDownloadPromise(h);const A=this.updateError(m,"Viewer::addSplatScene -> Could not load one or more scenes");g.reject(A),i&&i(A)}),g.promise}addSplatScenes(e,t=!0,n=void 0){if(this.isLoadingOrUnloading())throw new Error("Cannot add splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot add splat scene after dispose() is called.");const s=e.length,r=[];let i;t&&(this.loadingSpinner.removeAllTasks(),i=this.loadingSpinner.addTask("Downloading..."));const o=(u,f,h,g)=>{r[u]=f;let p=0;for(let m=0;m<s;m++)p+=r[m]||0;p=p/s,h=`${p.toFixed(2)}%`,t&&g===ze.Downloading&&this.loadingSpinner.setMessageForTask(i,p==100?"Download complete!":`Downloading: ${h}`),n&&n(p,h,g)},a=[],c=[];for(let u=0;u<e.length;u++){const f=e[u],h=f.format!==void 0&&f.format!==null?f.format:_o(f.path),g=this.downloadSplatSceneToSplatBuffer(f.path,f.splatAlphaRemovalThreshold,o.bind(this,u),!1,void 0,h,f.headers);a.push(g),c.push(g.promise)}const d=new Nt((u,f)=>{Promise.all(c).then(h=>{t&&this.loadingSpinner.removeTask(i),n&&n(0,"0%",ze.Processing),this.addSplatBuffers(h,e,!0,t,t,!1,!1).then(()=>{n&&n(100,"100%",ze.Processing),this.clearSplatSceneDownloadAndBuildPromise(),u()})}).catch(h=>{t&&this.loadingSpinner.removeTask(i),this.clearSplatSceneDownloadAndBuildPromise(),f(this.updateError(h,"Viewer::addSplatScenes -> Could not load one or more splat scenes."))}).finally(()=>{this.removeSplatSceneDownloadPromise(d)})},u=>{for(let f of a)f.abort(u)});return this.addSplatSceneDownloadPromise(d),this.setSplatSceneDownloadAndBuildPromise(d),d}downloadSplatSceneToSplatBuffer(e,t=1,n=void 0,s=!1,r=void 0,i,o){try{if(i===tt.Splat||i===tt.KSplat||i===tt.Ply){const a=s?!1:this.optimizeSplatData;if(i===tt.Splat)return Jr.loadFromURL(e,n,s,r,t,this.inMemoryCompressionLevel,a,o);if(i===tt.KSplat)return kn.loadFromURL(e,n,s,r,o);if(i===tt.Ply)return Yr.loadFromURL(e,n,s,r,t,this.inMemoryCompressionLevel,a,this.sphericalHarmonicsDegree,o)}else if(i===tt.Spz)return Zr.loadFromURL(e,n,t,this.inMemoryCompressionLevel,this.optimizeSplatData,this.sphericalHarmonicsDegree,o)}catch(a){throw this.updateError(a,null)}throw new Error(`Viewer::downloadSplatSceneToSplatBuffer -> File format not supported: ${e}`)}static isProgressivelyLoadable(e){return e===tt.Splat||e===tt.KSplat||e===tt.Ply}addSplatBuffers=function(){return function(e,t=[],n=!0,s=!0,r=!0,i=!1,o=!1,a=!0){if(this.isDisposingOrDisposed())return Promise.resolve();let c=null;const d=()=>{c!==null&&(this.loadingSpinner.removeTask(c),c=null)};return this.splatRenderReady=!1,new Promise(u=>{s&&(c=this.loadingSpinner.addTask("Processing splats...")),ut(()=>{if(this.isDisposingOrDisposed())u();else{const f=this.addSplatBuffersToMesh(e,t,n,r,i,a),h=this.splatMesh.getMaxSplatCount();this.sortWorker&&this.sortWorker.maxSplatCount!==h&&this.disposeSortWorker(),this.gpuAcceleratedSort||this.preSortMessages.push({centers:f.centers.buffer,sceneIndexes:f.sceneIndexes.buffer,range:{from:f.from,to:f.to,count:f.count}}),(!this.sortWorker&&h>0?this.setupSortWorker(this.splatMesh):Promise.resolve()).then(()=>{this.isDisposingOrDisposed()||this.runSplatSort(!0,!0).then(p=>{!this.sortWorker||!p?(this.splatRenderReady=!0,d(),u()):(o?this.splatRenderReady=!0:this.runAfterNextSort.push(()=>{this.splatRenderReady=!0}),this.runAfterNextSort.push(()=>{d(),u()}))})})}},!0)})}}();addSplatBuffersToMesh=function(){let e;return function(t,n,s=!0,r=!1,i=!1,o=!0){if(this.isDisposingOrDisposed())return;let a=[],c=[];i||(a=this.splatMesh.scenes.map(h=>h.splatBuffer)||[],c=this.splatMesh.sceneOptions?this.splatMesh.sceneOptions.map(h=>h):[]),a.push(...t),c.push(...n),this.renderer&&this.splatMesh.setRenderer(this.renderer);const d=h=>{if(this.isDisposingOrDisposed())return;const g=this.splatMesh.getSplatCount();r&&g>=pp&&!h&&!e&&(this.loadingSpinner.setMinimized(!0,!0),e=this.loadingSpinner.addTask("Optimizing data structures..."))},u=h=>{this.isDisposingOrDisposed()||h&&e&&(this.loadingSpinner.removeTask(e),e=null)},f=this.splatMesh.build(a,c,!0,s,d,u,o);return s&&this.freeIntermediateSplatData&&this.splatMesh.freeIntermediateSplatData(),f}}();setupSortWorker(e){if(!this.isDisposingOrDisposed())return new Promise(t=>{const n=this.integerBasedSort?Int32Array:Float32Array,s=e.getSplatCount(),r=e.getMaxSplatCount();this.sortWorker=up(r,this.sharedMemoryForWorkers,this.enableSIMDInSort,this.integerBasedSort,this.splatMesh.dynamicMode,this.splatSortDistanceMapPrecision),this.sortWorker.onmessage=i=>{if(i.data.sortDone){if(this.sortRunning=!1,this.sharedMemoryForWorkers)this.splatMesh.updateRenderIndexes(this.sortWorkerSortedIndexes,i.data.splatRenderCount);else{const o=new Uint32Array(i.data.sortedIndexes.buffer,0,i.data.splatRenderCount);this.splatMesh.updateRenderIndexes(o,i.data.splatRenderCount)}this.lastSplatSortCount=this.splatSortCount,this.lastSortTime=i.data.sortTime,this.sortPromiseResolver(),this.sortPromiseResolver=null,this.forceRenderNextFrame(),this.runAfterNextSort.length>0&&(this.runAfterNextSort.forEach(o=>{o()}),this.runAfterNextSort.length=0)}else if(i.data.sortCanceled)this.sortRunning=!1;else if(i.data.sortSetupPhase1Complete){this.logLevel>=vn.Info&&console.log("Sorting web worker WASM setup complete."),this.sharedMemoryForWorkers?(this.sortWorkerSortedIndexes=new Uint32Array(i.data.sortedIndexesBuffer,i.data.sortedIndexesOffset,r),this.sortWorkerIndexesToSort=new Uint32Array(i.data.indexesToSortBuffer,i.data.indexesToSortOffset,r),this.sortWorkerPrecomputedDistances=new n(i.data.precomputedDistancesBuffer,i.data.precomputedDistancesOffset,r),this.sortWorkerTransforms=new Float32Array(i.data.transformsBuffer,i.data.transformsOffset,Ee.MaxScenes*16)):(this.sortWorkerIndexesToSort=new Uint32Array(r),this.sortWorkerPrecomputedDistances=new n(r),this.sortWorkerTransforms=new Float32Array(Ee.MaxScenes*16));for(let o=0;o<s;o++)this.sortWorkerIndexesToSort[o]=o;if(this.sortWorker.maxSplatCount=r,this.logLevel>=vn.Info){console.log("Sorting web worker ready.");const o=this.splatMesh.getSplatDataTextures(),a=o.covariances.size,c=o.centerColors.size;console.log("Covariances texture size: "+a.x+" x "+a.y),console.log("Centers/colors texture size: "+c.x+" x "+c.y)}t()}}})}updateError(e,t){return e instanceof Ba?e:e instanceof Es?new Error("File type or server does not support progressive loading."):t?new Error(t):e}disposeSortWorker(){this.sortWorker&&this.sortWorker.terminate(),this.sortWorker=null,this.sortPromise=null,this.sortPromiseResolver&&(this.sortPromiseResolver(),this.sortPromiseResolver=null),this.preSortMessages=[],this.sortRunning=!1}removeSplatScene(e,t=!0){return this.removeSplatScenes([e],t)}removeSplatScenes(e,t=!0){if(this.isLoadingOrUnloading())throw new Error("Cannot remove splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot remove splat scene after dispose() is called.");let n;return this.splatSceneRemovalPromise=new Promise((s,r)=>{let i;t&&(this.loadingSpinner.removeAllTasks(),this.loadingSpinner.show(),i=this.loadingSpinner.addTask("Removing splat scene..."));const o=()=>{t&&(this.loadingSpinner.hide(),this.loadingSpinner.removeTask(i))},a=d=>{o(),this.splatSceneRemovalPromise=null,d?r(d):s()},c=()=>this.isDisposingOrDisposed()?(a(),!0):!1;n=this.sortPromise||Promise.resolve(),n.then(()=>{if(c())return;const d=[],u=[],f=[];for(let h=0;h<this.splatMesh.scenes.length;h++){let g=!1;for(let p of e)if(p===h){g=!0;break}if(!g){const p=this.splatMesh.scenes[h];d.push(p.splatBuffer),u.push(this.splatMesh.sceneOptions[h]),f.push({position:p.position.clone(),quaternion:p.quaternion.clone(),scale:p.scale.clone()})}}this.disposeSortWorker(),this.splatMesh.dispose(),this.sceneRevealMode=Nn.Instant,this.createSplatMesh(),this.addSplatBuffers(d,u,!0,!1,!0).then(()=>{c()||(o(),this.splatMesh.scenes.forEach((h,g)=>{h.position.copy(f[g].position),h.quaternion.copy(f[g].quaternion),h.scale.copy(f[g].scale)}),this.splatMesh.updateTransforms(),this.splatRenderReady=!1,this.runSplatSort(!0).then(()=>{if(c()){this.splatRenderReady=!0;return}n=this.sortPromise||Promise.resolve(),n.then(()=>{this.splatRenderReady=!0,a()})}))}).catch(h=>{a(h)})})}),this.splatSceneRemovalPromise}start(){if(this.selfDrivenMode)this.webXRMode?this.renderer.setAnimationLoop(this.selfDrivenUpdateFunc):this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc),this.selfDrivenModeRunning=!0;else throw new Error("Cannot start viewer unless it is in self driven mode.")}stop(){this.selfDrivenMode&&this.selfDrivenModeRunning&&(this.webXRMode?this.renderer.setAnimationLoop(null):cancelAnimationFrame(this.requestFrameId),this.selfDrivenModeRunning=!1)}async dispose(){if(this.isDisposingOrDisposed())return this.disposePromise;let e=[],t=[];for(let n in this.splatSceneDownloadPromises)if(this.splatSceneDownloadPromises.hasOwnProperty(n)){const s=this.splatSceneDownloadPromises[n];t.push(s),e.push(s.promise)}return this.sortPromise&&e.push(this.sortPromise),this.disposing=!0,this.disposePromise=Promise.all(e).finally(()=>{this.stop(),this.orthographicControls&&(this.orthographicControls.dispose(),this.orthographicControls=null),this.perspectiveControls&&(this.perspectiveControls.dispose(),this.perspectiveControls=null),this.controls=null,this.splatMesh&&(this.splatMesh.dispose(),this.splatMesh=null),this.sceneHelper&&(this.sceneHelper.dispose(),this.sceneHelper=null),this.resizeObserver&&(this.resizeObserver.unobserve(this.rootElement),this.resizeObserver=null),this.disposeSortWorker(),this.removeEventHandlers(),this.loadingSpinner.removeAllTasks(),this.loadingSpinner.setContainer(null),this.loadingProgressBar.hide(),this.loadingProgressBar.setContainer(null),this.infoPanel.setContainer(null),this.camera=null,this.threeScene=null,this.splatRenderReady=!1,this.initialized=!1,this.renderer&&(this.usingExternalRenderer||(this.rootElement.removeChild(this.renderer.domElement),this.renderer.dispose()),this.renderer=null),this.usingExternalRenderer||document.body.removeChild(this.rootElement),this.sortWorkerSortedIndexes=null,this.sortWorkerIndexesToSort=null,this.sortWorkerPrecomputedDistances=null,this.sortWorkerTransforms=null,this.disposed=!0,this.disposing=!1,this.disposePromise=null}),t.forEach(n=>{n.abort("Scene disposed")}),this.disposePromise}selfDrivenUpdate(){this.selfDrivenMode&&!this.webXRMode&&(this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc)),this.update(),this.shouldRender()?(this.render(),this.consecutiveRenderFrames++):this.consecutiveRenderFrames=0,this.renderNextFrame=!1}forceRenderNextFrame(){this.renderNextFrame=!0}shouldRender=function(){let e=0;const t=new F,n=new ce,s=1e-4;return function(){if(!this.initialized||!this.splatRenderReady||this.isDisposingOrDisposed())return!1;let r=!1,i=!1;if(this.camera){const o=this.camera.position,a=this.camera.quaternion;i=Math.abs(o.x-t.x)>s||Math.abs(o.y-t.y)>s||Math.abs(o.z-t.z)>s||Math.abs(a.x-n.x)>s||Math.abs(a.y-n.y)>s||Math.abs(a.z-n.z)>s||Math.abs(a.w-n.w)>s}return r=this.renderMode!==hr.Never&&(e===0||this.splatMesh.visibleRegionChanging||i||this.renderMode===hr.Always||this.dynamicMode===!0||this.renderNextFrame),this.camera&&(t.copy(this.camera.position),n.copy(this.camera.quaternion)),e++,r}}();render=function(){return function(){if(!this.initialized||!this.splatRenderReady||this.isDisposingOrDisposed())return;const e=n=>{for(let s of n.children)if(s.visible)return!0;return!1},t=this.renderer.autoClear;e(this.threeScene)&&(this.renderer.render(this.threeScene,this.camera),this.renderer.autoClear=!1),this.renderer.render(this.splatMesh,this.camera),this.renderer.autoClear=!1,this.sceneHelper.getFocusMarkerOpacity()>0&&this.renderer.render(this.sceneHelper.focusMarker,this.camera),this.showControlPlane&&this.renderer.render(this.sceneHelper.controlPlane,this.camera),this.renderer.autoClear=t}}();update(e,t){this.dropInMode&&this.updateForDropInMode(e,t),!(!this.initialized||!this.splatRenderReady||this.isDisposingOrDisposed())&&(this.controls&&(this.controls.update(),this.camera.isOrthographicCamera&&!this.usingExternalCamera&&fn.setCameraPositionFromZoom(this.camera,this.camera,this.controls)),this.runSplatSort(),this.updateForRendererSizeChanges(),this.updateSplatMesh(),this.updateMeshCursor(),this.updateFPS(),this.timingSensitiveUpdates(),this.updateInfoPanel(),this.updateControlPlane())}updateForDropInMode(e,t){this.renderer=e,this.splatMesh&&this.splatMesh.setRenderer(this.renderer),this.camera=t,this.controls&&(this.controls.object=t),this.init()}updateFPS=function(){let e=on(),t=0;return function(){if(this.consecutiveRenderFrames>Ap){const n=on();n-e>=1?(this.currentFPS=t,t=0,e=n):t++}else this.currentFPS=null}}();updateForRendererSizeChanges=function(){const e=new ge,t=new ge;let n;return function(){this.usingExternalCamera||(this.renderer.getSize(t),(n===void 0||n!==this.camera.isOrthographicCamera||t.x!==e.x||t.y!==e.y)&&(this.camera.isOrthographicCamera?(this.camera.left=-t.x/2,this.camera.right=t.x/2,this.camera.top=t.y/2,this.camera.bottom=-t.y/2):this.camera.aspect=t.x/t.y,this.camera.updateProjectionMatrix(),e.copy(t),n=this.camera.isOrthographicCamera))}}();timingSensitiveUpdates=function(){let e;return function(){const t=on();e||(e=t);const n=t-e;this.updateCameraTransition(t),this.updateFocusMarker(n),e=t}}();updateCameraTransition=function(){let e=new F,t=new F,n=new F;return function(s){if(this.transitioningCameraTarget){t.copy(this.previousCameraTarget).sub(this.camera.position).normalize(),n.copy(this.nextCameraTarget).sub(this.camera.position).normalize();const r=Math.acos(t.dot(n)),o=(r/(Math.PI/3)*.65+.3)/r*(s-this.transitioningCameraTargetStartTime);e.copy(this.previousCameraTarget).lerp(this.nextCameraTarget,o),this.camera.lookAt(e),this.controls.target.copy(e),o>=1&&(this.transitioningCameraTarget=!1)}}}();updateFocusMarker=function(){const e=new ge;let t=!1;return function(n){if(this.getRenderDimensions(e),this.transitioningCameraTarget){this.sceneHelper.setFocusMarkerVisibility(!0);const s=Math.max(this.sceneHelper.getFocusMarkerOpacity(),0);let r=Math.min(s+mp*n,1);this.sceneHelper.setFocusMarkerOpacity(r),this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e),t=!0,this.forceRenderNextFrame()}else{let s;if(t?s=1:s=Math.min(this.sceneHelper.getFocusMarkerOpacity(),1),s>0){this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e);let r=Math.max(s-gp*n,0);this.sceneHelper.setFocusMarkerOpacity(r),r===0&&this.sceneHelper.setFocusMarkerVisibility(!1)}s>0&&this.forceRenderNextFrame(),t=!1}}}();updateMeshCursor=function(){const e=[],t=new ge;return function(){this.showMeshCursor?(this.forceRenderNextFrame(),this.getRenderDimensions(t),e.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,t),this.raycaster.intersectSplatMesh(this.splatMesh,e),e.length>0?(this.sceneHelper.setMeshCursorVisibility(!0),this.sceneHelper.positionAndOrientMeshCursor(e[0].origin,this.camera)):this.sceneHelper.setMeshCursorVisibility(!1)):(this.sceneHelper.getMeschCursorVisibility()&&this.forceRenderNextFrame(),this.sceneHelper.setMeshCursorVisibility(!1))}}();updateInfoPanel=function(){const e=new ge;return function(){if(!this.showInfo)return;const t=this.splatMesh.getSplatCount();this.getRenderDimensions(e);const n=this.controls?this.controls.target:null,s=this.showMeshCursor?this.sceneHelper.meshCursor.position:null,r=t>0?this.splatRenderCount/t*100:0;this.infoPanel.update(e,this.camera.position,n,this.camera.up,this.camera.isOrthographicCamera,s,this.currentFPS||"N/A",t,this.splatRenderCount,r,this.lastSortTime,this.focalAdjustment,this.splatMesh.getSplatScale(),this.splatMesh.getPointCloudModeEnabled())}}();updateControlPlane(){this.showControlPlane?(this.sceneHelper.setControlPlaneVisibility(!0),this.sceneHelper.positionAndOrientControlPlane(this.controls.target,this.camera.up)):this.sceneHelper.setControlPlaneVisibility(!1)}runSplatSort=function(){const e=new he,t=[],n=new F(0,0,-1),s=new F(0,0,-1),r=new F,i=new F,o=[],a=[{angleThreshold:.55,sortFractions:[.125,.33333,.75]},{angleThreshold:.65,sortFractions:[.33333,.66667]},{angleThreshold:.8,sortFractions:[.5]}];return function(c=!1,d=!1){if(!this.initialized)return Promise.resolve(!1);if(this.sortRunning)return Promise.resolve(!0);if(this.splatMesh.getSplatCount()<=0)return this.splatRenderCount=0,Promise.resolve(!1);let u=0,f=0,h=!1,g=!1;if(s.set(0,0,-1).applyQuaternion(this.camera.quaternion),u=s.dot(n),f=i.copy(this.camera.position).sub(r).length(),!c&&!this.splatMesh.dynamicMode&&o.length===0&&(u<=.99&&(h=!0),f>=1&&(g=!0),!h&&!g))return Promise.resolve(!1);this.sortRunning=!0;let{splatRenderCount:p,shouldSortAll:m}=this.gatherSceneNodesForSort();m=m||d,this.splatRenderCount=p,e.copy(this.camera.matrixWorld).invert();const A=this.perspectiveCamera||this.camera;e.premultiply(A.projectionMatrix),this.splatMesh.dynamicMode||e.multiply(this.splatMesh.matrixWorld);let y=Promise.resolve(!0);return this.gpuAcceleratedSort&&(o.length<=1||o.length%2===0)&&(y=this.splatMesh.computeDistancesOnGPU(e,this.sortWorkerPrecomputedDistances)),y.then(()=>{if(o.length===0)if(this.splatMesh.dynamicMode||m)o.push(this.splatRenderCount);else{for(let w of a)if(u<w.angleThreshold){for(let T of w.sortFractions)o.push(Math.floor(this.splatRenderCount*T));break}o.push(this.splatRenderCount)}let v=Math.min(o.shift(),this.splatRenderCount);this.splatSortCount=v,t[0]=this.camera.position.x,t[1]=this.camera.position.y,t[2]=this.camera.position.z;const x={modelViewProj:e.elements,cameraPosition:t,splatRenderCount:this.splatRenderCount,splatSortCount:v,usePrecomputedDistances:this.gpuAcceleratedSort};return this.splatMesh.dynamicMode&&this.splatMesh.fillTransformsArray(this.sortWorkerTransforms),this.sharedMemoryForWorkers||(x.indexesToSort=this.sortWorkerIndexesToSort,x.transforms=this.sortWorkerTransforms,this.gpuAcceleratedSort&&(x.precomputedDistances=this.sortWorkerPrecomputedDistances)),this.sortPromise=new Promise(w=>{this.sortPromiseResolver=w}),this.preSortMessages.length>0&&(this.preSortMessages.forEach(w=>{this.sortWorker.postMessage(w)}),this.preSortMessages=[]),this.sortWorker.postMessage({sort:x}),o.length===0&&(r.copy(this.camera.position),n.copy(s)),!0}),y}}();gatherSceneNodesForSort=function(){const e=[];let t=null;const n=new F,s=new F,r=new F,i=new he,o=new he,a=new he,c=new F,d=new F(0,0,-1),u=new F,f=h=>u.copy(h.max).sub(h.min).length();return function(h=!1){this.getRenderDimensions(c);const g=c.y/2/Math.tan(this.camera.fov/2*Ae.DEG2RAD),p=Math.atan(c.x/2/g),m=Math.atan(c.y/2/g),A=Math.cos(p),y=Math.cos(m),v=this.splatMesh.getSplatTree();if(v){o.copy(this.camera.matrixWorld).invert(),this.splatMesh.dynamicMode||o.multiply(this.splatMesh.matrixWorld);let x=0,w=0;for(let C=0;C<v.subTrees.length;C++){const E=v.subTrees[C];i.copy(o),this.splatMesh.dynamicMode&&(this.splatMesh.getSceneTransform(C,a),i.multiply(a));const I=E.nodesWithIndexes.length;for(let P=0;P<I;P++){const B=E.nodesWithIndexes[P];if(!B.data||!B.data.indexes||B.data.indexes.length===0)continue;r.copy(B.center).applyMatrix4(i);const M=r.length();r.normalize(),n.copy(r).setX(0).normalize(),s.copy(r).setY(0).normalize();const D=d.dot(s),_=d.dot(n),k=f(B),G=_<y-.6,O=D<A-.6;!h&&(O||G)&&M>k||(w+=B.data.indexes.length,e[x]=B,B.data.distanceToNode=M,x++)}}e.length=x,e.sort((C,E)=>C.data.distanceToNode<E.data.distanceToNode?-1:1);let T=w*Ee.BytesPerInt;for(let C=0;C<x;C++){const E=e[C],I=E.data.indexes.length,P=I*Ee.BytesPerInt;new Uint32Array(this.sortWorkerIndexesToSort.buffer,T-P,I).set(E.data.indexes),T-=P}return{splatRenderCount:w,shouldSortAll:!1}}else{const x=this.splatMesh.getSplatCount();if(!t||t.length!==x){t=new Uint32Array(x);for(let w=0;w<x;w++)t[w]=w}return this.sortWorkerIndexesToSort.set(t),{splatRenderCount:x,shouldSortAll:!0}}}}();getSplatMesh(){return this.splatMesh}getSplatScene(e){return this.splatMesh.getScene(e)}getSceneCount(){return this.splatMesh.getSceneCount()}isMobile(){return navigator.userAgent.includes("Mobi")}}class Rs extends Je{constructor(e={}){super(),e.selfDrivenMode=!1,e.useBuiltInControls=!1,e.rootElement=null,e.dropInMode=!0,e.camera=void 0,e.renderer=void 0,this.viewer=new fn(e),this.splatMesh=null,this.updateSplatMesh(),this.callbackMesh=Rs.createCallbackMesh(),this.add(this.callbackMesh),this.callbackMesh.onBeforeRender=Rs.onBeforeRender.bind(this,this.viewer),this.viewer.onSplatMeshChanged(()=>{this.updateSplatMesh()})}updateSplatMesh(){this.splatMesh!==this.viewer.splatMesh&&(this.splatMesh&&this.remove(this.splatMesh),this.splatMesh=this.viewer.splatMesh,this.add(this.viewer.splatMesh))}addSplatScene(e,t={}){return t.showLoadingUI!==!1&&(t.showLoadingUI=!0),this.viewer.addSplatScene(e,t)}addSplatScenes(e,t){return t!==!1&&(t=!0),this.viewer.addSplatScenes(e,t)}getSplatScene(e){return this.viewer.getSplatScene(e)}removeSplatScene(e,t=!0){return this.viewer.removeSplatScene(e,t)}removeSplatScenes(e,t=!0){return this.viewer.removeSplatScenes(e,t)}getSceneCount(){return this.viewer.getSceneCount()}setActiveSphericalHarmonicsDegrees(e){this.viewer.setActiveSphericalHarmonicsDegrees(e)}async dispose(){return await this.viewer.dispose()}static onBeforeRender(e,t,n,s){e.update(t,s)}static createCallbackMesh(){const e=new vr(1,8,8),t=new rt;t.colorWrite=!1,t.depthWrite=!1;const n=new Oe(e,t);return n.frustumCulled=!1,n}}class yp extends Je{constructor(e,t,n,s,r){super(),this.loadGS(e,t,n,s,r)}loadGS(e,t,n=[0,0,0],s=[0,0,1,0],r){Array.isArray(e)||(e=[e]),this.loadingPromise=new Promise(async(i,o)=>{let a=new Rs({sharedMemoryForWorkers:!1,dynamicScene:!0,sceneRevealMode:2,sphericalHarmonicsDegree:2});const c=e.map(d=>({path:d,scale:[t,t,t],position:n,rotation:s,splatAlphaRemovalThreshold:0}));c.push(...r.map(d=>{const u=new ce().setFromEuler(new at(...(d.rotation??[0,0,0]).map((h,g)=>h*Math.PI/180+Math.PI*(g===2)))),f=d.scale??1;return{path:d.url,scale:[f,f,f],position:d.position??[0,0,0],rotation:[u.x,u.y,u.z,u.w],splatAlphaRemovalThreshold:0}})),await a.addSplatScenes(c,!1),this.add(a),this.viewer=a,this.position0=new F(...n),this.quaternion0=new ce(...s),this.rotation0=new at().setFromQuaternion(this.quaternion0),this.matrix0=new he().compose(this.position0,this.quaternion0,new F(1,1,1)),i(this)},void 0,function(i){console.error(i)})}}class vp{constructor(){this.header=null,this.vertexCount=0,this.properties=[],this.propertyTypes=new Map([["char",1],["uchar",1],["short",2],["ushort",2],["int",4],["uint",4],["float",4],["double",8]])}async parsePLY(e,t){let n;if(e.endsWith(".ply")||(t=!1),t)try{const v=await fetch(e,{method:"HEAD"});n=Number(v.headers.get("content-length"))}catch{const x=await fetch(e);n=Number(x.headers.get("content-length"))}else{const v=await fetch(e);n=Number(v.headers.get("content-length"))}const r=(await fetch(e)).body.getReader(),i=[];let o=0;for(;;){const{done:v,value:x}=await r.read();if(v)break;i.push(x),o+=x.length;const w=document.getElementById("loaddisplay");if(w)if(n){const T=o/n*100;w.innerHTML=`${T.toFixed(1)}% (1/2)`}else w.innerHTML=`${o} bytes loaded (1/2)`}const a=document.getElementById("loaddisplay");a&&(a.innerHTML=`${100 .toFixed(1)}% (1/2)`);const c=new ArrayBuffer(o),d=new Uint8Array(c);let u=0;for(const v of i)d.set(v,u),u+=v.length;const f=new DataView(c);u=0;let h="";for(;;){const v=f.getUint8(u++);if(h+=String.fromCharCode(v),h.includes(`end_header
`))break}const g=h.split(`
`);this.header=g.filter(v=>v.trim()!=="");for(const v of this.header)if(v.startsWith("format"))v.split(" ")[1];else if(v.startsWith("element vertex"))this.vertexCount=parseInt(v.split(" ")[2]);else if(v.startsWith("property")){const x=v.split(" ");this.properties.push({type:x[1],name:x[2]})}const p=this.properties.reduce((v,x)=>v+this.propertyTypes.get(x.type),0),m=[],A=new Uint8Array(c.slice(u));for(let v=0;v<this.vertexCount;v++){const x={rawData:A.slice(v*p,(v+1)*p)};let w=0;for(const T of this.properties){const C=this.propertyTypes.get(T.type);let E;switch(T.type){case"float":E=f.getFloat32(u+w,!0);break}x[T.name]=E,w+=C}if(m.push(x),u+=p,v%1e4===0){const T=v/this.vertexCount*100,C=document.getElementById("loaddisplay");C&&await new Promise(E=>{requestAnimationFrame(()=>{C.innerHTML=`${T.toFixed(1)}% (2/2)`,E()})})}}const y=document.getElementById("loaddisplay");return y&&(y.innerHTML=`${100 .toFixed(1)}% (2/2)`),{header:this.header,vertices:m,vertexCount:this.vertexCount,vertexSize:p}}createPLYFile(e,t,n){const s=e.join(`
`)+`
`,i=new TextEncoder().encode(s),o=new Uint8Array(t.length*n);t.forEach((c,d)=>{o.set(c.rawData,d*n)});const a=new Uint8Array(i.length+o.length);return a.set(i,0),a.set(o,i.length),a}async splitPLY(e,t){const n=await this.parsePLY(e,!1),s=i=>n.header.map(o=>o.startsWith("element vertex")?`element vertex ${i}`:o),r=[];for(const[i,o]of Object.entries(t)){const a=o.map(u=>n.vertices[u]),c=this.createPLYFile(s(a.length),a,n.vertexSize),d=new Blob([c],{type:"application/octet-stream"});r.push(URL.createObjectURL(d))}return r}}var us=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function xp(l){return l&&l.__esModule&&Object.prototype.hasOwnProperty.call(l,"default")?l.default:l}function ds(l){throw new Error('Could not dynamically require "'+l+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var za={exports:{}};/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/(function(l,e){(function(t){l.exports=t()})(function(){return function t(n,s,r){function i(c,d){if(!s[c]){if(!n[c]){var u=typeof ds=="function"&&ds;if(!d&&u)return u(c,!0);if(o)return o(c,!0);var f=new Error("Cannot find module '"+c+"'");throw f.code="MODULE_NOT_FOUND",f}var h=s[c]={exports:{}};n[c][0].call(h.exports,function(g){var p=n[c][1][g];return i(p||g)},h,h.exports,t,n,s,r)}return s[c].exports}for(var o=typeof ds=="function"&&ds,a=0;a<r.length;a++)i(r[a]);return i}({1:[function(t,n,s){var r=t("./utils"),i=t("./support"),o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";s.encode=function(a){for(var c,d,u,f,h,g,p,m=[],A=0,y=a.length,v=y,x=r.getTypeOf(a)!=="string";A<a.length;)v=y-A,u=x?(c=a[A++],d=A<y?a[A++]:0,A<y?a[A++]:0):(c=a.charCodeAt(A++),d=A<y?a.charCodeAt(A++):0,A<y?a.charCodeAt(A++):0),f=c>>2,h=(3&c)<<4|d>>4,g=1<v?(15&d)<<2|u>>6:64,p=2<v?63&u:64,m.push(o.charAt(f)+o.charAt(h)+o.charAt(g)+o.charAt(p));return m.join("")},s.decode=function(a){var c,d,u,f,h,g,p=0,m=0,A="data:";if(a.substr(0,A.length)===A)throw new Error("Invalid base64 input, it looks like a data url.");var y,v=3*(a=a.replace(/[^A-Za-z0-9+/=]/g,"")).length/4;if(a.charAt(a.length-1)===o.charAt(64)&&v--,a.charAt(a.length-2)===o.charAt(64)&&v--,v%1!=0)throw new Error("Invalid base64 input, bad content length.");for(y=i.uint8array?new Uint8Array(0|v):new Array(0|v);p<a.length;)c=o.indexOf(a.charAt(p++))<<2|(f=o.indexOf(a.charAt(p++)))>>4,d=(15&f)<<4|(h=o.indexOf(a.charAt(p++)))>>2,u=(3&h)<<6|(g=o.indexOf(a.charAt(p++))),y[m++]=c,h!==64&&(y[m++]=d),g!==64&&(y[m++]=u);return y}},{"./support":30,"./utils":32}],2:[function(t,n,s){var r=t("./external"),i=t("./stream/DataWorker"),o=t("./stream/Crc32Probe"),a=t("./stream/DataLengthProbe");function c(d,u,f,h,g){this.compressedSize=d,this.uncompressedSize=u,this.crc32=f,this.compression=h,this.compressedContent=g}c.prototype={getContentWorker:function(){var d=new i(r.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")),u=this;return d.on("end",function(){if(this.streamInfo.data_length!==u.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),d},getCompressedWorker:function(){return new i(r.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},c.createWorkerFrom=function(d,u,f){return d.pipe(new o).pipe(new a("uncompressedSize")).pipe(u.compressWorker(f)).pipe(new a("compressedSize")).withStreamInfo("compression",u)},n.exports=c},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(t,n,s){var r=t("./stream/GenericWorker");s.STORE={magic:"\0\0",compressWorker:function(){return new r("STORE compression")},uncompressWorker:function(){return new r("STORE decompression")}},s.DEFLATE=t("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(t,n,s){var r=t("./utils"),i=function(){for(var o,a=[],c=0;c<256;c++){o=c;for(var d=0;d<8;d++)o=1&o?3988292384^o>>>1:o>>>1;a[c]=o}return a}();n.exports=function(o,a){return o!==void 0&&o.length?r.getTypeOf(o)!=="string"?function(c,d,u,f){var h=i,g=f+u;c^=-1;for(var p=f;p<g;p++)c=c>>>8^h[255&(c^d[p])];return-1^c}(0|a,o,o.length,0):function(c,d,u,f){var h=i,g=f+u;c^=-1;for(var p=f;p<g;p++)c=c>>>8^h[255&(c^d.charCodeAt(p))];return-1^c}(0|a,o,o.length,0):0}},{"./utils":32}],5:[function(t,n,s){s.base64=!1,s.binary=!1,s.dir=!1,s.createFolders=!0,s.date=null,s.compression=null,s.compressionOptions=null,s.comment=null,s.unixPermissions=null,s.dosPermissions=null},{}],6:[function(t,n,s){var r=null;r=typeof Promise<"u"?Promise:t("lie"),n.exports={Promise:r}},{lie:37}],7:[function(t,n,s){var r=typeof Uint8Array<"u"&&typeof Uint16Array<"u"&&typeof Uint32Array<"u",i=t("pako"),o=t("./utils"),a=t("./stream/GenericWorker"),c=r?"uint8array":"array";function d(u,f){a.call(this,"FlateWorker/"+u),this._pako=null,this._pakoAction=u,this._pakoOptions=f,this.meta={}}s.magic="\b\0",o.inherits(d,a),d.prototype.processChunk=function(u){this.meta=u.meta,this._pako===null&&this._createPako(),this._pako.push(o.transformTo(c,u.data),!1)},d.prototype.flush=function(){a.prototype.flush.call(this),this._pako===null&&this._createPako(),this._pako.push([],!0)},d.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null},d.prototype._createPako=function(){this._pako=new i[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var u=this;this._pako.onData=function(f){u.push({data:f,meta:u.meta})}},s.compressWorker=function(u){return new d("Deflate",u)},s.uncompressWorker=function(){return new d("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(t,n,s){function r(h,g){var p,m="";for(p=0;p<g;p++)m+=String.fromCharCode(255&h),h>>>=8;return m}function i(h,g,p,m,A,y){var v,x,w=h.file,T=h.compression,C=y!==c.utf8encode,E=o.transformTo("string",y(w.name)),I=o.transformTo("string",c.utf8encode(w.name)),P=w.comment,B=o.transformTo("string",y(P)),M=o.transformTo("string",c.utf8encode(P)),D=I.length!==w.name.length,_=M.length!==P.length,k="",G="",O="",$=w.dir,U=w.date,Z={crc32:0,compressedSize:0,uncompressedSize:0};g&&!p||(Z.crc32=h.crc32,Z.compressedSize=h.compressedSize,Z.uncompressedSize=h.uncompressedSize);var V=0;g&&(V|=8),C||!D&&!_||(V|=2048);var z=0,ne=0;$&&(z|=16),A==="UNIX"?(ne=798,z|=function(J,ue){var me=J;return J||(me=ue?16893:33204),(65535&me)<<16}(w.unixPermissions,$)):(ne=20,z|=function(J){return 63&(J||0)}(w.dosPermissions)),v=U.getUTCHours(),v<<=6,v|=U.getUTCMinutes(),v<<=5,v|=U.getUTCSeconds()/2,x=U.getUTCFullYear()-1980,x<<=4,x|=U.getUTCMonth()+1,x<<=5,x|=U.getUTCDate(),D&&(G=r(1,1)+r(d(E),4)+I,k+="up"+r(G.length,2)+G),_&&(O=r(1,1)+r(d(B),4)+M,k+="uc"+r(O.length,2)+O);var te="";return te+=`
\0`,te+=r(V,2),te+=T.magic,te+=r(v,2),te+=r(x,2),te+=r(Z.crc32,4),te+=r(Z.compressedSize,4),te+=r(Z.uncompressedSize,4),te+=r(E.length,2),te+=r(k.length,2),{fileRecord:u.LOCAL_FILE_HEADER+te+E+k,dirRecord:u.CENTRAL_FILE_HEADER+r(ne,2)+te+r(B.length,2)+"\0\0\0\0"+r(z,4)+r(m,4)+E+k+B}}var o=t("../utils"),a=t("../stream/GenericWorker"),c=t("../utf8"),d=t("../crc32"),u=t("../signature");function f(h,g,p,m){a.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=g,this.zipPlatform=p,this.encodeFileName=m,this.streamFiles=h,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}o.inherits(f,a),f.prototype.push=function(h){var g=h.meta.percent||0,p=this.entriesCount,m=this._sources.length;this.accumulate?this.contentBuffer.push(h):(this.bytesWritten+=h.data.length,a.prototype.push.call(this,{data:h.data,meta:{currentFile:this.currentFile,percent:p?(g+100*(p-m-1))/p:100}}))},f.prototype.openedSource=function(h){this.currentSourceOffset=this.bytesWritten,this.currentFile=h.file.name;var g=this.streamFiles&&!h.file.dir;if(g){var p=i(h,g,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:p.fileRecord,meta:{percent:0}})}else this.accumulate=!0},f.prototype.closedSource=function(h){this.accumulate=!1;var g=this.streamFiles&&!h.file.dir,p=i(h,g,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(p.dirRecord),g)this.push({data:function(m){return u.DATA_DESCRIPTOR+r(m.crc32,4)+r(m.compressedSize,4)+r(m.uncompressedSize,4)}(h),meta:{percent:100}});else for(this.push({data:p.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},f.prototype.flush=function(){for(var h=this.bytesWritten,g=0;g<this.dirRecords.length;g++)this.push({data:this.dirRecords[g],meta:{percent:100}});var p=this.bytesWritten-h,m=function(A,y,v,x,w){var T=o.transformTo("string",w(x));return u.CENTRAL_DIRECTORY_END+"\0\0\0\0"+r(A,2)+r(A,2)+r(y,4)+r(v,4)+r(T.length,2)+T}(this.dirRecords.length,p,h,this.zipComment,this.encodeFileName);this.push({data:m,meta:{percent:100}})},f.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},f.prototype.registerPrevious=function(h){this._sources.push(h);var g=this;return h.on("data",function(p){g.processChunk(p)}),h.on("end",function(){g.closedSource(g.previous.streamInfo),g._sources.length?g.prepareNextSource():g.end()}),h.on("error",function(p){g.error(p)}),this},f.prototype.resume=function(){return!!a.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},f.prototype.error=function(h){var g=this._sources;if(!a.prototype.error.call(this,h))return!1;for(var p=0;p<g.length;p++)try{g[p].error(h)}catch{}return!0},f.prototype.lock=function(){a.prototype.lock.call(this);for(var h=this._sources,g=0;g<h.length;g++)h[g].lock()},n.exports=f},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(t,n,s){var r=t("../compressions"),i=t("./ZipFileWorker");s.generateWorker=function(o,a,c){var d=new i(a.streamFiles,c,a.platform,a.encodeFileName),u=0;try{o.forEach(function(f,h){u++;var g=function(y,v){var x=y||v,w=r[x];if(!w)throw new Error(x+" is not a valid compression method !");return w}(h.options.compression,a.compression),p=h.options.compressionOptions||a.compressionOptions||{},m=h.dir,A=h.date;h._compressWorker(g,p).withStreamInfo("file",{name:f,dir:m,date:A,comment:h.comment||"",unixPermissions:h.unixPermissions,dosPermissions:h.dosPermissions}).pipe(d)}),d.entriesCount=u}catch(f){d.error(f)}return d}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(t,n,s){function r(){if(!(this instanceof r))return new r;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files=Object.create(null),this.comment=null,this.root="",this.clone=function(){var i=new r;for(var o in this)typeof this[o]!="function"&&(i[o]=this[o]);return i}}(r.prototype=t("./object")).loadAsync=t("./load"),r.support=t("./support"),r.defaults=t("./defaults"),r.version="3.10.1",r.loadAsync=function(i,o){return new r().loadAsync(i,o)},r.external=t("./external"),n.exports=r},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(t,n,s){var r=t("./utils"),i=t("./external"),o=t("./utf8"),a=t("./zipEntries"),c=t("./stream/Crc32Probe"),d=t("./nodejsUtils");function u(f){return new i.Promise(function(h,g){var p=f.decompressed.getContentWorker().pipe(new c);p.on("error",function(m){g(m)}).on("end",function(){p.streamInfo.crc32!==f.decompressed.crc32?g(new Error("Corrupted zip : CRC32 mismatch")):h()}).resume()})}n.exports=function(f,h){var g=this;return h=r.extend(h||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:o.utf8decode}),d.isNode&&d.isStream(f)?i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):r.prepareContent("the loaded zip file",f,!0,h.optimizedBinaryString,h.base64).then(function(p){var m=new a(h);return m.load(p),m}).then(function(p){var m=[i.Promise.resolve(p)],A=p.files;if(h.checkCRC32)for(var y=0;y<A.length;y++)m.push(u(A[y]));return i.Promise.all(m)}).then(function(p){for(var m=p.shift(),A=m.files,y=0;y<A.length;y++){var v=A[y],x=v.fileNameStr,w=r.resolve(v.fileNameStr);g.file(w,v.decompressed,{binary:!0,optimizedBinaryString:!0,date:v.date,dir:v.dir,comment:v.fileCommentStr.length?v.fileCommentStr:null,unixPermissions:v.unixPermissions,dosPermissions:v.dosPermissions,createFolders:h.createFolders}),v.dir||(g.file(w).unsafeOriginalName=x)}return m.zipComment.length&&(g.comment=m.zipComment),g})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(t,n,s){var r=t("../utils"),i=t("../stream/GenericWorker");function o(a,c){i.call(this,"Nodejs stream input adapter for "+a),this._upstreamEnded=!1,this._bindStream(c)}r.inherits(o,i),o.prototype._bindStream=function(a){var c=this;(this._stream=a).pause(),a.on("data",function(d){c.push({data:d,meta:{percent:0}})}).on("error",function(d){c.isPaused?this.generatedError=d:c.error(d)}).on("end",function(){c.isPaused?c._upstreamEnded=!0:c.end()})},o.prototype.pause=function(){return!!i.prototype.pause.call(this)&&(this._stream.pause(),!0)},o.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},n.exports=o},{"../stream/GenericWorker":28,"../utils":32}],13:[function(t,n,s){var r=t("readable-stream").Readable;function i(o,a,c){r.call(this,a),this._helper=o;var d=this;o.on("data",function(u,f){d.push(u)||d._helper.pause(),c&&c(f)}).on("error",function(u){d.emit("error",u)}).on("end",function(){d.push(null)})}t("../utils").inherits(i,r),i.prototype._read=function(){this._helper.resume()},n.exports=i},{"../utils":32,"readable-stream":16}],14:[function(t,n,s){n.exports={isNode:typeof Buffer<"u",newBufferFrom:function(r,i){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(r,i);if(typeof r=="number")throw new Error('The "data" argument must not be a number');return new Buffer(r,i)},allocBuffer:function(r){if(Buffer.alloc)return Buffer.alloc(r);var i=new Buffer(r);return i.fill(0),i},isBuffer:function(r){return Buffer.isBuffer(r)},isStream:function(r){return r&&typeof r.on=="function"&&typeof r.pause=="function"&&typeof r.resume=="function"}}},{}],15:[function(t,n,s){function r(w,T,C){var E,I=o.getTypeOf(T),P=o.extend(C||{},d);P.date=P.date||new Date,P.compression!==null&&(P.compression=P.compression.toUpperCase()),typeof P.unixPermissions=="string"&&(P.unixPermissions=parseInt(P.unixPermissions,8)),P.unixPermissions&&16384&P.unixPermissions&&(P.dir=!0),P.dosPermissions&&16&P.dosPermissions&&(P.dir=!0),P.dir&&(w=A(w)),P.createFolders&&(E=m(w))&&y.call(this,E,!0);var B=I==="string"&&P.binary===!1&&P.base64===!1;C&&C.binary!==void 0||(P.binary=!B),(T instanceof u&&T.uncompressedSize===0||P.dir||!T||T.length===0)&&(P.base64=!1,P.binary=!0,T="",P.compression="STORE",I="string");var M=null;M=T instanceof u||T instanceof a?T:g.isNode&&g.isStream(T)?new p(w,T):o.prepareContent(w,T,P.binary,P.optimizedBinaryString,P.base64);var D=new f(w,M,P);this.files[w]=D}var i=t("./utf8"),o=t("./utils"),a=t("./stream/GenericWorker"),c=t("./stream/StreamHelper"),d=t("./defaults"),u=t("./compressedObject"),f=t("./zipObject"),h=t("./generate"),g=t("./nodejsUtils"),p=t("./nodejs/NodejsStreamInputAdapter"),m=function(w){w.slice(-1)==="/"&&(w=w.substring(0,w.length-1));var T=w.lastIndexOf("/");return 0<T?w.substring(0,T):""},A=function(w){return w.slice(-1)!=="/"&&(w+="/"),w},y=function(w,T){return T=T!==void 0?T:d.createFolders,w=A(w),this.files[w]||r.call(this,w,null,{dir:!0,createFolders:T}),this.files[w]};function v(w){return Object.prototype.toString.call(w)==="[object RegExp]"}var x={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(w){var T,C,E;for(T in this.files)E=this.files[T],(C=T.slice(this.root.length,T.length))&&T.slice(0,this.root.length)===this.root&&w(C,E)},filter:function(w){var T=[];return this.forEach(function(C,E){w(C,E)&&T.push(E)}),T},file:function(w,T,C){if(arguments.length!==1)return w=this.root+w,r.call(this,w,T,C),this;if(v(w)){var E=w;return this.filter(function(P,B){return!B.dir&&E.test(P)})}var I=this.files[this.root+w];return I&&!I.dir?I:null},folder:function(w){if(!w)return this;if(v(w))return this.filter(function(I,P){return P.dir&&w.test(I)});var T=this.root+w,C=y.call(this,T),E=this.clone();return E.root=C.name,E},remove:function(w){w=this.root+w;var T=this.files[w];if(T||(w.slice(-1)!=="/"&&(w+="/"),T=this.files[w]),T&&!T.dir)delete this.files[w];else for(var C=this.filter(function(I,P){return P.name.slice(0,w.length)===w}),E=0;E<C.length;E++)delete this.files[C[E].name];return this},generate:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(w){var T,C={};try{if((C=o.extend(w||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:i.utf8encode})).type=C.type.toLowerCase(),C.compression=C.compression.toUpperCase(),C.type==="binarystring"&&(C.type="string"),!C.type)throw new Error("No output type specified.");o.checkSupport(C.type),C.platform!=="darwin"&&C.platform!=="freebsd"&&C.platform!=="linux"&&C.platform!=="sunos"||(C.platform="UNIX"),C.platform==="win32"&&(C.platform="DOS");var E=C.comment||this.comment||"";T=h.generateWorker(this,C,E)}catch(I){(T=new a("error")).error(I)}return new c(T,C.type||"string",C.mimeType)},generateAsync:function(w,T){return this.generateInternalStream(w).accumulate(T)},generateNodeStream:function(w,T){return(w=w||{}).type||(w.type="nodebuffer"),this.generateInternalStream(w).toNodejsStream(T)}};n.exports=x},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(t,n,s){n.exports=t("stream")},{stream:void 0}],17:[function(t,n,s){var r=t("./DataReader");function i(o){r.call(this,o);for(var a=0;a<this.data.length;a++)o[a]=255&o[a]}t("../utils").inherits(i,r),i.prototype.byteAt=function(o){return this.data[this.zero+o]},i.prototype.lastIndexOfSignature=function(o){for(var a=o.charCodeAt(0),c=o.charCodeAt(1),d=o.charCodeAt(2),u=o.charCodeAt(3),f=this.length-4;0<=f;--f)if(this.data[f]===a&&this.data[f+1]===c&&this.data[f+2]===d&&this.data[f+3]===u)return f-this.zero;return-1},i.prototype.readAndCheckSignature=function(o){var a=o.charCodeAt(0),c=o.charCodeAt(1),d=o.charCodeAt(2),u=o.charCodeAt(3),f=this.readData(4);return a===f[0]&&c===f[1]&&d===f[2]&&u===f[3]},i.prototype.readData=function(o){if(this.checkOffset(o),o===0)return[];var a=this.data.slice(this.zero+this.index,this.zero+this.index+o);return this.index+=o,a},n.exports=i},{"../utils":32,"./DataReader":18}],18:[function(t,n,s){var r=t("../utils");function i(o){this.data=o,this.length=o.length,this.index=0,this.zero=0}i.prototype={checkOffset:function(o){this.checkIndex(this.index+o)},checkIndex:function(o){if(this.length<this.zero+o||o<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+o+"). Corrupted zip ?")},setIndex:function(o){this.checkIndex(o),this.index=o},skip:function(o){this.setIndex(this.index+o)},byteAt:function(){},readInt:function(o){var a,c=0;for(this.checkOffset(o),a=this.index+o-1;a>=this.index;a--)c=(c<<8)+this.byteAt(a);return this.index+=o,c},readString:function(o){return r.transformTo("string",this.readData(o))},readData:function(){},lastIndexOfSignature:function(){},readAndCheckSignature:function(){},readDate:function(){var o=this.readInt(4);return new Date(Date.UTC(1980+(o>>25&127),(o>>21&15)-1,o>>16&31,o>>11&31,o>>5&63,(31&o)<<1))}},n.exports=i},{"../utils":32}],19:[function(t,n,s){var r=t("./Uint8ArrayReader");function i(o){r.call(this,o)}t("../utils").inherits(i,r),i.prototype.readData=function(o){this.checkOffset(o);var a=this.data.slice(this.zero+this.index,this.zero+this.index+o);return this.index+=o,a},n.exports=i},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(t,n,s){var r=t("./DataReader");function i(o){r.call(this,o)}t("../utils").inherits(i,r),i.prototype.byteAt=function(o){return this.data.charCodeAt(this.zero+o)},i.prototype.lastIndexOfSignature=function(o){return this.data.lastIndexOf(o)-this.zero},i.prototype.readAndCheckSignature=function(o){return o===this.readData(4)},i.prototype.readData=function(o){this.checkOffset(o);var a=this.data.slice(this.zero+this.index,this.zero+this.index+o);return this.index+=o,a},n.exports=i},{"../utils":32,"./DataReader":18}],21:[function(t,n,s){var r=t("./ArrayReader");function i(o){r.call(this,o)}t("../utils").inherits(i,r),i.prototype.readData=function(o){if(this.checkOffset(o),o===0)return new Uint8Array(0);var a=this.data.subarray(this.zero+this.index,this.zero+this.index+o);return this.index+=o,a},n.exports=i},{"../utils":32,"./ArrayReader":17}],22:[function(t,n,s){var r=t("../utils"),i=t("../support"),o=t("./ArrayReader"),a=t("./StringReader"),c=t("./NodeBufferReader"),d=t("./Uint8ArrayReader");n.exports=function(u){var f=r.getTypeOf(u);return r.checkSupport(f),f!=="string"||i.uint8array?f==="nodebuffer"?new c(u):i.uint8array?new d(r.transformTo("uint8array",u)):new o(r.transformTo("array",u)):new a(u)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(t,n,s){s.LOCAL_FILE_HEADER="PK",s.CENTRAL_FILE_HEADER="PK",s.CENTRAL_DIRECTORY_END="PK",s.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK\x07",s.ZIP64_CENTRAL_DIRECTORY_END="PK",s.DATA_DESCRIPTOR="PK\x07\b"},{}],24:[function(t,n,s){var r=t("./GenericWorker"),i=t("../utils");function o(a){r.call(this,"ConvertWorker to "+a),this.destType=a}i.inherits(o,r),o.prototype.processChunk=function(a){this.push({data:i.transformTo(this.destType,a.data),meta:a.meta})},n.exports=o},{"../utils":32,"./GenericWorker":28}],25:[function(t,n,s){var r=t("./GenericWorker"),i=t("../crc32");function o(){r.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}t("../utils").inherits(o,r),o.prototype.processChunk=function(a){this.streamInfo.crc32=i(a.data,this.streamInfo.crc32||0),this.push(a)},n.exports=o},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(t,n,s){var r=t("../utils"),i=t("./GenericWorker");function o(a){i.call(this,"DataLengthProbe for "+a),this.propName=a,this.withStreamInfo(a,0)}r.inherits(o,i),o.prototype.processChunk=function(a){if(a){var c=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=c+a.data.length}i.prototype.processChunk.call(this,a)},n.exports=o},{"../utils":32,"./GenericWorker":28}],27:[function(t,n,s){var r=t("../utils"),i=t("./GenericWorker");function o(a){i.call(this,"DataWorker");var c=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,a.then(function(d){c.dataIsReady=!0,c.data=d,c.max=d&&d.length||0,c.type=r.getTypeOf(d),c.isPaused||c._tickAndRepeat()},function(d){c.error(d)})}r.inherits(o,i),o.prototype.cleanUp=function(){i.prototype.cleanUp.call(this),this.data=null},o.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,r.delay(this._tickAndRepeat,[],this)),!0)},o.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(r.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},o.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var a=null,c=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":a=this.data.substring(this.index,c);break;case"uint8array":a=this.data.subarray(this.index,c);break;case"array":case"nodebuffer":a=this.data.slice(this.index,c)}return this.index=c,this.push({data:a,meta:{percent:this.max?this.index/this.max*100:0}})},n.exports=o},{"../utils":32,"./GenericWorker":28}],28:[function(t,n,s){function r(i){this.name=i||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}r.prototype={push:function(i){this.emit("data",i)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(i){this.emit("error",i)}return!0},error:function(i){return!this.isFinished&&(this.isPaused?this.generatedError=i:(this.isFinished=!0,this.emit("error",i),this.previous&&this.previous.error(i),this.cleanUp()),!0)},on:function(i,o){return this._listeners[i].push(o),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(i,o){if(this._listeners[i])for(var a=0;a<this._listeners[i].length;a++)this._listeners[i][a].call(this,o)},pipe:function(i){return i.registerPrevious(this)},registerPrevious:function(i){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=i.streamInfo,this.mergeStreamInfo(),this.previous=i;var o=this;return i.on("data",function(a){o.processChunk(a)}),i.on("end",function(){o.end()}),i.on("error",function(a){o.error(a)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var i=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),i=!0),this.previous&&this.previous.resume(),!i},flush:function(){},processChunk:function(i){this.push(i)},withStreamInfo:function(i,o){return this.extraStreamInfo[i]=o,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var i in this.extraStreamInfo)Object.prototype.hasOwnProperty.call(this.extraStreamInfo,i)&&(this.streamInfo[i]=this.extraStreamInfo[i])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var i="Worker "+this.name;return this.previous?this.previous+" -> "+i:i}},n.exports=r},{}],29:[function(t,n,s){var r=t("../utils"),i=t("./ConvertWorker"),o=t("./GenericWorker"),a=t("../base64"),c=t("../support"),d=t("../external"),u=null;if(c.nodestream)try{u=t("../nodejs/NodejsStreamOutputAdapter")}catch{}function f(g,p){return new d.Promise(function(m,A){var y=[],v=g._internalType,x=g._outputType,w=g._mimeType;g.on("data",function(T,C){y.push(T),p&&p(C)}).on("error",function(T){y=[],A(T)}).on("end",function(){try{var T=function(C,E,I){switch(C){case"blob":return r.newBlob(r.transformTo("arraybuffer",E),I);case"base64":return a.encode(E);default:return r.transformTo(C,E)}}(x,function(C,E){var I,P=0,B=null,M=0;for(I=0;I<E.length;I++)M+=E[I].length;switch(C){case"string":return E.join("");case"array":return Array.prototype.concat.apply([],E);case"uint8array":for(B=new Uint8Array(M),I=0;I<E.length;I++)B.set(E[I],P),P+=E[I].length;return B;case"nodebuffer":return Buffer.concat(E);default:throw new Error("concat : unsupported type '"+C+"'")}}(v,y),w);m(T)}catch(C){A(C)}y=[]}).resume()})}function h(g,p,m){var A=p;switch(p){case"blob":case"arraybuffer":A="uint8array";break;case"base64":A="string"}try{this._internalType=A,this._outputType=p,this._mimeType=m,r.checkSupport(A),this._worker=g.pipe(new i(A)),g.lock()}catch(y){this._worker=new o("error"),this._worker.error(y)}}h.prototype={accumulate:function(g){return f(this,g)},on:function(g,p){var m=this;return g==="data"?this._worker.on(g,function(A){p.call(m,A.data,A.meta)}):this._worker.on(g,function(){r.delay(p,arguments,m)}),this},resume:function(){return r.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(g){if(r.checkSupport("nodestream"),this._outputType!=="nodebuffer")throw new Error(this._outputType+" is not supported by this method");return new u(this,{objectMode:this._outputType!=="nodebuffer"},g)}},n.exports=h},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(t,n,s){if(s.base64=!0,s.array=!0,s.string=!0,s.arraybuffer=typeof ArrayBuffer<"u"&&typeof Uint8Array<"u",s.nodebuffer=typeof Buffer<"u",s.uint8array=typeof Uint8Array<"u",typeof ArrayBuffer>"u")s.blob=!1;else{var r=new ArrayBuffer(0);try{s.blob=new Blob([r],{type:"application/zip"}).size===0}catch{try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);i.append(r),s.blob=i.getBlob("application/zip").size===0}catch{s.blob=!1}}}try{s.nodestream=!!t("readable-stream").Readable}catch{s.nodestream=!1}},{"readable-stream":16}],31:[function(t,n,s){for(var r=t("./utils"),i=t("./support"),o=t("./nodejsUtils"),a=t("./stream/GenericWorker"),c=new Array(256),d=0;d<256;d++)c[d]=252<=d?6:248<=d?5:240<=d?4:224<=d?3:192<=d?2:1;c[254]=c[254]=1;function u(){a.call(this,"utf-8 decode"),this.leftOver=null}function f(){a.call(this,"utf-8 encode")}s.utf8encode=function(h){return i.nodebuffer?o.newBufferFrom(h,"utf-8"):function(g){var p,m,A,y,v,x=g.length,w=0;for(y=0;y<x;y++)(64512&(m=g.charCodeAt(y)))==55296&&y+1<x&&(64512&(A=g.charCodeAt(y+1)))==56320&&(m=65536+(m-55296<<10)+(A-56320),y++),w+=m<128?1:m<2048?2:m<65536?3:4;for(p=i.uint8array?new Uint8Array(w):new Array(w),y=v=0;v<w;y++)(64512&(m=g.charCodeAt(y)))==55296&&y+1<x&&(64512&(A=g.charCodeAt(y+1)))==56320&&(m=65536+(m-55296<<10)+(A-56320),y++),m<128?p[v++]=m:(m<2048?p[v++]=192|m>>>6:(m<65536?p[v++]=224|m>>>12:(p[v++]=240|m>>>18,p[v++]=128|m>>>12&63),p[v++]=128|m>>>6&63),p[v++]=128|63&m);return p}(h)},s.utf8decode=function(h){return i.nodebuffer?r.transformTo("nodebuffer",h).toString("utf-8"):function(g){var p,m,A,y,v=g.length,x=new Array(2*v);for(p=m=0;p<v;)if((A=g[p++])<128)x[m++]=A;else if(4<(y=c[A]))x[m++]=65533,p+=y-1;else{for(A&=y===2?31:y===3?15:7;1<y&&p<v;)A=A<<6|63&g[p++],y--;1<y?x[m++]=65533:A<65536?x[m++]=A:(A-=65536,x[m++]=55296|A>>10&1023,x[m++]=56320|1023&A)}return x.length!==m&&(x.subarray?x=x.subarray(0,m):x.length=m),r.applyFromCharCode(x)}(h=r.transformTo(i.uint8array?"uint8array":"array",h))},r.inherits(u,a),u.prototype.processChunk=function(h){var g=r.transformTo(i.uint8array?"uint8array":"array",h.data);if(this.leftOver&&this.leftOver.length){if(i.uint8array){var p=g;(g=new Uint8Array(p.length+this.leftOver.length)).set(this.leftOver,0),g.set(p,this.leftOver.length)}else g=this.leftOver.concat(g);this.leftOver=null}var m=function(y,v){var x;for((v=v||y.length)>y.length&&(v=y.length),x=v-1;0<=x&&(192&y[x])==128;)x--;return x<0||x===0?v:x+c[y[x]]>v?x:v}(g),A=g;m!==g.length&&(i.uint8array?(A=g.subarray(0,m),this.leftOver=g.subarray(m,g.length)):(A=g.slice(0,m),this.leftOver=g.slice(m,g.length))),this.push({data:s.utf8decode(A),meta:h.meta})},u.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},s.Utf8DecodeWorker=u,r.inherits(f,a),f.prototype.processChunk=function(h){this.push({data:s.utf8encode(h.data),meta:h.meta})},s.Utf8EncodeWorker=f},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(t,n,s){var r=t("./support"),i=t("./base64"),o=t("./nodejsUtils"),a=t("./external");function c(p){return p}function d(p,m){for(var A=0;A<p.length;++A)m[A]=255&p.charCodeAt(A);return m}t("setimmediate"),s.newBlob=function(p,m){s.checkSupport("blob");try{return new Blob([p],{type:m})}catch{try{var A=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return A.append(p),A.getBlob(m)}catch{throw new Error("Bug : can't construct the Blob.")}}};var u={stringifyByChunk:function(p,m,A){var y=[],v=0,x=p.length;if(x<=A)return String.fromCharCode.apply(null,p);for(;v<x;)m==="array"||m==="nodebuffer"?y.push(String.fromCharCode.apply(null,p.slice(v,Math.min(v+A,x)))):y.push(String.fromCharCode.apply(null,p.subarray(v,Math.min(v+A,x)))),v+=A;return y.join("")},stringifyByChar:function(p){for(var m="",A=0;A<p.length;A++)m+=String.fromCharCode(p[A]);return m},applyCanBeUsed:{uint8array:function(){try{return r.uint8array&&String.fromCharCode.apply(null,new Uint8Array(1)).length===1}catch{return!1}}(),nodebuffer:function(){try{return r.nodebuffer&&String.fromCharCode.apply(null,o.allocBuffer(1)).length===1}catch{return!1}}()}};function f(p){var m=65536,A=s.getTypeOf(p),y=!0;if(A==="uint8array"?y=u.applyCanBeUsed.uint8array:A==="nodebuffer"&&(y=u.applyCanBeUsed.nodebuffer),y)for(;1<m;)try{return u.stringifyByChunk(p,A,m)}catch{m=Math.floor(m/2)}return u.stringifyByChar(p)}function h(p,m){for(var A=0;A<p.length;A++)m[A]=p[A];return m}s.applyFromCharCode=f;var g={};g.string={string:c,array:function(p){return d(p,new Array(p.length))},arraybuffer:function(p){return g.string.uint8array(p).buffer},uint8array:function(p){return d(p,new Uint8Array(p.length))},nodebuffer:function(p){return d(p,o.allocBuffer(p.length))}},g.array={string:f,array:c,arraybuffer:function(p){return new Uint8Array(p).buffer},uint8array:function(p){return new Uint8Array(p)},nodebuffer:function(p){return o.newBufferFrom(p)}},g.arraybuffer={string:function(p){return f(new Uint8Array(p))},array:function(p){return h(new Uint8Array(p),new Array(p.byteLength))},arraybuffer:c,uint8array:function(p){return new Uint8Array(p)},nodebuffer:function(p){return o.newBufferFrom(new Uint8Array(p))}},g.uint8array={string:f,array:function(p){return h(p,new Array(p.length))},arraybuffer:function(p){return p.buffer},uint8array:c,nodebuffer:function(p){return o.newBufferFrom(p)}},g.nodebuffer={string:f,array:function(p){return h(p,new Array(p.length))},arraybuffer:function(p){return g.nodebuffer.uint8array(p).buffer},uint8array:function(p){return h(p,new Uint8Array(p.length))},nodebuffer:c},s.transformTo=function(p,m){if(m=m||"",!p)return m;s.checkSupport(p);var A=s.getTypeOf(m);return g[A][p](m)},s.resolve=function(p){for(var m=p.split("/"),A=[],y=0;y<m.length;y++){var v=m[y];v==="."||v===""&&y!==0&&y!==m.length-1||(v===".."?A.pop():A.push(v))}return A.join("/")},s.getTypeOf=function(p){return typeof p=="string"?"string":Object.prototype.toString.call(p)==="[object Array]"?"array":r.nodebuffer&&o.isBuffer(p)?"nodebuffer":r.uint8array&&p instanceof Uint8Array?"uint8array":r.arraybuffer&&p instanceof ArrayBuffer?"arraybuffer":void 0},s.checkSupport=function(p){if(!r[p.toLowerCase()])throw new Error(p+" is not supported by this platform")},s.MAX_VALUE_16BITS=65535,s.MAX_VALUE_32BITS=-1,s.pretty=function(p){var m,A,y="";for(A=0;A<(p||"").length;A++)y+="\\x"+((m=p.charCodeAt(A))<16?"0":"")+m.toString(16).toUpperCase();return y},s.delay=function(p,m,A){setImmediate(function(){p.apply(A||null,m||[])})},s.inherits=function(p,m){function A(){}A.prototype=m.prototype,p.prototype=new A},s.extend=function(){var p,m,A={};for(p=0;p<arguments.length;p++)for(m in arguments[p])Object.prototype.hasOwnProperty.call(arguments[p],m)&&A[m]===void 0&&(A[m]=arguments[p][m]);return A},s.prepareContent=function(p,m,A,y,v){return a.Promise.resolve(m).then(function(x){return r.blob&&(x instanceof Blob||["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(x))!==-1)&&typeof FileReader<"u"?new a.Promise(function(w,T){var C=new FileReader;C.onload=function(E){w(E.target.result)},C.onerror=function(E){T(E.target.error)},C.readAsArrayBuffer(x)}):x}).then(function(x){var w=s.getTypeOf(x);return w?(w==="arraybuffer"?x=s.transformTo("uint8array",x):w==="string"&&(v?x=i.decode(x):A&&y!==!0&&(x=function(T){return d(T,r.uint8array?new Uint8Array(T.length):new Array(T.length))}(x))),x):a.Promise.reject(new Error("Can't read the data of '"+p+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,setimmediate:54}],33:[function(t,n,s){var r=t("./reader/readerFor"),i=t("./utils"),o=t("./signature"),a=t("./zipEntry"),c=t("./support");function d(u){this.files=[],this.loadOptions=u}d.prototype={checkSignature:function(u){if(!this.reader.readAndCheckSignature(u)){this.reader.index-=4;var f=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+i.pretty(f)+", expected "+i.pretty(u)+")")}},isSignature:function(u,f){var h=this.reader.index;this.reader.setIndex(u);var g=this.reader.readString(4)===f;return this.reader.setIndex(h),g},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var u=this.reader.readData(this.zipCommentLength),f=c.uint8array?"uint8array":"array",h=i.transformTo(f,u);this.zipComment=this.loadOptions.decodeFileName(h)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var u,f,h,g=this.zip64EndOfCentralSize-44;0<g;)u=this.reader.readInt(2),f=this.reader.readInt(4),h=this.reader.readData(f),this.zip64ExtensibleData[u]={id:u,length:f,value:h}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var u,f;for(u=0;u<this.files.length;u++)f=this.files[u],this.reader.setIndex(f.localHeaderOffset),this.checkSignature(o.LOCAL_FILE_HEADER),f.readLocalPart(this.reader),f.handleUTF8(),f.processAttributes()},readCentralDir:function(){var u;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(o.CENTRAL_FILE_HEADER);)(u=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(u);if(this.centralDirRecords!==this.files.length&&this.centralDirRecords!==0&&this.files.length===0)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var u=this.reader.lastIndexOfSignature(o.CENTRAL_DIRECTORY_END);if(u<0)throw this.isSignature(0,o.LOCAL_FILE_HEADER)?new Error("Corrupted zip: can't find end of central directory"):new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");this.reader.setIndex(u);var f=u;if(this.checkSignature(o.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===i.MAX_VALUE_16BITS||this.diskWithCentralDirStart===i.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===i.MAX_VALUE_16BITS||this.centralDirRecords===i.MAX_VALUE_16BITS||this.centralDirSize===i.MAX_VALUE_32BITS||this.centralDirOffset===i.MAX_VALUE_32BITS){if(this.zip64=!0,(u=this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(u),this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,o.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var h=this.centralDirOffset+this.centralDirSize;this.zip64&&(h+=20,h+=12+this.zip64EndOfCentralSize);var g=f-h;if(0<g)this.isSignature(f,o.CENTRAL_FILE_HEADER)||(this.reader.zero=g);else if(g<0)throw new Error("Corrupted zip: missing "+Math.abs(g)+" bytes.")},prepareReader:function(u){this.reader=r(u)},load:function(u){this.prepareReader(u),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},n.exports=d},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utils":32,"./zipEntry":34}],34:[function(t,n,s){var r=t("./reader/readerFor"),i=t("./utils"),o=t("./compressedObject"),a=t("./crc32"),c=t("./utf8"),d=t("./compressions"),u=t("./support");function f(h,g){this.options=h,this.loadOptions=g}f.prototype={isEncrypted:function(){return(1&this.bitFlag)==1},useUTF8:function(){return(2048&this.bitFlag)==2048},readLocalPart:function(h){var g,p;if(h.skip(22),this.fileNameLength=h.readInt(2),p=h.readInt(2),this.fileName=h.readData(this.fileNameLength),h.skip(p),this.compressedSize===-1||this.uncompressedSize===-1)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if((g=function(m){for(var A in d)if(Object.prototype.hasOwnProperty.call(d,A)&&d[A].magic===m)return d[A];return null}(this.compressionMethod))===null)throw new Error("Corrupted zip : compression "+i.pretty(this.compressionMethod)+" unknown (inner file : "+i.transformTo("string",this.fileName)+")");this.decompressed=new o(this.compressedSize,this.uncompressedSize,this.crc32,g,h.readData(this.compressedSize))},readCentralPart:function(h){this.versionMadeBy=h.readInt(2),h.skip(2),this.bitFlag=h.readInt(2),this.compressionMethod=h.readString(2),this.date=h.readDate(),this.crc32=h.readInt(4),this.compressedSize=h.readInt(4),this.uncompressedSize=h.readInt(4);var g=h.readInt(2);if(this.extraFieldsLength=h.readInt(2),this.fileCommentLength=h.readInt(2),this.diskNumberStart=h.readInt(2),this.internalFileAttributes=h.readInt(2),this.externalFileAttributes=h.readInt(4),this.localHeaderOffset=h.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");h.skip(g),this.readExtraFields(h),this.parseZIP64ExtraField(h),this.fileComment=h.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var h=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),h==0&&(this.dosPermissions=63&this.externalFileAttributes),h==3&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||this.fileNameStr.slice(-1)!=="/"||(this.dir=!0)},parseZIP64ExtraField:function(){if(this.extraFields[1]){var h=r(this.extraFields[1].value);this.uncompressedSize===i.MAX_VALUE_32BITS&&(this.uncompressedSize=h.readInt(8)),this.compressedSize===i.MAX_VALUE_32BITS&&(this.compressedSize=h.readInt(8)),this.localHeaderOffset===i.MAX_VALUE_32BITS&&(this.localHeaderOffset=h.readInt(8)),this.diskNumberStart===i.MAX_VALUE_32BITS&&(this.diskNumberStart=h.readInt(4))}},readExtraFields:function(h){var g,p,m,A=h.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});h.index+4<A;)g=h.readInt(2),p=h.readInt(2),m=h.readData(p),this.extraFields[g]={id:g,length:p,value:m};h.setIndex(A)},handleUTF8:function(){var h=u.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=c.utf8decode(this.fileName),this.fileCommentStr=c.utf8decode(this.fileComment);else{var g=this.findExtraFieldUnicodePath();if(g!==null)this.fileNameStr=g;else{var p=i.transformTo(h,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(p)}var m=this.findExtraFieldUnicodeComment();if(m!==null)this.fileCommentStr=m;else{var A=i.transformTo(h,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(A)}}},findExtraFieldUnicodePath:function(){var h=this.extraFields[28789];if(h){var g=r(h.value);return g.readInt(1)!==1||a(this.fileName)!==g.readInt(4)?null:c.utf8decode(g.readData(h.length-5))}return null},findExtraFieldUnicodeComment:function(){var h=this.extraFields[25461];if(h){var g=r(h.value);return g.readInt(1)!==1||a(this.fileComment)!==g.readInt(4)?null:c.utf8decode(g.readData(h.length-5))}return null}},n.exports=f},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(t,n,s){function r(g,p,m){this.name=g,this.dir=m.dir,this.date=m.date,this.comment=m.comment,this.unixPermissions=m.unixPermissions,this.dosPermissions=m.dosPermissions,this._data=p,this._dataBinary=m.binary,this.options={compression:m.compression,compressionOptions:m.compressionOptions}}var i=t("./stream/StreamHelper"),o=t("./stream/DataWorker"),a=t("./utf8"),c=t("./compressedObject"),d=t("./stream/GenericWorker");r.prototype={internalStream:function(g){var p=null,m="string";try{if(!g)throw new Error("No output type specified.");var A=(m=g.toLowerCase())==="string"||m==="text";m!=="binarystring"&&m!=="text"||(m="string"),p=this._decompressWorker();var y=!this._dataBinary;y&&!A&&(p=p.pipe(new a.Utf8EncodeWorker)),!y&&A&&(p=p.pipe(new a.Utf8DecodeWorker))}catch(v){(p=new d("error")).error(v)}return new i(p,m,"")},async:function(g,p){return this.internalStream(g).accumulate(p)},nodeStream:function(g,p){return this.internalStream(g||"nodebuffer").toNodejsStream(p)},_compressWorker:function(g,p){if(this._data instanceof c&&this._data.compression.magic===g.magic)return this._data.getCompressedWorker();var m=this._decompressWorker();return this._dataBinary||(m=m.pipe(new a.Utf8EncodeWorker)),c.createWorkerFrom(m,g,p)},_decompressWorker:function(){return this._data instanceof c?this._data.getContentWorker():this._data instanceof d?this._data:new o(this._data)}};for(var u=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],f=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},h=0;h<u.length;h++)r.prototype[u[h]]=f;n.exports=r},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(t,n,s){(function(r){var i,o,a=r.MutationObserver||r.WebKitMutationObserver;if(a){var c=0,d=new a(g),u=r.document.createTextNode("");d.observe(u,{characterData:!0}),i=function(){u.data=c=++c%2}}else if(r.setImmediate||r.MessageChannel===void 0)i="document"in r&&"onreadystatechange"in r.document.createElement("script")?function(){var p=r.document.createElement("script");p.onreadystatechange=function(){g(),p.onreadystatechange=null,p.parentNode.removeChild(p),p=null},r.document.documentElement.appendChild(p)}:function(){setTimeout(g,0)};else{var f=new r.MessageChannel;f.port1.onmessage=g,i=function(){f.port2.postMessage(0)}}var h=[];function g(){var p,m;o=!0;for(var A=h.length;A;){for(m=h,h=[],p=-1;++p<A;)m[p]();A=h.length}o=!1}n.exports=function(p){h.push(p)!==1||o||i()}}).call(this,typeof us<"u"?us:typeof self<"u"?self:typeof window<"u"?window:{})},{}],37:[function(t,n,s){var r=t("immediate");function i(){}var o={},a=["REJECTED"],c=["FULFILLED"],d=["PENDING"];function u(A){if(typeof A!="function")throw new TypeError("resolver must be a function");this.state=d,this.queue=[],this.outcome=void 0,A!==i&&p(this,A)}function f(A,y,v){this.promise=A,typeof y=="function"&&(this.onFulfilled=y,this.callFulfilled=this.otherCallFulfilled),typeof v=="function"&&(this.onRejected=v,this.callRejected=this.otherCallRejected)}function h(A,y,v){r(function(){var x;try{x=y(v)}catch(w){return o.reject(A,w)}x===A?o.reject(A,new TypeError("Cannot resolve promise with itself")):o.resolve(A,x)})}function g(A){var y=A&&A.then;if(A&&(typeof A=="object"||typeof A=="function")&&typeof y=="function")return function(){y.apply(A,arguments)}}function p(A,y){var v=!1;function x(C){v||(v=!0,o.reject(A,C))}function w(C){v||(v=!0,o.resolve(A,C))}var T=m(function(){y(w,x)});T.status==="error"&&x(T.value)}function m(A,y){var v={};try{v.value=A(y),v.status="success"}catch(x){v.status="error",v.value=x}return v}(n.exports=u).prototype.finally=function(A){if(typeof A!="function")return this;var y=this.constructor;return this.then(function(v){return y.resolve(A()).then(function(){return v})},function(v){return y.resolve(A()).then(function(){throw v})})},u.prototype.catch=function(A){return this.then(null,A)},u.prototype.then=function(A,y){if(typeof A!="function"&&this.state===c||typeof y!="function"&&this.state===a)return this;var v=new this.constructor(i);return this.state!==d?h(v,this.state===c?A:y,this.outcome):this.queue.push(new f(v,A,y)),v},f.prototype.callFulfilled=function(A){o.resolve(this.promise,A)},f.prototype.otherCallFulfilled=function(A){h(this.promise,this.onFulfilled,A)},f.prototype.callRejected=function(A){o.reject(this.promise,A)},f.prototype.otherCallRejected=function(A){h(this.promise,this.onRejected,A)},o.resolve=function(A,y){var v=m(g,y);if(v.status==="error")return o.reject(A,v.value);var x=v.value;if(x)p(A,x);else{A.state=c,A.outcome=y;for(var w=-1,T=A.queue.length;++w<T;)A.queue[w].callFulfilled(y)}return A},o.reject=function(A,y){A.state=a,A.outcome=y;for(var v=-1,x=A.queue.length;++v<x;)A.queue[v].callRejected(y);return A},u.resolve=function(A){return A instanceof this?A:o.resolve(new this(i),A)},u.reject=function(A){var y=new this(i);return o.reject(y,A)},u.all=function(A){var y=this;if(Object.prototype.toString.call(A)!=="[object Array]")return this.reject(new TypeError("must be an array"));var v=A.length,x=!1;if(!v)return this.resolve([]);for(var w=new Array(v),T=0,C=-1,E=new this(i);++C<v;)I(A[C],C);return E;function I(P,B){y.resolve(P).then(function(M){w[B]=M,++T!==v||x||(x=!0,o.resolve(E,w))},function(M){x||(x=!0,o.reject(E,M))})}},u.race=function(A){var y=this;if(Object.prototype.toString.call(A)!=="[object Array]")return this.reject(new TypeError("must be an array"));var v=A.length,x=!1;if(!v)return this.resolve([]);for(var w=-1,T=new this(i);++w<v;)C=A[w],y.resolve(C).then(function(E){x||(x=!0,o.resolve(T,E))},function(E){x||(x=!0,o.reject(T,E))});var C;return T}},{immediate:36}],38:[function(t,n,s){var r={};(0,t("./lib/utils/common").assign)(r,t("./lib/deflate"),t("./lib/inflate"),t("./lib/zlib/constants")),n.exports=r},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(t,n,s){var r=t("./zlib/deflate"),i=t("./utils/common"),o=t("./utils/strings"),a=t("./zlib/messages"),c=t("./zlib/zstream"),d=Object.prototype.toString,u=0,f=-1,h=0,g=8;function p(A){if(!(this instanceof p))return new p(A);this.options=i.assign({level:f,method:g,chunkSize:16384,windowBits:15,memLevel:8,strategy:h,to:""},A||{});var y=this.options;y.raw&&0<y.windowBits?y.windowBits=-y.windowBits:y.gzip&&0<y.windowBits&&y.windowBits<16&&(y.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new c,this.strm.avail_out=0;var v=r.deflateInit2(this.strm,y.level,y.method,y.windowBits,y.memLevel,y.strategy);if(v!==u)throw new Error(a[v]);if(y.header&&r.deflateSetHeader(this.strm,y.header),y.dictionary){var x;if(x=typeof y.dictionary=="string"?o.string2buf(y.dictionary):d.call(y.dictionary)==="[object ArrayBuffer]"?new Uint8Array(y.dictionary):y.dictionary,(v=r.deflateSetDictionary(this.strm,x))!==u)throw new Error(a[v]);this._dict_set=!0}}function m(A,y){var v=new p(y);if(v.push(A,!0),v.err)throw v.msg||a[v.err];return v.result}p.prototype.push=function(A,y){var v,x,w=this.strm,T=this.options.chunkSize;if(this.ended)return!1;x=y===~~y?y:y===!0?4:0,typeof A=="string"?w.input=o.string2buf(A):d.call(A)==="[object ArrayBuffer]"?w.input=new Uint8Array(A):w.input=A,w.next_in=0,w.avail_in=w.input.length;do{if(w.avail_out===0&&(w.output=new i.Buf8(T),w.next_out=0,w.avail_out=T),(v=r.deflate(w,x))!==1&&v!==u)return this.onEnd(v),!(this.ended=!0);w.avail_out!==0&&(w.avail_in!==0||x!==4&&x!==2)||(this.options.to==="string"?this.onData(o.buf2binstring(i.shrinkBuf(w.output,w.next_out))):this.onData(i.shrinkBuf(w.output,w.next_out)))}while((0<w.avail_in||w.avail_out===0)&&v!==1);return x===4?(v=r.deflateEnd(this.strm),this.onEnd(v),this.ended=!0,v===u):x!==2||(this.onEnd(u),!(w.avail_out=0))},p.prototype.onData=function(A){this.chunks.push(A)},p.prototype.onEnd=function(A){A===u&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=i.flattenChunks(this.chunks)),this.chunks=[],this.err=A,this.msg=this.strm.msg},s.Deflate=p,s.deflate=m,s.deflateRaw=function(A,y){return(y=y||{}).raw=!0,m(A,y)},s.gzip=function(A,y){return(y=y||{}).gzip=!0,m(A,y)}},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(t,n,s){var r=t("./zlib/inflate"),i=t("./utils/common"),o=t("./utils/strings"),a=t("./zlib/constants"),c=t("./zlib/messages"),d=t("./zlib/zstream"),u=t("./zlib/gzheader"),f=Object.prototype.toString;function h(p){if(!(this instanceof h))return new h(p);this.options=i.assign({chunkSize:16384,windowBits:0,to:""},p||{});var m=this.options;m.raw&&0<=m.windowBits&&m.windowBits<16&&(m.windowBits=-m.windowBits,m.windowBits===0&&(m.windowBits=-15)),!(0<=m.windowBits&&m.windowBits<16)||p&&p.windowBits||(m.windowBits+=32),15<m.windowBits&&m.windowBits<48&&!(15&m.windowBits)&&(m.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new d,this.strm.avail_out=0;var A=r.inflateInit2(this.strm,m.windowBits);if(A!==a.Z_OK)throw new Error(c[A]);this.header=new u,r.inflateGetHeader(this.strm,this.header)}function g(p,m){var A=new h(m);if(A.push(p,!0),A.err)throw A.msg||c[A.err];return A.result}h.prototype.push=function(p,m){var A,y,v,x,w,T,C=this.strm,E=this.options.chunkSize,I=this.options.dictionary,P=!1;if(this.ended)return!1;y=m===~~m?m:m===!0?a.Z_FINISH:a.Z_NO_FLUSH,typeof p=="string"?C.input=o.binstring2buf(p):f.call(p)==="[object ArrayBuffer]"?C.input=new Uint8Array(p):C.input=p,C.next_in=0,C.avail_in=C.input.length;do{if(C.avail_out===0&&(C.output=new i.Buf8(E),C.next_out=0,C.avail_out=E),(A=r.inflate(C,a.Z_NO_FLUSH))===a.Z_NEED_DICT&&I&&(T=typeof I=="string"?o.string2buf(I):f.call(I)==="[object ArrayBuffer]"?new Uint8Array(I):I,A=r.inflateSetDictionary(this.strm,T)),A===a.Z_BUF_ERROR&&P===!0&&(A=a.Z_OK,P=!1),A!==a.Z_STREAM_END&&A!==a.Z_OK)return this.onEnd(A),!(this.ended=!0);C.next_out&&(C.avail_out!==0&&A!==a.Z_STREAM_END&&(C.avail_in!==0||y!==a.Z_FINISH&&y!==a.Z_SYNC_FLUSH)||(this.options.to==="string"?(v=o.utf8border(C.output,C.next_out),x=C.next_out-v,w=o.buf2string(C.output,v),C.next_out=x,C.avail_out=E-x,x&&i.arraySet(C.output,C.output,v,x,0),this.onData(w)):this.onData(i.shrinkBuf(C.output,C.next_out)))),C.avail_in===0&&C.avail_out===0&&(P=!0)}while((0<C.avail_in||C.avail_out===0)&&A!==a.Z_STREAM_END);return A===a.Z_STREAM_END&&(y=a.Z_FINISH),y===a.Z_FINISH?(A=r.inflateEnd(this.strm),this.onEnd(A),this.ended=!0,A===a.Z_OK):y!==a.Z_SYNC_FLUSH||(this.onEnd(a.Z_OK),!(C.avail_out=0))},h.prototype.onData=function(p){this.chunks.push(p)},h.prototype.onEnd=function(p){p===a.Z_OK&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=i.flattenChunks(this.chunks)),this.chunks=[],this.err=p,this.msg=this.strm.msg},s.Inflate=h,s.inflate=g,s.inflateRaw=function(p,m){return(m=m||{}).raw=!0,g(p,m)},s.ungzip=g},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(t,n,s){var r=typeof Uint8Array<"u"&&typeof Uint16Array<"u"&&typeof Int32Array<"u";s.assign=function(a){for(var c=Array.prototype.slice.call(arguments,1);c.length;){var d=c.shift();if(d){if(typeof d!="object")throw new TypeError(d+"must be non-object");for(var u in d)d.hasOwnProperty(u)&&(a[u]=d[u])}}return a},s.shrinkBuf=function(a,c){return a.length===c?a:a.subarray?a.subarray(0,c):(a.length=c,a)};var i={arraySet:function(a,c,d,u,f){if(c.subarray&&a.subarray)a.set(c.subarray(d,d+u),f);else for(var h=0;h<u;h++)a[f+h]=c[d+h]},flattenChunks:function(a){var c,d,u,f,h,g;for(c=u=0,d=a.length;c<d;c++)u+=a[c].length;for(g=new Uint8Array(u),c=f=0,d=a.length;c<d;c++)h=a[c],g.set(h,f),f+=h.length;return g}},o={arraySet:function(a,c,d,u,f){for(var h=0;h<u;h++)a[f+h]=c[d+h]},flattenChunks:function(a){return[].concat.apply([],a)}};s.setTyped=function(a){a?(s.Buf8=Uint8Array,s.Buf16=Uint16Array,s.Buf32=Int32Array,s.assign(s,i)):(s.Buf8=Array,s.Buf16=Array,s.Buf32=Array,s.assign(s,o))},s.setTyped(r)},{}],42:[function(t,n,s){var r=t("./common"),i=!0,o=!0;try{String.fromCharCode.apply(null,[0])}catch{i=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{o=!1}for(var a=new r.Buf8(256),c=0;c<256;c++)a[c]=252<=c?6:248<=c?5:240<=c?4:224<=c?3:192<=c?2:1;function d(u,f){if(f<65537&&(u.subarray&&o||!u.subarray&&i))return String.fromCharCode.apply(null,r.shrinkBuf(u,f));for(var h="",g=0;g<f;g++)h+=String.fromCharCode(u[g]);return h}a[254]=a[254]=1,s.string2buf=function(u){var f,h,g,p,m,A=u.length,y=0;for(p=0;p<A;p++)(64512&(h=u.charCodeAt(p)))==55296&&p+1<A&&(64512&(g=u.charCodeAt(p+1)))==56320&&(h=65536+(h-55296<<10)+(g-56320),p++),y+=h<128?1:h<2048?2:h<65536?3:4;for(f=new r.Buf8(y),p=m=0;m<y;p++)(64512&(h=u.charCodeAt(p)))==55296&&p+1<A&&(64512&(g=u.charCodeAt(p+1)))==56320&&(h=65536+(h-55296<<10)+(g-56320),p++),h<128?f[m++]=h:(h<2048?f[m++]=192|h>>>6:(h<65536?f[m++]=224|h>>>12:(f[m++]=240|h>>>18,f[m++]=128|h>>>12&63),f[m++]=128|h>>>6&63),f[m++]=128|63&h);return f},s.buf2binstring=function(u){return d(u,u.length)},s.binstring2buf=function(u){for(var f=new r.Buf8(u.length),h=0,g=f.length;h<g;h++)f[h]=u.charCodeAt(h);return f},s.buf2string=function(u,f){var h,g,p,m,A=f||u.length,y=new Array(2*A);for(h=g=0;h<A;)if((p=u[h++])<128)y[g++]=p;else if(4<(m=a[p]))y[g++]=65533,h+=m-1;else{for(p&=m===2?31:m===3?15:7;1<m&&h<A;)p=p<<6|63&u[h++],m--;1<m?y[g++]=65533:p<65536?y[g++]=p:(p-=65536,y[g++]=55296|p>>10&1023,y[g++]=56320|1023&p)}return d(y,g)},s.utf8border=function(u,f){var h;for((f=f||u.length)>u.length&&(f=u.length),h=f-1;0<=h&&(192&u[h])==128;)h--;return h<0||h===0?f:h+a[u[h]]>f?h:f}},{"./common":41}],43:[function(t,n,s){n.exports=function(r,i,o,a){for(var c=65535&r|0,d=r>>>16&65535|0,u=0;o!==0;){for(o-=u=2e3<o?2e3:o;d=d+(c=c+i[a++]|0)|0,--u;);c%=65521,d%=65521}return c|d<<16|0}},{}],44:[function(t,n,s){n.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(t,n,s){var r=function(){for(var i,o=[],a=0;a<256;a++){i=a;for(var c=0;c<8;c++)i=1&i?3988292384^i>>>1:i>>>1;o[a]=i}return o}();n.exports=function(i,o,a,c){var d=r,u=c+a;i^=-1;for(var f=c;f<u;f++)i=i>>>8^d[255&(i^o[f])];return-1^i}},{}],46:[function(t,n,s){var r,i=t("../utils/common"),o=t("./trees"),a=t("./adler32"),c=t("./crc32"),d=t("./messages"),u=0,f=4,h=0,g=-2,p=-1,m=4,A=2,y=8,v=9,x=286,w=30,T=19,C=2*x+1,E=15,I=3,P=258,B=P+I+1,M=42,D=113,_=1,k=2,G=3,O=4;function $(S,N){return S.msg=d[N],N}function U(S){return(S<<1)-(4<S?9:0)}function Z(S){for(var N=S.length;0<=--N;)S[N]=0}function V(S){var N=S.state,W=N.pending;W>S.avail_out&&(W=S.avail_out),W!==0&&(i.arraySet(S.output,N.pending_buf,N.pending_out,W,S.next_out),S.next_out+=W,N.pending_out+=W,S.total_out+=W,S.avail_out-=W,N.pending-=W,N.pending===0&&(N.pending_out=0))}function z(S,N){o._tr_flush_block(S,0<=S.block_start?S.block_start:-1,S.strstart-S.block_start,N),S.block_start=S.strstart,V(S.strm)}function ne(S,N){S.pending_buf[S.pending++]=N}function te(S,N){S.pending_buf[S.pending++]=N>>>8&255,S.pending_buf[S.pending++]=255&N}function J(S,N){var W,R,b=S.max_chain_length,L=S.strstart,K=S.prev_length,Y=S.nice_match,Q=S.strstart>S.w_size-B?S.strstart-(S.w_size-B):0,se=S.window,le=S.w_mask,re=S.prev,pe=S.strstart+P,Ce=se[L+K-1],ve=se[L+K];S.prev_length>=S.good_match&&(b>>=2),Y>S.lookahead&&(Y=S.lookahead);do if(se[(W=N)+K]===ve&&se[W+K-1]===Ce&&se[W]===se[L]&&se[++W]===se[L+1]){L+=2,W++;do;while(se[++L]===se[++W]&&se[++L]===se[++W]&&se[++L]===se[++W]&&se[++L]===se[++W]&&se[++L]===se[++W]&&se[++L]===se[++W]&&se[++L]===se[++W]&&se[++L]===se[++W]&&L<pe);if(R=P-(pe-L),L=pe-P,K<R){if(S.match_start=N,Y<=(K=R))break;Ce=se[L+K-1],ve=se[L+K]}}while((N=re[N&le])>Q&&--b!=0);return K<=S.lookahead?K:S.lookahead}function ue(S){var N,W,R,b,L,K,Y,Q,se,le,re=S.w_size;do{if(b=S.window_size-S.lookahead-S.strstart,S.strstart>=re+(re-B)){for(i.arraySet(S.window,S.window,re,re,0),S.match_start-=re,S.strstart-=re,S.block_start-=re,N=W=S.hash_size;R=S.head[--N],S.head[N]=re<=R?R-re:0,--W;);for(N=W=re;R=S.prev[--N],S.prev[N]=re<=R?R-re:0,--W;);b+=re}if(S.strm.avail_in===0)break;if(K=S.strm,Y=S.window,Q=S.strstart+S.lookahead,se=b,le=void 0,le=K.avail_in,se<le&&(le=se),W=le===0?0:(K.avail_in-=le,i.arraySet(Y,K.input,K.next_in,le,Q),K.state.wrap===1?K.adler=a(K.adler,Y,le,Q):K.state.wrap===2&&(K.adler=c(K.adler,Y,le,Q)),K.next_in+=le,K.total_in+=le,le),S.lookahead+=W,S.lookahead+S.insert>=I)for(L=S.strstart-S.insert,S.ins_h=S.window[L],S.ins_h=(S.ins_h<<S.hash_shift^S.window[L+1])&S.hash_mask;S.insert&&(S.ins_h=(S.ins_h<<S.hash_shift^S.window[L+I-1])&S.hash_mask,S.prev[L&S.w_mask]=S.head[S.ins_h],S.head[S.ins_h]=L,L++,S.insert--,!(S.lookahead+S.insert<I)););}while(S.lookahead<B&&S.strm.avail_in!==0)}function me(S,N){for(var W,R;;){if(S.lookahead<B){if(ue(S),S.lookahead<B&&N===u)return _;if(S.lookahead===0)break}if(W=0,S.lookahead>=I&&(S.ins_h=(S.ins_h<<S.hash_shift^S.window[S.strstart+I-1])&S.hash_mask,W=S.prev[S.strstart&S.w_mask]=S.head[S.ins_h],S.head[S.ins_h]=S.strstart),W!==0&&S.strstart-W<=S.w_size-B&&(S.match_length=J(S,W)),S.match_length>=I)if(R=o._tr_tally(S,S.strstart-S.match_start,S.match_length-I),S.lookahead-=S.match_length,S.match_length<=S.max_lazy_match&&S.lookahead>=I){for(S.match_length--;S.strstart++,S.ins_h=(S.ins_h<<S.hash_shift^S.window[S.strstart+I-1])&S.hash_mask,W=S.prev[S.strstart&S.w_mask]=S.head[S.ins_h],S.head[S.ins_h]=S.strstart,--S.match_length!=0;);S.strstart++}else S.strstart+=S.match_length,S.match_length=0,S.ins_h=S.window[S.strstart],S.ins_h=(S.ins_h<<S.hash_shift^S.window[S.strstart+1])&S.hash_mask;else R=o._tr_tally(S,0,S.window[S.strstart]),S.lookahead--,S.strstart++;if(R&&(z(S,!1),S.strm.avail_out===0))return _}return S.insert=S.strstart<I-1?S.strstart:I-1,N===f?(z(S,!0),S.strm.avail_out===0?G:O):S.last_lit&&(z(S,!1),S.strm.avail_out===0)?_:k}function de(S,N){for(var W,R,b;;){if(S.lookahead<B){if(ue(S),S.lookahead<B&&N===u)return _;if(S.lookahead===0)break}if(W=0,S.lookahead>=I&&(S.ins_h=(S.ins_h<<S.hash_shift^S.window[S.strstart+I-1])&S.hash_mask,W=S.prev[S.strstart&S.w_mask]=S.head[S.ins_h],S.head[S.ins_h]=S.strstart),S.prev_length=S.match_length,S.prev_match=S.match_start,S.match_length=I-1,W!==0&&S.prev_length<S.max_lazy_match&&S.strstart-W<=S.w_size-B&&(S.match_length=J(S,W),S.match_length<=5&&(S.strategy===1||S.match_length===I&&4096<S.strstart-S.match_start)&&(S.match_length=I-1)),S.prev_length>=I&&S.match_length<=S.prev_length){for(b=S.strstart+S.lookahead-I,R=o._tr_tally(S,S.strstart-1-S.prev_match,S.prev_length-I),S.lookahead-=S.prev_length-1,S.prev_length-=2;++S.strstart<=b&&(S.ins_h=(S.ins_h<<S.hash_shift^S.window[S.strstart+I-1])&S.hash_mask,W=S.prev[S.strstart&S.w_mask]=S.head[S.ins_h],S.head[S.ins_h]=S.strstart),--S.prev_length!=0;);if(S.match_available=0,S.match_length=I-1,S.strstart++,R&&(z(S,!1),S.strm.avail_out===0))return _}else if(S.match_available){if((R=o._tr_tally(S,0,S.window[S.strstart-1]))&&z(S,!1),S.strstart++,S.lookahead--,S.strm.avail_out===0)return _}else S.match_available=1,S.strstart++,S.lookahead--}return S.match_available&&(R=o._tr_tally(S,0,S.window[S.strstart-1]),S.match_available=0),S.insert=S.strstart<I-1?S.strstart:I-1,N===f?(z(S,!0),S.strm.avail_out===0?G:O):S.last_lit&&(z(S,!1),S.strm.avail_out===0)?_:k}function fe(S,N,W,R,b){this.good_length=S,this.max_lazy=N,this.nice_length=W,this.max_chain=R,this.func=b}function q(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=y,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new i.Buf16(2*C),this.dyn_dtree=new i.Buf16(2*(2*w+1)),this.bl_tree=new i.Buf16(2*(2*T+1)),Z(this.dyn_ltree),Z(this.dyn_dtree),Z(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new i.Buf16(E+1),this.heap=new i.Buf16(2*x+1),Z(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new i.Buf16(2*x+1),Z(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function X(S){var N;return S&&S.state?(S.total_in=S.total_out=0,S.data_type=A,(N=S.state).pending=0,N.pending_out=0,N.wrap<0&&(N.wrap=-N.wrap),N.status=N.wrap?M:D,S.adler=N.wrap===2?0:1,N.last_flush=u,o._tr_init(N),h):$(S,g)}function ie(S){var N=X(S);return N===h&&function(W){W.window_size=2*W.w_size,Z(W.head),W.max_lazy_match=r[W.level].max_lazy,W.good_match=r[W.level].good_length,W.nice_match=r[W.level].nice_length,W.max_chain_length=r[W.level].max_chain,W.strstart=0,W.block_start=0,W.lookahead=0,W.insert=0,W.match_length=W.prev_length=I-1,W.match_available=0,W.ins_h=0}(S.state),N}function ee(S,N,W,R,b,L){if(!S)return g;var K=1;if(N===p&&(N=6),R<0?(K=0,R=-R):15<R&&(K=2,R-=16),b<1||v<b||W!==y||R<8||15<R||N<0||9<N||L<0||m<L)return $(S,g);R===8&&(R=9);var Y=new q;return(S.state=Y).strm=S,Y.wrap=K,Y.gzhead=null,Y.w_bits=R,Y.w_size=1<<Y.w_bits,Y.w_mask=Y.w_size-1,Y.hash_bits=b+7,Y.hash_size=1<<Y.hash_bits,Y.hash_mask=Y.hash_size-1,Y.hash_shift=~~((Y.hash_bits+I-1)/I),Y.window=new i.Buf8(2*Y.w_size),Y.head=new i.Buf16(Y.hash_size),Y.prev=new i.Buf16(Y.w_size),Y.lit_bufsize=1<<b+6,Y.pending_buf_size=4*Y.lit_bufsize,Y.pending_buf=new i.Buf8(Y.pending_buf_size),Y.d_buf=1*Y.lit_bufsize,Y.l_buf=3*Y.lit_bufsize,Y.level=N,Y.strategy=L,Y.method=W,ie(S)}r=[new fe(0,0,0,0,function(S,N){var W=65535;for(W>S.pending_buf_size-5&&(W=S.pending_buf_size-5);;){if(S.lookahead<=1){if(ue(S),S.lookahead===0&&N===u)return _;if(S.lookahead===0)break}S.strstart+=S.lookahead,S.lookahead=0;var R=S.block_start+W;if((S.strstart===0||S.strstart>=R)&&(S.lookahead=S.strstart-R,S.strstart=R,z(S,!1),S.strm.avail_out===0)||S.strstart-S.block_start>=S.w_size-B&&(z(S,!1),S.strm.avail_out===0))return _}return S.insert=0,N===f?(z(S,!0),S.strm.avail_out===0?G:O):(S.strstart>S.block_start&&(z(S,!1),S.strm.avail_out),_)}),new fe(4,4,8,4,me),new fe(4,5,16,8,me),new fe(4,6,32,32,me),new fe(4,4,16,16,de),new fe(8,16,32,32,de),new fe(8,16,128,128,de),new fe(8,32,128,256,de),new fe(32,128,258,1024,de),new fe(32,258,258,4096,de)],s.deflateInit=function(S,N){return ee(S,N,y,15,8,0)},s.deflateInit2=ee,s.deflateReset=ie,s.deflateResetKeep=X,s.deflateSetHeader=function(S,N){return S&&S.state?S.state.wrap!==2?g:(S.state.gzhead=N,h):g},s.deflate=function(S,N){var W,R,b,L;if(!S||!S.state||5<N||N<0)return S?$(S,g):g;if(R=S.state,!S.output||!S.input&&S.avail_in!==0||R.status===666&&N!==f)return $(S,S.avail_out===0?-5:g);if(R.strm=S,W=R.last_flush,R.last_flush=N,R.status===M)if(R.wrap===2)S.adler=0,ne(R,31),ne(R,139),ne(R,8),R.gzhead?(ne(R,(R.gzhead.text?1:0)+(R.gzhead.hcrc?2:0)+(R.gzhead.extra?4:0)+(R.gzhead.name?8:0)+(R.gzhead.comment?16:0)),ne(R,255&R.gzhead.time),ne(R,R.gzhead.time>>8&255),ne(R,R.gzhead.time>>16&255),ne(R,R.gzhead.time>>24&255),ne(R,R.level===9?2:2<=R.strategy||R.level<2?4:0),ne(R,255&R.gzhead.os),R.gzhead.extra&&R.gzhead.extra.length&&(ne(R,255&R.gzhead.extra.length),ne(R,R.gzhead.extra.length>>8&255)),R.gzhead.hcrc&&(S.adler=c(S.adler,R.pending_buf,R.pending,0)),R.gzindex=0,R.status=69):(ne(R,0),ne(R,0),ne(R,0),ne(R,0),ne(R,0),ne(R,R.level===9?2:2<=R.strategy||R.level<2?4:0),ne(R,3),R.status=D);else{var K=y+(R.w_bits-8<<4)<<8;K|=(2<=R.strategy||R.level<2?0:R.level<6?1:R.level===6?2:3)<<6,R.strstart!==0&&(K|=32),K+=31-K%31,R.status=D,te(R,K),R.strstart!==0&&(te(R,S.adler>>>16),te(R,65535&S.adler)),S.adler=1}if(R.status===69)if(R.gzhead.extra){for(b=R.pending;R.gzindex<(65535&R.gzhead.extra.length)&&(R.pending!==R.pending_buf_size||(R.gzhead.hcrc&&R.pending>b&&(S.adler=c(S.adler,R.pending_buf,R.pending-b,b)),V(S),b=R.pending,R.pending!==R.pending_buf_size));)ne(R,255&R.gzhead.extra[R.gzindex]),R.gzindex++;R.gzhead.hcrc&&R.pending>b&&(S.adler=c(S.adler,R.pending_buf,R.pending-b,b)),R.gzindex===R.gzhead.extra.length&&(R.gzindex=0,R.status=73)}else R.status=73;if(R.status===73)if(R.gzhead.name){b=R.pending;do{if(R.pending===R.pending_buf_size&&(R.gzhead.hcrc&&R.pending>b&&(S.adler=c(S.adler,R.pending_buf,R.pending-b,b)),V(S),b=R.pending,R.pending===R.pending_buf_size)){L=1;break}L=R.gzindex<R.gzhead.name.length?255&R.gzhead.name.charCodeAt(R.gzindex++):0,ne(R,L)}while(L!==0);R.gzhead.hcrc&&R.pending>b&&(S.adler=c(S.adler,R.pending_buf,R.pending-b,b)),L===0&&(R.gzindex=0,R.status=91)}else R.status=91;if(R.status===91)if(R.gzhead.comment){b=R.pending;do{if(R.pending===R.pending_buf_size&&(R.gzhead.hcrc&&R.pending>b&&(S.adler=c(S.adler,R.pending_buf,R.pending-b,b)),V(S),b=R.pending,R.pending===R.pending_buf_size)){L=1;break}L=R.gzindex<R.gzhead.comment.length?255&R.gzhead.comment.charCodeAt(R.gzindex++):0,ne(R,L)}while(L!==0);R.gzhead.hcrc&&R.pending>b&&(S.adler=c(S.adler,R.pending_buf,R.pending-b,b)),L===0&&(R.status=103)}else R.status=103;if(R.status===103&&(R.gzhead.hcrc?(R.pending+2>R.pending_buf_size&&V(S),R.pending+2<=R.pending_buf_size&&(ne(R,255&S.adler),ne(R,S.adler>>8&255),S.adler=0,R.status=D)):R.status=D),R.pending!==0){if(V(S),S.avail_out===0)return R.last_flush=-1,h}else if(S.avail_in===0&&U(N)<=U(W)&&N!==f)return $(S,-5);if(R.status===666&&S.avail_in!==0)return $(S,-5);if(S.avail_in!==0||R.lookahead!==0||N!==u&&R.status!==666){var Y=R.strategy===2?function(Q,se){for(var le;;){if(Q.lookahead===0&&(ue(Q),Q.lookahead===0)){if(se===u)return _;break}if(Q.match_length=0,le=o._tr_tally(Q,0,Q.window[Q.strstart]),Q.lookahead--,Q.strstart++,le&&(z(Q,!1),Q.strm.avail_out===0))return _}return Q.insert=0,se===f?(z(Q,!0),Q.strm.avail_out===0?G:O):Q.last_lit&&(z(Q,!1),Q.strm.avail_out===0)?_:k}(R,N):R.strategy===3?function(Q,se){for(var le,re,pe,Ce,ve=Q.window;;){if(Q.lookahead<=P){if(ue(Q),Q.lookahead<=P&&se===u)return _;if(Q.lookahead===0)break}if(Q.match_length=0,Q.lookahead>=I&&0<Q.strstart&&(re=ve[pe=Q.strstart-1])===ve[++pe]&&re===ve[++pe]&&re===ve[++pe]){Ce=Q.strstart+P;do;while(re===ve[++pe]&&re===ve[++pe]&&re===ve[++pe]&&re===ve[++pe]&&re===ve[++pe]&&re===ve[++pe]&&re===ve[++pe]&&re===ve[++pe]&&pe<Ce);Q.match_length=P-(Ce-pe),Q.match_length>Q.lookahead&&(Q.match_length=Q.lookahead)}if(Q.match_length>=I?(le=o._tr_tally(Q,1,Q.match_length-I),Q.lookahead-=Q.match_length,Q.strstart+=Q.match_length,Q.match_length=0):(le=o._tr_tally(Q,0,Q.window[Q.strstart]),Q.lookahead--,Q.strstart++),le&&(z(Q,!1),Q.strm.avail_out===0))return _}return Q.insert=0,se===f?(z(Q,!0),Q.strm.avail_out===0?G:O):Q.last_lit&&(z(Q,!1),Q.strm.avail_out===0)?_:k}(R,N):r[R.level].func(R,N);if(Y!==G&&Y!==O||(R.status=666),Y===_||Y===G)return S.avail_out===0&&(R.last_flush=-1),h;if(Y===k&&(N===1?o._tr_align(R):N!==5&&(o._tr_stored_block(R,0,0,!1),N===3&&(Z(R.head),R.lookahead===0&&(R.strstart=0,R.block_start=0,R.insert=0))),V(S),S.avail_out===0))return R.last_flush=-1,h}return N!==f?h:R.wrap<=0?1:(R.wrap===2?(ne(R,255&S.adler),ne(R,S.adler>>8&255),ne(R,S.adler>>16&255),ne(R,S.adler>>24&255),ne(R,255&S.total_in),ne(R,S.total_in>>8&255),ne(R,S.total_in>>16&255),ne(R,S.total_in>>24&255)):(te(R,S.adler>>>16),te(R,65535&S.adler)),V(S),0<R.wrap&&(R.wrap=-R.wrap),R.pending!==0?h:1)},s.deflateEnd=function(S){var N;return S&&S.state?(N=S.state.status)!==M&&N!==69&&N!==73&&N!==91&&N!==103&&N!==D&&N!==666?$(S,g):(S.state=null,N===D?$(S,-3):h):g},s.deflateSetDictionary=function(S,N){var W,R,b,L,K,Y,Q,se,le=N.length;if(!S||!S.state||(L=(W=S.state).wrap)===2||L===1&&W.status!==M||W.lookahead)return g;for(L===1&&(S.adler=a(S.adler,N,le,0)),W.wrap=0,le>=W.w_size&&(L===0&&(Z(W.head),W.strstart=0,W.block_start=0,W.insert=0),se=new i.Buf8(W.w_size),i.arraySet(se,N,le-W.w_size,W.w_size,0),N=se,le=W.w_size),K=S.avail_in,Y=S.next_in,Q=S.input,S.avail_in=le,S.next_in=0,S.input=N,ue(W);W.lookahead>=I;){for(R=W.strstart,b=W.lookahead-(I-1);W.ins_h=(W.ins_h<<W.hash_shift^W.window[R+I-1])&W.hash_mask,W.prev[R&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=R,R++,--b;);W.strstart=R,W.lookahead=I-1,ue(W)}return W.strstart+=W.lookahead,W.block_start=W.strstart,W.insert=W.lookahead,W.lookahead=0,W.match_length=W.prev_length=I-1,W.match_available=0,S.next_in=Y,S.input=Q,S.avail_in=K,W.wrap=L,h},s.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(t,n,s){n.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],48:[function(t,n,s){n.exports=function(r,i){var o,a,c,d,u,f,h,g,p,m,A,y,v,x,w,T,C,E,I,P,B,M,D,_,k;o=r.state,a=r.next_in,_=r.input,c=a+(r.avail_in-5),d=r.next_out,k=r.output,u=d-(i-r.avail_out),f=d+(r.avail_out-257),h=o.dmax,g=o.wsize,p=o.whave,m=o.wnext,A=o.window,y=o.hold,v=o.bits,x=o.lencode,w=o.distcode,T=(1<<o.lenbits)-1,C=(1<<o.distbits)-1;e:do{v<15&&(y+=_[a++]<<v,v+=8,y+=_[a++]<<v,v+=8),E=x[y&T];t:for(;;){if(y>>>=I=E>>>24,v-=I,(I=E>>>16&255)===0)k[d++]=65535&E;else{if(!(16&I)){if(!(64&I)){E=x[(65535&E)+(y&(1<<I)-1)];continue t}if(32&I){o.mode=12;break e}r.msg="invalid literal/length code",o.mode=30;break e}P=65535&E,(I&=15)&&(v<I&&(y+=_[a++]<<v,v+=8),P+=y&(1<<I)-1,y>>>=I,v-=I),v<15&&(y+=_[a++]<<v,v+=8,y+=_[a++]<<v,v+=8),E=w[y&C];n:for(;;){if(y>>>=I=E>>>24,v-=I,!(16&(I=E>>>16&255))){if(!(64&I)){E=w[(65535&E)+(y&(1<<I)-1)];continue n}r.msg="invalid distance code",o.mode=30;break e}if(B=65535&E,v<(I&=15)&&(y+=_[a++]<<v,(v+=8)<I&&(y+=_[a++]<<v,v+=8)),h<(B+=y&(1<<I)-1)){r.msg="invalid distance too far back",o.mode=30;break e}if(y>>>=I,v-=I,(I=d-u)<B){if(p<(I=B-I)&&o.sane){r.msg="invalid distance too far back",o.mode=30;break e}if(D=A,(M=0)===m){if(M+=g-I,I<P){for(P-=I;k[d++]=A[M++],--I;);M=d-B,D=k}}else if(m<I){if(M+=g+m-I,(I-=m)<P){for(P-=I;k[d++]=A[M++],--I;);if(M=0,m<P){for(P-=I=m;k[d++]=A[M++],--I;);M=d-B,D=k}}}else if(M+=m-I,I<P){for(P-=I;k[d++]=A[M++],--I;);M=d-B,D=k}for(;2<P;)k[d++]=D[M++],k[d++]=D[M++],k[d++]=D[M++],P-=3;P&&(k[d++]=D[M++],1<P&&(k[d++]=D[M++]))}else{for(M=d-B;k[d++]=k[M++],k[d++]=k[M++],k[d++]=k[M++],2<(P-=3););P&&(k[d++]=k[M++],1<P&&(k[d++]=k[M++]))}break}}break}}while(a<c&&d<f);a-=P=v>>3,y&=(1<<(v-=P<<3))-1,r.next_in=a,r.next_out=d,r.avail_in=a<c?c-a+5:5-(a-c),r.avail_out=d<f?f-d+257:257-(d-f),o.hold=y,o.bits=v}},{}],49:[function(t,n,s){var r=t("../utils/common"),i=t("./adler32"),o=t("./crc32"),a=t("./inffast"),c=t("./inftrees"),d=1,u=2,f=0,h=-2,g=1,p=852,m=592;function A(M){return(M>>>24&255)+(M>>>8&65280)+((65280&M)<<8)+((255&M)<<24)}function y(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new r.Buf16(320),this.work=new r.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function v(M){var D;return M&&M.state?(D=M.state,M.total_in=M.total_out=D.total=0,M.msg="",D.wrap&&(M.adler=1&D.wrap),D.mode=g,D.last=0,D.havedict=0,D.dmax=32768,D.head=null,D.hold=0,D.bits=0,D.lencode=D.lendyn=new r.Buf32(p),D.distcode=D.distdyn=new r.Buf32(m),D.sane=1,D.back=-1,f):h}function x(M){var D;return M&&M.state?((D=M.state).wsize=0,D.whave=0,D.wnext=0,v(M)):h}function w(M,D){var _,k;return M&&M.state?(k=M.state,D<0?(_=0,D=-D):(_=1+(D>>4),D<48&&(D&=15)),D&&(D<8||15<D)?h:(k.window!==null&&k.wbits!==D&&(k.window=null),k.wrap=_,k.wbits=D,x(M))):h}function T(M,D){var _,k;return M?(k=new y,(M.state=k).window=null,(_=w(M,D))!==f&&(M.state=null),_):h}var C,E,I=!0;function P(M){if(I){var D;for(C=new r.Buf32(512),E=new r.Buf32(32),D=0;D<144;)M.lens[D++]=8;for(;D<256;)M.lens[D++]=9;for(;D<280;)M.lens[D++]=7;for(;D<288;)M.lens[D++]=8;for(c(d,M.lens,0,288,C,0,M.work,{bits:9}),D=0;D<32;)M.lens[D++]=5;c(u,M.lens,0,32,E,0,M.work,{bits:5}),I=!1}M.lencode=C,M.lenbits=9,M.distcode=E,M.distbits=5}function B(M,D,_,k){var G,O=M.state;return O.window===null&&(O.wsize=1<<O.wbits,O.wnext=0,O.whave=0,O.window=new r.Buf8(O.wsize)),k>=O.wsize?(r.arraySet(O.window,D,_-O.wsize,O.wsize,0),O.wnext=0,O.whave=O.wsize):(k<(G=O.wsize-O.wnext)&&(G=k),r.arraySet(O.window,D,_-k,G,O.wnext),(k-=G)?(r.arraySet(O.window,D,_-k,k,0),O.wnext=k,O.whave=O.wsize):(O.wnext+=G,O.wnext===O.wsize&&(O.wnext=0),O.whave<O.wsize&&(O.whave+=G))),0}s.inflateReset=x,s.inflateReset2=w,s.inflateResetKeep=v,s.inflateInit=function(M){return T(M,15)},s.inflateInit2=T,s.inflate=function(M,D){var _,k,G,O,$,U,Z,V,z,ne,te,J,ue,me,de,fe,q,X,ie,ee,S,N,W,R,b=0,L=new r.Buf8(4),K=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!M||!M.state||!M.output||!M.input&&M.avail_in!==0)return h;(_=M.state).mode===12&&(_.mode=13),$=M.next_out,G=M.output,Z=M.avail_out,O=M.next_in,k=M.input,U=M.avail_in,V=_.hold,z=_.bits,ne=U,te=Z,N=f;e:for(;;)switch(_.mode){case g:if(_.wrap===0){_.mode=13;break}for(;z<16;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}if(2&_.wrap&&V===35615){L[_.check=0]=255&V,L[1]=V>>>8&255,_.check=o(_.check,L,2,0),z=V=0,_.mode=2;break}if(_.flags=0,_.head&&(_.head.done=!1),!(1&_.wrap)||(((255&V)<<8)+(V>>8))%31){M.msg="incorrect header check",_.mode=30;break}if((15&V)!=8){M.msg="unknown compression method",_.mode=30;break}if(z-=4,S=8+(15&(V>>>=4)),_.wbits===0)_.wbits=S;else if(S>_.wbits){M.msg="invalid window size",_.mode=30;break}_.dmax=1<<S,M.adler=_.check=1,_.mode=512&V?10:12,z=V=0;break;case 2:for(;z<16;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}if(_.flags=V,(255&_.flags)!=8){M.msg="unknown compression method",_.mode=30;break}if(57344&_.flags){M.msg="unknown header flags set",_.mode=30;break}_.head&&(_.head.text=V>>8&1),512&_.flags&&(L[0]=255&V,L[1]=V>>>8&255,_.check=o(_.check,L,2,0)),z=V=0,_.mode=3;case 3:for(;z<32;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}_.head&&(_.head.time=V),512&_.flags&&(L[0]=255&V,L[1]=V>>>8&255,L[2]=V>>>16&255,L[3]=V>>>24&255,_.check=o(_.check,L,4,0)),z=V=0,_.mode=4;case 4:for(;z<16;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}_.head&&(_.head.xflags=255&V,_.head.os=V>>8),512&_.flags&&(L[0]=255&V,L[1]=V>>>8&255,_.check=o(_.check,L,2,0)),z=V=0,_.mode=5;case 5:if(1024&_.flags){for(;z<16;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}_.length=V,_.head&&(_.head.extra_len=V),512&_.flags&&(L[0]=255&V,L[1]=V>>>8&255,_.check=o(_.check,L,2,0)),z=V=0}else _.head&&(_.head.extra=null);_.mode=6;case 6:if(1024&_.flags&&(U<(J=_.length)&&(J=U),J&&(_.head&&(S=_.head.extra_len-_.length,_.head.extra||(_.head.extra=new Array(_.head.extra_len)),r.arraySet(_.head.extra,k,O,J,S)),512&_.flags&&(_.check=o(_.check,k,J,O)),U-=J,O+=J,_.length-=J),_.length))break e;_.length=0,_.mode=7;case 7:if(2048&_.flags){if(U===0)break e;for(J=0;S=k[O+J++],_.head&&S&&_.length<65536&&(_.head.name+=String.fromCharCode(S)),S&&J<U;);if(512&_.flags&&(_.check=o(_.check,k,J,O)),U-=J,O+=J,S)break e}else _.head&&(_.head.name=null);_.length=0,_.mode=8;case 8:if(4096&_.flags){if(U===0)break e;for(J=0;S=k[O+J++],_.head&&S&&_.length<65536&&(_.head.comment+=String.fromCharCode(S)),S&&J<U;);if(512&_.flags&&(_.check=o(_.check,k,J,O)),U-=J,O+=J,S)break e}else _.head&&(_.head.comment=null);_.mode=9;case 9:if(512&_.flags){for(;z<16;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}if(V!==(65535&_.check)){M.msg="header crc mismatch",_.mode=30;break}z=V=0}_.head&&(_.head.hcrc=_.flags>>9&1,_.head.done=!0),M.adler=_.check=0,_.mode=12;break;case 10:for(;z<32;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}M.adler=_.check=A(V),z=V=0,_.mode=11;case 11:if(_.havedict===0)return M.next_out=$,M.avail_out=Z,M.next_in=O,M.avail_in=U,_.hold=V,_.bits=z,2;M.adler=_.check=1,_.mode=12;case 12:if(D===5||D===6)break e;case 13:if(_.last){V>>>=7&z,z-=7&z,_.mode=27;break}for(;z<3;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}switch(_.last=1&V,z-=1,3&(V>>>=1)){case 0:_.mode=14;break;case 1:if(P(_),_.mode=20,D!==6)break;V>>>=2,z-=2;break e;case 2:_.mode=17;break;case 3:M.msg="invalid block type",_.mode=30}V>>>=2,z-=2;break;case 14:for(V>>>=7&z,z-=7&z;z<32;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}if((65535&V)!=(V>>>16^65535)){M.msg="invalid stored block lengths",_.mode=30;break}if(_.length=65535&V,z=V=0,_.mode=15,D===6)break e;case 15:_.mode=16;case 16:if(J=_.length){if(U<J&&(J=U),Z<J&&(J=Z),J===0)break e;r.arraySet(G,k,O,J,$),U-=J,O+=J,Z-=J,$+=J,_.length-=J;break}_.mode=12;break;case 17:for(;z<14;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}if(_.nlen=257+(31&V),V>>>=5,z-=5,_.ndist=1+(31&V),V>>>=5,z-=5,_.ncode=4+(15&V),V>>>=4,z-=4,286<_.nlen||30<_.ndist){M.msg="too many length or distance symbols",_.mode=30;break}_.have=0,_.mode=18;case 18:for(;_.have<_.ncode;){for(;z<3;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}_.lens[K[_.have++]]=7&V,V>>>=3,z-=3}for(;_.have<19;)_.lens[K[_.have++]]=0;if(_.lencode=_.lendyn,_.lenbits=7,W={bits:_.lenbits},N=c(0,_.lens,0,19,_.lencode,0,_.work,W),_.lenbits=W.bits,N){M.msg="invalid code lengths set",_.mode=30;break}_.have=0,_.mode=19;case 19:for(;_.have<_.nlen+_.ndist;){for(;fe=(b=_.lencode[V&(1<<_.lenbits)-1])>>>16&255,q=65535&b,!((de=b>>>24)<=z);){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}if(q<16)V>>>=de,z-=de,_.lens[_.have++]=q;else{if(q===16){for(R=de+2;z<R;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}if(V>>>=de,z-=de,_.have===0){M.msg="invalid bit length repeat",_.mode=30;break}S=_.lens[_.have-1],J=3+(3&V),V>>>=2,z-=2}else if(q===17){for(R=de+3;z<R;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}z-=de,S=0,J=3+(7&(V>>>=de)),V>>>=3,z-=3}else{for(R=de+7;z<R;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}z-=de,S=0,J=11+(127&(V>>>=de)),V>>>=7,z-=7}if(_.have+J>_.nlen+_.ndist){M.msg="invalid bit length repeat",_.mode=30;break}for(;J--;)_.lens[_.have++]=S}}if(_.mode===30)break;if(_.lens[256]===0){M.msg="invalid code -- missing end-of-block",_.mode=30;break}if(_.lenbits=9,W={bits:_.lenbits},N=c(d,_.lens,0,_.nlen,_.lencode,0,_.work,W),_.lenbits=W.bits,N){M.msg="invalid literal/lengths set",_.mode=30;break}if(_.distbits=6,_.distcode=_.distdyn,W={bits:_.distbits},N=c(u,_.lens,_.nlen,_.ndist,_.distcode,0,_.work,W),_.distbits=W.bits,N){M.msg="invalid distances set",_.mode=30;break}if(_.mode=20,D===6)break e;case 20:_.mode=21;case 21:if(6<=U&&258<=Z){M.next_out=$,M.avail_out=Z,M.next_in=O,M.avail_in=U,_.hold=V,_.bits=z,a(M,te),$=M.next_out,G=M.output,Z=M.avail_out,O=M.next_in,k=M.input,U=M.avail_in,V=_.hold,z=_.bits,_.mode===12&&(_.back=-1);break}for(_.back=0;fe=(b=_.lencode[V&(1<<_.lenbits)-1])>>>16&255,q=65535&b,!((de=b>>>24)<=z);){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}if(fe&&!(240&fe)){for(X=de,ie=fe,ee=q;fe=(b=_.lencode[ee+((V&(1<<X+ie)-1)>>X)])>>>16&255,q=65535&b,!(X+(de=b>>>24)<=z);){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}V>>>=X,z-=X,_.back+=X}if(V>>>=de,z-=de,_.back+=de,_.length=q,fe===0){_.mode=26;break}if(32&fe){_.back=-1,_.mode=12;break}if(64&fe){M.msg="invalid literal/length code",_.mode=30;break}_.extra=15&fe,_.mode=22;case 22:if(_.extra){for(R=_.extra;z<R;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}_.length+=V&(1<<_.extra)-1,V>>>=_.extra,z-=_.extra,_.back+=_.extra}_.was=_.length,_.mode=23;case 23:for(;fe=(b=_.distcode[V&(1<<_.distbits)-1])>>>16&255,q=65535&b,!((de=b>>>24)<=z);){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}if(!(240&fe)){for(X=de,ie=fe,ee=q;fe=(b=_.distcode[ee+((V&(1<<X+ie)-1)>>X)])>>>16&255,q=65535&b,!(X+(de=b>>>24)<=z);){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}V>>>=X,z-=X,_.back+=X}if(V>>>=de,z-=de,_.back+=de,64&fe){M.msg="invalid distance code",_.mode=30;break}_.offset=q,_.extra=15&fe,_.mode=24;case 24:if(_.extra){for(R=_.extra;z<R;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}_.offset+=V&(1<<_.extra)-1,V>>>=_.extra,z-=_.extra,_.back+=_.extra}if(_.offset>_.dmax){M.msg="invalid distance too far back",_.mode=30;break}_.mode=25;case 25:if(Z===0)break e;if(J=te-Z,_.offset>J){if((J=_.offset-J)>_.whave&&_.sane){M.msg="invalid distance too far back",_.mode=30;break}ue=J>_.wnext?(J-=_.wnext,_.wsize-J):_.wnext-J,J>_.length&&(J=_.length),me=_.window}else me=G,ue=$-_.offset,J=_.length;for(Z<J&&(J=Z),Z-=J,_.length-=J;G[$++]=me[ue++],--J;);_.length===0&&(_.mode=21);break;case 26:if(Z===0)break e;G[$++]=_.length,Z--,_.mode=21;break;case 27:if(_.wrap){for(;z<32;){if(U===0)break e;U--,V|=k[O++]<<z,z+=8}if(te-=Z,M.total_out+=te,_.total+=te,te&&(M.adler=_.check=_.flags?o(_.check,G,te,$-te):i(_.check,G,te,$-te)),te=Z,(_.flags?V:A(V))!==_.check){M.msg="incorrect data check",_.mode=30;break}z=V=0}_.mode=28;case 28:if(_.wrap&&_.flags){for(;z<32;){if(U===0)break e;U--,V+=k[O++]<<z,z+=8}if(V!==(4294967295&_.total)){M.msg="incorrect length check",_.mode=30;break}z=V=0}_.mode=29;case 29:N=1;break e;case 30:N=-3;break e;case 31:return-4;case 32:default:return h}return M.next_out=$,M.avail_out=Z,M.next_in=O,M.avail_in=U,_.hold=V,_.bits=z,(_.wsize||te!==M.avail_out&&_.mode<30&&(_.mode<27||D!==4))&&B(M,M.output,M.next_out,te-M.avail_out)?(_.mode=31,-4):(ne-=M.avail_in,te-=M.avail_out,M.total_in+=ne,M.total_out+=te,_.total+=te,_.wrap&&te&&(M.adler=_.check=_.flags?o(_.check,G,te,M.next_out-te):i(_.check,G,te,M.next_out-te)),M.data_type=_.bits+(_.last?64:0)+(_.mode===12?128:0)+(_.mode===20||_.mode===15?256:0),(ne==0&&te===0||D===4)&&N===f&&(N=-5),N)},s.inflateEnd=function(M){if(!M||!M.state)return h;var D=M.state;return D.window&&(D.window=null),M.state=null,f},s.inflateGetHeader=function(M,D){var _;return M&&M.state&&2&(_=M.state).wrap?((_.head=D).done=!1,f):h},s.inflateSetDictionary=function(M,D){var _,k=D.length;return M&&M.state?(_=M.state).wrap!==0&&_.mode!==11?h:_.mode===11&&i(1,D,k,0)!==_.check?-3:B(M,D,k,k)?(_.mode=31,-4):(_.havedict=1,f):h},s.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(t,n,s){var r=t("../utils/common"),i=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],o=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],a=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],c=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];n.exports=function(d,u,f,h,g,p,m,A){var y,v,x,w,T,C,E,I,P,B=A.bits,M=0,D=0,_=0,k=0,G=0,O=0,$=0,U=0,Z=0,V=0,z=null,ne=0,te=new r.Buf16(16),J=new r.Buf16(16),ue=null,me=0;for(M=0;M<=15;M++)te[M]=0;for(D=0;D<h;D++)te[u[f+D]]++;for(G=B,k=15;1<=k&&te[k]===0;k--);if(k<G&&(G=k),k===0)return g[p++]=20971520,g[p++]=20971520,A.bits=1,0;for(_=1;_<k&&te[_]===0;_++);for(G<_&&(G=_),M=U=1;M<=15;M++)if(U<<=1,(U-=te[M])<0)return-1;if(0<U&&(d===0||k!==1))return-1;for(J[1]=0,M=1;M<15;M++)J[M+1]=J[M]+te[M];for(D=0;D<h;D++)u[f+D]!==0&&(m[J[u[f+D]]++]=D);if(C=d===0?(z=ue=m,19):d===1?(z=i,ne-=257,ue=o,me-=257,256):(z=a,ue=c,-1),M=_,T=p,$=D=V=0,x=-1,w=(Z=1<<(O=G))-1,d===1&&852<Z||d===2&&592<Z)return 1;for(;;){for(E=M-$,P=m[D]<C?(I=0,m[D]):m[D]>C?(I=ue[me+m[D]],z[ne+m[D]]):(I=96,0),y=1<<M-$,_=v=1<<O;g[T+(V>>$)+(v-=y)]=E<<24|I<<16|P|0,v!==0;);for(y=1<<M-1;V&y;)y>>=1;if(y!==0?(V&=y-1,V+=y):V=0,D++,--te[M]==0){if(M===k)break;M=u[f+m[D]]}if(G<M&&(V&w)!==x){for($===0&&($=G),T+=_,U=1<<(O=M-$);O+$<k&&!((U-=te[O+$])<=0);)O++,U<<=1;if(Z+=1<<O,d===1&&852<Z||d===2&&592<Z)return 1;g[x=V&w]=G<<24|O<<16|T-p|0}}return V!==0&&(g[T+V]=M-$<<24|64<<16|0),A.bits=G,0}},{"../utils/common":41}],51:[function(t,n,s){n.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],52:[function(t,n,s){var r=t("../utils/common"),i=0,o=1;function a(b){for(var L=b.length;0<=--L;)b[L]=0}var c=0,d=29,u=256,f=u+1+d,h=30,g=19,p=2*f+1,m=15,A=16,y=7,v=256,x=16,w=17,T=18,C=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],E=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],I=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],P=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],B=new Array(2*(f+2));a(B);var M=new Array(2*h);a(M);var D=new Array(512);a(D);var _=new Array(256);a(_);var k=new Array(d);a(k);var G,O,$,U=new Array(h);function Z(b,L,K,Y,Q){this.static_tree=b,this.extra_bits=L,this.extra_base=K,this.elems=Y,this.max_length=Q,this.has_stree=b&&b.length}function V(b,L){this.dyn_tree=b,this.max_code=0,this.stat_desc=L}function z(b){return b<256?D[b]:D[256+(b>>>7)]}function ne(b,L){b.pending_buf[b.pending++]=255&L,b.pending_buf[b.pending++]=L>>>8&255}function te(b,L,K){b.bi_valid>A-K?(b.bi_buf|=L<<b.bi_valid&65535,ne(b,b.bi_buf),b.bi_buf=L>>A-b.bi_valid,b.bi_valid+=K-A):(b.bi_buf|=L<<b.bi_valid&65535,b.bi_valid+=K)}function J(b,L,K){te(b,K[2*L],K[2*L+1])}function ue(b,L){for(var K=0;K|=1&b,b>>>=1,K<<=1,0<--L;);return K>>>1}function me(b,L,K){var Y,Q,se=new Array(m+1),le=0;for(Y=1;Y<=m;Y++)se[Y]=le=le+K[Y-1]<<1;for(Q=0;Q<=L;Q++){var re=b[2*Q+1];re!==0&&(b[2*Q]=ue(se[re]++,re))}}function de(b){var L;for(L=0;L<f;L++)b.dyn_ltree[2*L]=0;for(L=0;L<h;L++)b.dyn_dtree[2*L]=0;for(L=0;L<g;L++)b.bl_tree[2*L]=0;b.dyn_ltree[2*v]=1,b.opt_len=b.static_len=0,b.last_lit=b.matches=0}function fe(b){8<b.bi_valid?ne(b,b.bi_buf):0<b.bi_valid&&(b.pending_buf[b.pending++]=b.bi_buf),b.bi_buf=0,b.bi_valid=0}function q(b,L,K,Y){var Q=2*L,se=2*K;return b[Q]<b[se]||b[Q]===b[se]&&Y[L]<=Y[K]}function X(b,L,K){for(var Y=b.heap[K],Q=K<<1;Q<=b.heap_len&&(Q<b.heap_len&&q(L,b.heap[Q+1],b.heap[Q],b.depth)&&Q++,!q(L,Y,b.heap[Q],b.depth));)b.heap[K]=b.heap[Q],K=Q,Q<<=1;b.heap[K]=Y}function ie(b,L,K){var Y,Q,se,le,re=0;if(b.last_lit!==0)for(;Y=b.pending_buf[b.d_buf+2*re]<<8|b.pending_buf[b.d_buf+2*re+1],Q=b.pending_buf[b.l_buf+re],re++,Y===0?J(b,Q,L):(J(b,(se=_[Q])+u+1,L),(le=C[se])!==0&&te(b,Q-=k[se],le),J(b,se=z(--Y),K),(le=E[se])!==0&&te(b,Y-=U[se],le)),re<b.last_lit;);J(b,v,L)}function ee(b,L){var K,Y,Q,se=L.dyn_tree,le=L.stat_desc.static_tree,re=L.stat_desc.has_stree,pe=L.stat_desc.elems,Ce=-1;for(b.heap_len=0,b.heap_max=p,K=0;K<pe;K++)se[2*K]!==0?(b.heap[++b.heap_len]=Ce=K,b.depth[K]=0):se[2*K+1]=0;for(;b.heap_len<2;)se[2*(Q=b.heap[++b.heap_len]=Ce<2?++Ce:0)]=1,b.depth[Q]=0,b.opt_len--,re&&(b.static_len-=le[2*Q+1]);for(L.max_code=Ce,K=b.heap_len>>1;1<=K;K--)X(b,se,K);for(Q=pe;K=b.heap[1],b.heap[1]=b.heap[b.heap_len--],X(b,se,1),Y=b.heap[1],b.heap[--b.heap_max]=K,b.heap[--b.heap_max]=Y,se[2*Q]=se[2*K]+se[2*Y],b.depth[Q]=(b.depth[K]>=b.depth[Y]?b.depth[K]:b.depth[Y])+1,se[2*K+1]=se[2*Y+1]=Q,b.heap[1]=Q++,X(b,se,1),2<=b.heap_len;);b.heap[--b.heap_max]=b.heap[1],function(ve,Xe){var Ke,Ye,H,ae,be,Re,Be=Xe.dyn_tree,mt=Xe.max_code,lt=Xe.stat_desc.static_tree,Xn=Xe.stat_desc.has_stree,Xt=Xe.stat_desc.extra_bits,$e=Xe.stat_desc.extra_base,Qe=Xe.stat_desc.max_length,it=0;for(ae=0;ae<=m;ae++)ve.bl_count[ae]=0;for(Be[2*ve.heap[ve.heap_max]+1]=0,Ke=ve.heap_max+1;Ke<p;Ke++)Qe<(ae=Be[2*Be[2*(Ye=ve.heap[Ke])+1]+1]+1)&&(ae=Qe,it++),Be[2*Ye+1]=ae,mt<Ye||(ve.bl_count[ae]++,be=0,$e<=Ye&&(be=Xt[Ye-$e]),Re=Be[2*Ye],ve.opt_len+=Re*(ae+be),Xn&&(ve.static_len+=Re*(lt[2*Ye+1]+be)));if(it!==0){do{for(ae=Qe-1;ve.bl_count[ae]===0;)ae--;ve.bl_count[ae]--,ve.bl_count[ae+1]+=2,ve.bl_count[Qe]--,it-=2}while(0<it);for(ae=Qe;ae!==0;ae--)for(Ye=ve.bl_count[ae];Ye!==0;)mt<(H=ve.heap[--Ke])||(Be[2*H+1]!==ae&&(ve.opt_len+=(ae-Be[2*H+1])*Be[2*H],Be[2*H+1]=ae),Ye--)}}(b,L),me(se,Ce,b.bl_count)}function S(b,L,K){var Y,Q,se=-1,le=L[1],re=0,pe=7,Ce=4;for(le===0&&(pe=138,Ce=3),L[2*(K+1)+1]=65535,Y=0;Y<=K;Y++)Q=le,le=L[2*(Y+1)+1],++re<pe&&Q===le||(re<Ce?b.bl_tree[2*Q]+=re:Q!==0?(Q!==se&&b.bl_tree[2*Q]++,b.bl_tree[2*x]++):re<=10?b.bl_tree[2*w]++:b.bl_tree[2*T]++,se=Q,Ce=(re=0)===le?(pe=138,3):Q===le?(pe=6,3):(pe=7,4))}function N(b,L,K){var Y,Q,se=-1,le=L[1],re=0,pe=7,Ce=4;for(le===0&&(pe=138,Ce=3),Y=0;Y<=K;Y++)if(Q=le,le=L[2*(Y+1)+1],!(++re<pe&&Q===le)){if(re<Ce)for(;J(b,Q,b.bl_tree),--re!=0;);else Q!==0?(Q!==se&&(J(b,Q,b.bl_tree),re--),J(b,x,b.bl_tree),te(b,re-3,2)):re<=10?(J(b,w,b.bl_tree),te(b,re-3,3)):(J(b,T,b.bl_tree),te(b,re-11,7));se=Q,Ce=(re=0)===le?(pe=138,3):Q===le?(pe=6,3):(pe=7,4)}}a(U);var W=!1;function R(b,L,K,Y){te(b,(c<<1)+(Y?1:0),3),function(Q,se,le,re){fe(Q),re&&(ne(Q,le),ne(Q,~le)),r.arraySet(Q.pending_buf,Q.window,se,le,Q.pending),Q.pending+=le}(b,L,K,!0)}s._tr_init=function(b){W||(function(){var L,K,Y,Q,se,le=new Array(m+1);for(Q=Y=0;Q<d-1;Q++)for(k[Q]=Y,L=0;L<1<<C[Q];L++)_[Y++]=Q;for(_[Y-1]=Q,Q=se=0;Q<16;Q++)for(U[Q]=se,L=0;L<1<<E[Q];L++)D[se++]=Q;for(se>>=7;Q<h;Q++)for(U[Q]=se<<7,L=0;L<1<<E[Q]-7;L++)D[256+se++]=Q;for(K=0;K<=m;K++)le[K]=0;for(L=0;L<=143;)B[2*L+1]=8,L++,le[8]++;for(;L<=255;)B[2*L+1]=9,L++,le[9]++;for(;L<=279;)B[2*L+1]=7,L++,le[7]++;for(;L<=287;)B[2*L+1]=8,L++,le[8]++;for(me(B,f+1,le),L=0;L<h;L++)M[2*L+1]=5,M[2*L]=ue(L,5);G=new Z(B,C,u+1,f,m),O=new Z(M,E,0,h,m),$=new Z(new Array(0),I,0,g,y)}(),W=!0),b.l_desc=new V(b.dyn_ltree,G),b.d_desc=new V(b.dyn_dtree,O),b.bl_desc=new V(b.bl_tree,$),b.bi_buf=0,b.bi_valid=0,de(b)},s._tr_stored_block=R,s._tr_flush_block=function(b,L,K,Y){var Q,se,le=0;0<b.level?(b.strm.data_type===2&&(b.strm.data_type=function(re){var pe,Ce=4093624447;for(pe=0;pe<=31;pe++,Ce>>>=1)if(1&Ce&&re.dyn_ltree[2*pe]!==0)return i;if(re.dyn_ltree[18]!==0||re.dyn_ltree[20]!==0||re.dyn_ltree[26]!==0)return o;for(pe=32;pe<u;pe++)if(re.dyn_ltree[2*pe]!==0)return o;return i}(b)),ee(b,b.l_desc),ee(b,b.d_desc),le=function(re){var pe;for(S(re,re.dyn_ltree,re.l_desc.max_code),S(re,re.dyn_dtree,re.d_desc.max_code),ee(re,re.bl_desc),pe=g-1;3<=pe&&re.bl_tree[2*P[pe]+1]===0;pe--);return re.opt_len+=3*(pe+1)+5+5+4,pe}(b),Q=b.opt_len+3+7>>>3,(se=b.static_len+3+7>>>3)<=Q&&(Q=se)):Q=se=K+5,K+4<=Q&&L!==-1?R(b,L,K,Y):b.strategy===4||se===Q?(te(b,2+(Y?1:0),3),ie(b,B,M)):(te(b,4+(Y?1:0),3),function(re,pe,Ce,ve){var Xe;for(te(re,pe-257,5),te(re,Ce-1,5),te(re,ve-4,4),Xe=0;Xe<ve;Xe++)te(re,re.bl_tree[2*P[Xe]+1],3);N(re,re.dyn_ltree,pe-1),N(re,re.dyn_dtree,Ce-1)}(b,b.l_desc.max_code+1,b.d_desc.max_code+1,le+1),ie(b,b.dyn_ltree,b.dyn_dtree)),de(b),Y&&fe(b)},s._tr_tally=function(b,L,K){return b.pending_buf[b.d_buf+2*b.last_lit]=L>>>8&255,b.pending_buf[b.d_buf+2*b.last_lit+1]=255&L,b.pending_buf[b.l_buf+b.last_lit]=255&K,b.last_lit++,L===0?b.dyn_ltree[2*K]++:(b.matches++,L--,b.dyn_ltree[2*(_[K]+u+1)]++,b.dyn_dtree[2*z(L)]++),b.last_lit===b.lit_bufsize-1},s._tr_align=function(b){te(b,2,3),J(b,v,B),function(L){L.bi_valid===16?(ne(L,L.bi_buf),L.bi_buf=0,L.bi_valid=0):8<=L.bi_valid&&(L.pending_buf[L.pending++]=255&L.bi_buf,L.bi_buf>>=8,L.bi_valid-=8)}(b)}},{"../utils/common":41}],53:[function(t,n,s){n.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(t,n,s){(function(r){(function(i,o){if(!i.setImmediate){var a,c,d,u,f=1,h={},g=!1,p=i.document,m=Object.getPrototypeOf&&Object.getPrototypeOf(i);m=m&&m.setTimeout?m:i,a={}.toString.call(i.process)==="[object process]"?function(x){process.nextTick(function(){y(x)})}:function(){if(i.postMessage&&!i.importScripts){var x=!0,w=i.onmessage;return i.onmessage=function(){x=!1},i.postMessage("","*"),i.onmessage=w,x}}()?(u="setImmediate$"+Math.random()+"$",i.addEventListener?i.addEventListener("message",v,!1):i.attachEvent("onmessage",v),function(x){i.postMessage(u+x,"*")}):i.MessageChannel?((d=new MessageChannel).port1.onmessage=function(x){y(x.data)},function(x){d.port2.postMessage(x)}):p&&"onreadystatechange"in p.createElement("script")?(c=p.documentElement,function(x){var w=p.createElement("script");w.onreadystatechange=function(){y(x),w.onreadystatechange=null,c.removeChild(w),w=null},c.appendChild(w)}):function(x){setTimeout(y,0,x)},m.setImmediate=function(x){typeof x!="function"&&(x=new Function(""+x));for(var w=new Array(arguments.length-1),T=0;T<w.length;T++)w[T]=arguments[T+1];var C={callback:x,args:w};return h[f]=C,a(f),f++},m.clearImmediate=A}function A(x){delete h[x]}function y(x){if(g)setTimeout(y,0,x);else{var w=h[x];if(w){g=!0;try{(function(T){var C=T.callback,E=T.args;switch(E.length){case 0:C();break;case 1:C(E[0]);break;case 2:C(E[0],E[1]);break;case 3:C(E[0],E[1],E[2]);break;default:C.apply(o,E)}})(w)}finally{A(x),g=!1}}}}function v(x){x.source===i&&typeof x.data=="string"&&x.data.indexOf(u)===0&&y(+x.data.slice(u.length))}})(typeof self>"u"?r===void 0?this:r:self)}).call(this,typeof us<"u"?us:typeof self<"u"?self:typeof window<"u"?window:{})},{}]},{},[10])(10)})})(za);var Sp=za.exports;const Do=xp(Sp);class ht extends Je{constructor(e,t){super(),this.character=e,this.gs=t,this.debugAxes=new Map,this.isReady=!1,this.t=0}static async initVRM(e,t,n,s,r,i){i||(i=(await(await fetch("./assets/default.json")).json()).boneOperations),r||(r=1);const o=new Ph(t,e,"",r,!0);await o.loadingPromise,o.skinnedMeshIndex=1,o.faceIndex=void 0,o.currentVrm.scene.children.length>4&&(o.skinnedMeshIndex=2,o.faceIndex=1);const a=o.currentVrm.scene.children[o.skinnedMeshIndex];if(_u(o,!1),wu(o,i),a.skeleton.update(),a.skeleton.computeBoneTexture(),a.geometry.computeVertexNormals(),o.skinnedMeshIndex===2){const g=o.currentVrm.humanoid.getRawBoneNode("head"),p=new As;p.name="J_Bip_C_HeadTop_End",p.position.set(0,.2,-.05),p.updateMatrixWorld(!0),g.add(p),a.skeleton.bones.push(p),a.bind(new Cn(a.skeleton.bones),a.matrixWorld)}s.render(t,n),a.bindMatrix0=a.bindMatrix.clone(),a.bindMatrixInverse0=a.bindMatrixInverse.clone();const c=a.skeleton.boneTexture.image.width,d=a.skeleton.boneTexture.image.height,u=a.skeleton.boneTexture.format,f=a.skeleton.boneTexture.type,h=a.skeleton.boneTexture.image.data.slice();return a.boneTexture0=new wt(h,c,d,u,f),a.boneTexture0.needsUpdate=!0,o}static async initGS(e,t,n,s,r){const i=await new yp(e,1,t,n,r);return await i.loadingPromise,s.add(i),i.splatMesh=i.viewer.splatMesh,i.centers=i.splatMesh.splatDataTextures.baseData.centers,i.colors=i.splatMesh.splatDataTextures.baseData.colors,i.covariances=i.splatMesh.splatDataTextures.baseData.covariances,i.splatCount=i.splatMesh.geometry.attributes.splatIndex.array.length,i.centers0=new Float32Array(i.centers),i.colors0=new Float32Array(i.colors),i.covariances0=new Float32Array(i.covariances),i.splatMesh.updateDataTexturesFromBaseData(0,i.splatCount-1),i.vrmSplatCount=76337,i}static async load(e,t,n,s,r,i){if(!e){await ht.initGS([],[],[],t,i);return}console.log("Loading GVRM:",e);const o=await fetch(e),a=await Do.loadAsync(o.arrayBuffer()),c=await a.file("model.vrm").async("arraybuffer"),d=await a.file("model.ply").async("arraybuffer"),u=JSON.parse(await a.file("data.json").async("text")),f=new Blob([c],{type:"application/octet-stream"}),h=URL.createObjectURL(f),g=new Blob([d],{type:"application/octet-stream"}),p=URL.createObjectURL(g),m=u.modelScale,A=u.boneOperations;u.splatRelativePoses===void 0&&(u.splatRelativePoses=u.relativePoses);const y=await ht.initVRM(h,t,n,s,m,A),{sceneSplatIndices:v,boneSceneMap:x}=ht.sortSplatsByBones(u),T=await new vp().splitPLY(p,v),C=await ht.initGS(T,u.gsPosition,u.gsQuaternion,t,i),E=new ht(y,C);E.modelScale=m,E.boneOperations=A,E.boneSceneMap=x,E.fileName=r,E.updatePMC(),Mu(t,E.pmc),Cu(E.pmc,!1),s.render(t,n),E.gs.splatVertexIndices=u.splatVertexIndices,E.gs.splatBoneIndices=u.splatBoneIndices,E.gs.splatRelativePoses=u.splatRelativePoses,ht.gsCustomizeMaterial(y,C);for(let B=0;B<E.gs.vrmSplatCount;B++){let M=Math.sqrt(E.gs.splatRelativePoses[B*3+0]**2+E.gs.splatRelativePoses[B*3+1]**2+E.gs.splatRelativePoses[B*3+2]**2);(E.gs.splatBoneIndices[B]!==57&&M>.2||E.gs.splatBoneIndices[B]==21&&M>.1||E.gs.splatBoneIndices[B]==19&&M>.1||E.gs.splatBoneIndices[B]===57&&M>.3)&&(E.gs.colors[B*4+3]=0)}E.gs.splatMesh.updateDataTexturesFromBaseData(0,E.gs.splatCount-1);function I(B,M=0){B.children.forEach(function(D){D.isBone&&(["J_Bip_L_Hand","J_Bip_L_LowerArm","J_Bip_R_Hand","J_Bip_R_LowerArm","J_Bip_L_LowerLeg","J_Bip_L_Foot","J_Bip_R_LowerLeg","J_Bip_R_Foot","J_Bip_C_Neck","J_Bip_C_Spine","J_Bip_C_Chest","J_Bip_C_UpperChest","J_Bip_C_HeadTop_End","J_Bip_C_Head"].includes(D.name)&&(D.updateMatrix(),D.matrixWorld0=D.matrixWorld.clone()),I(D,M+1))})}const P=y.currentVrm.scene.children[0].children[0];return I(P,1),E.isReady=!0,E}static async save(e,t,n,s,r,i,o=!1){const a=await fetch(t).then(g=>g.arrayBuffer()),c=await fetch(n).then(g=>g.arrayBuffer()),d={modelScale:r,boneOperations:s,gsQuaternion:e.gs.viewer.splatMesh.scenes[0].quaternion.toArray(),gsPosition:e.gs.viewer.splatMesh.scenes[0].position.toArray(),splatVertexIndices:e.gs.splatVertexIndices,splatBoneIndices:e.gs.splatBoneIndices,splatRelativePoses:e.gs.splatRelativePoses},u=new Do;u.file("model.vrm",a),u.file("model.ply",c),u.file("data.json",JSON.stringify(d,null,2));const f=await u.generateAsync({type:"blob"});if(!i&&n.endsWith(".ply")?i=n.split("/").pop().replace(".ply",".gvrm"):i||(i=n.split("/").pop()+".gvrm"),h(f,i),o){console.log("savePly!");const g=new Blob([c],{type:"application/octet-stream"}),p=i.replace(".gvrm","_processed.ply");h(g,p)}function h(g,p){const m=URL.createObjectURL(g),A=document.createElement("a");A.href=m,A.download=p,A.click(),g===f&&e.url&&URL.revokeObjectURL(e.url),g===f?e.url=m:URL.revokeObjectURL(m)}}static async remove(e,t){e.character&&(await e.character.leave(t),e.character=null),e.gs&&(await e.gs.viewer.dispose(),e.gs=null),e.pmc&&Tu(t,e.pmc)}async load(e,t,n,s,r=null){const i=await ht.load(e,t,n,s,r);this.character=i.character,this.gs=i.gs,this.modelScale=i.modelScale,this.boneOperations=i.boneOperations,this.boneSceneMap=i.boneSceneMap,this.vertexSceneMap=i.vertexSceneMap,this.fileName=i.fileName,this.isReady=!0}async save(e,t,n,s,r,i=!1){await ht.save(this,e,t,n,s,r,i)}async remove(e){this.isReady=!1,await ht.remove(this,e)}async changeFBX(e){await this.character.changeFBX(e)}updatePMC(){const{pmc:e}=bu(this.character);this.pmc=e}updateByBones(){const e=new F,t=new F,n=new F,s=new he,r=new ce,i=["J_Bip_C_Neck","J_Bip_C_Spine","J_Bip_C_Chest","J_Bip_C_UpperChest","J_Bip_C_HeadTop_End","J_Bip_C_Head"],o=this.character.currentVrm.scene.children[2].skeleton;o.bones.forEach(a=>{const c=a.children;c.length!==0&&c.forEach(d=>{const u=o.bones.indexOf(d),f=this.boneSceneMap[u];if(f===void 0)return;a.updateMatrixWorld(!0),d.updateMatrixWorld(!0),e.setFromMatrixPosition(a.matrixWorld),t.setFromMatrixPosition(d.matrixWorld),n.addVectors(e,t).multiplyScalar(.5),n.sub(this.character.currentVrm.scene.position).add(this.character.currentVrm.scene.position0),n.applyQuaternion(this.gs.viewer.quaternion.clone().invert()),s.extractRotation(d.matrixWorld.multiply(d.matrixWorld0.clone().invert())),r.setFromRotationMatrix(s),r.premultiply(this.gs.viewer.quaternion.clone().invert()),r.multiply(this.gs.quaternion0);const h=this.gs.viewer.getSplatScene(f);if(h){i.includes(d.name)||(h.position.copy(n),h.quaternion.copy(r));let g=this.debugAxes.get(f);g||(g=this.createDebugAxes(f)),g.position.copy(n),g.quaternion.copy(r)}})})}createDebugAxes(e){const t=new Qo(.3);return t.visible=!1,this.gs.add(t),this.debugAxes.set(e,t),t}update(){if(!this.isReady)return;const e={};for(let i=14;i<this.gs.viewer.getSceneCount();++i){const o=this.gs.viewer.getSplatScene(i);e[i]=o.matrixWorld.clone()}let t=this.character.currentVrm.scene.quaternion.clone(),n=this.character.currentVrm.scene.quaternion0.clone(),s=this.character.currentVrm.scene.position.clone(),r=this.character.currentVrm.scene.position0.clone();this.gs.viewer.quaternion.copy(t.clone().multiply(n.invert())),this.gs.viewer.position.copy(s.clone().sub(r)),this.gs.viewer.updateMatrixWorld();for(let i=14;i<this.gs.viewer.getSceneCount();++i){const o=this.gs.viewer.getSplatScene(i);this.gs.viewer.matrixWorld.clone().invert().multiply(e[i]).decompose(o.position,o.quaternion,o.scale)}this.updateByBones(),this.character.update()}static sortSplatsByBones(e){const t={};let n=0;const s={};for(let r=0;r<e.splatBoneIndices.length;r++){const i=e.splatBoneIndices[r];s[i]===void 0&&(s[i]=n,n++,t[s[i]]=[]),t[s[i]].push(r)}return ht.updateExtraData(e,t),{sceneSplatIndices:t,boneSceneMap:s}}static updateExtraData(e,t){let n=[];for(let o=0;o<Object.keys(t).length;o++)n=n.concat(t[o]);const s=[],r=[],i=[];for(const o of Object.keys(t))for(const a of t[o])s.push(e.splatVertexIndices[a]),r.push(e.splatBoneIndices[a]),i.push(e.splatRelativePoses[a*3],e.splatRelativePoses[a*3+1],e.splatRelativePoses[a*3+2]);e.splatVertexIndices=s,e.splatBoneIndices=r,e.splatRelativePoses=i}static gsCustomizeMaterial(e,t){t.splatMesh.material=t.splatMesh.material.clone(),t.splatMesh.material.needsUpdate=!0;const n=e.currentVrm.scene.children[e.skinnedMeshIndex],s=n.geometry.attributes.position.count,r=n.geometry.attributes.position.array,i=n.geometry.attributes.normal.array,o=n.geometry.attributes.skinIndex.array,a=n.geometry.attributes.skinWeight.array,c=t.splatVertexIndices,d=t.splatRelativePoses,u=new Float32Array(4096*1024*4),f=new Float32Array(4096*1024*4),h=new Float32Array(4096*1024*4),g=new Float32Array(4096*1024*4),p=new Float32Array(4096*1024*4),m=new Float32Array(4096*1024*4);Jn(r,u,s,1),Jn(i,f,s,1),h.set(o),g.set(a),Jn(c,p,t.splatCount,3),Jn(d,m,t.splatCount,1);const A=tn(u,4096,1024,Ct,Ut),y=tn(f,4096,1024,Ct,Ut),v=tn(h,4096,1024,Ct,Ut),x=tn(g,4096,1024,Ct,Ut),w=tn(p,4096,1024,Ct,Ut),T=tn(m,4096,1024,Ct,Ut);t.splatMesh.material.onBeforeCompile=function(C){C.uniforms.meshPositionTexture={value:A},C.uniforms.meshNormalTexture={value:y},C.uniforms.meshSkinIndexTexture={value:v},C.uniforms.meshSkinWeightTexture={value:x},C.uniforms.gsMeshVertexIndexTexture={value:w},C.uniforms.gsMeshRelativePosTexture={value:T},C.uniforms.bindMatrix0={value:n.bindMatrix0},C.uniforms.bindMatrix={value:n.bindMatrix},C.uniforms.bindMatrixInverse0={value:n.bindMatrixInverse0},C.uniforms.bindMatrixInverse={value:n.bindMatrixInverse},C.uniforms.boneTexture0={value:n.boneTexture0},C.uniforms.boneTexture={value:n.skeleton.boneTexture},C.uniforms.meshMatrixWorld={value:e.currentVrm.scene.matrixWorld},C.uniforms.gsMatrix0={value:t.matrix0},C.uniforms.gsMatrix={value:t.viewer.matrixWorld},C.uniforms.VRM_SCENE_COUNT={value:14},C.vertexShader=C.vertexShader.replace("#include <common>",`
        #define USE_SKINNING

        #include <common>
        #include <skinning_pars_vertex>  // boneTexture

        uniform sampler2D meshPositionTexture;
        uniform sampler2D meshNormalTexture;
        uniform sampler2D meshSkinIndexTexture;
        uniform sampler2D meshSkinWeightTexture;
        uniform sampler2D gsMeshVertexIndexTexture;
        uniform sampler2D gsMeshRelativePosTexture;
        uniform mat4 meshMatrixWorld;
        uniform mat4 gsMatrix0;
        uniform mat4 gsMatrix;

        uniform mat4 bindMatrix0;
        uniform mat4 bindMatrixInverse0;
        uniform highp sampler2D boneTexture0;

        uniform uint VRM_SCENE_COUNT;

        mat4 getBoneMatrix0( const in float i ) {
          int size = textureSize( boneTexture0, 0 ).x;
          int j = int( i ) * 4;
          int x = j % size;
          int y = j / size;
          vec4 v1 = texelFetch( boneTexture0, ivec2( x, y ), 0 );
          vec4 v2 = texelFetch( boneTexture0, ivec2( x + 1, y ), 0 );
          vec4 v3 = texelFetch( boneTexture0, ivec2( x + 2, y ), 0 );
          vec4 v4 = texelFetch( boneTexture0, ivec2( x + 3, y ), 0 );
          return mat4( v1, v2, v3, v4 );
        }

        // TODO: check this
        vec4 quatFromMat3(mat3 m) {
          float trace = m[0][0] + m[1][1] + m[2][2];
          vec4 q;

          if (trace > 0.0) {
            float s = 0.5 / sqrt(trace + 1.0);
            q.w = 0.25 / s;
            q.x = (m[2][1] - m[1][2]) * s;
            q.y = (m[0][2] - m[2][0]) * s;
            q.z = (m[1][0] - m[0][1]) * s;
          } else if (m[0][0] > m[1][1] && m[0][0] > m[2][2]) {
            float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);
            q.w = (m[2][1] - m[1][2]) / s;
            q.x = 0.25 * s;
            q.y = (m[0][1] + m[1][0]) / s;
            q.z = (m[0][2] + m[2][0]) / s;
          } else if (m[1][1] > m[2][2]) {
            float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);
            q.w = (m[0][2] - m[2][0]) / s;
            q.x = (m[0][1] + m[1][0]) / s;
            q.y = 0.25 * s;
            q.z = (m[1][2] + m[2][1]) / s;
          } else {
            float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);
            q.w = (m[1][0] - m[0][1]) / s;
            q.x = (m[0][2] + m[2][0]) / s;
            q.y = (m[1][2] + m[2][1]) / s;
            q.z = 0.25 * s;
          }
          return q;
        }

        vec4 quatInverse(vec4 q) {
          return vec4(-q.x, -q.y, -q.z, q.w) / dot(q, q);
        }

        vec4 quatMultiply(vec4 a, vec4 b) {
          return vec4(
            a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
            a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,
            a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w,
            a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z
          );
        }

        mat3 mat3FromQuat(vec4 q) {
          float x = q.x, y = q.y, z = q.z, w = q.w;
          float x2 = x + x, y2 = y + y, z2 = z + z;
          float xx = x * x2, xy = x * y2, xz = x * z2;
          float yy = y * y2, yz = y * z2, zz = z * z2;
          float wx = w * x2, wy = w * y2, wz = w * z2;

          return mat3(
            1.0 - (yy + zz), xy - wz, xz + wy,
            xy + wz, 1.0 - (xx + zz), yz - wx,
            xz - wy, yz + wx, 1.0 - (xx + yy)
          );
        }
        `),C.vertexShader=C.vertexShader.replace("mat4 transform = transforms[sceneIndex]","mat4 transform = sceneIndex >= VRM_SCENE_COUNT ? transforms[sceneIndex] : gsMatrix * gsMatrix0"),C.vertexShader=C.vertexShader.replace("vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));",`
        vec3 splatCenter;
        mat4 skinMatrix0;
        mat4 skinMatrix_;
        if(sceneIndex >= VRM_SCENE_COUNT) splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba)); else {
        vec2 samplerUV2 = vec2(0.0, 0.0);
        float d2 = float(splatIndex) / 4096.0;
        samplerUV2.y = float(floor(d2)) / 1024.0;
        samplerUV2.x = fract(d2);
        float meshVertexIndex = texture2D(gsMeshVertexIndexTexture, samplerUV2).r;
        vec3 relativePos = texture2D(gsMeshRelativePosTexture, samplerUV2).rgb;

        vec2 samplerUV3 = vec2(0.0, 0.0);
        float d3 = float(meshVertexIndex) / 4096.0;
        samplerUV3.y = float(floor(d3)) / 1024.0;
        samplerUV3.x = fract(d3);
        vec3 transformed = texture2D(meshPositionTexture, samplerUV3).rgb;
        vec3 objectNormal = texture2D(meshNormalTexture, samplerUV3).rgb;
        vec4 skinIndex = texture2D(meshSkinIndexTexture, samplerUV3);
        vec4 skinWeight = texture2D(meshSkinWeightTexture, samplerUV3);

        mat4 boneMatX0 = getBoneMatrix0( skinIndex.x );
        mat4 boneMatY0 = getBoneMatrix0( skinIndex.y );
        mat4 boneMatZ0 = getBoneMatrix0( skinIndex.z );
        mat4 boneMatW0 = getBoneMatrix0( skinIndex.w );
        skinMatrix0 = mat4( 0.0 );
        skinMatrix0 += skinWeight.x * boneMatX0;
        skinMatrix0 += skinWeight.y * boneMatY0;
        skinMatrix0 += skinWeight.z * boneMatZ0;
        skinMatrix0 += skinWeight.w * boneMatW0;
        skinMatrix0 = bindMatrixInverse0 * skinMatrix0 * bindMatrix0;

        #include <skinbase_vertex>  // boneMat
        #include <skinnormal_vertex>  // skinMatrix, using normal
        #include <defaultnormal_vertex>  // ?
        #include <skinning_vertex>

        // vec3 splatCenter = ( vec4(transformed, 1.0) ).xyz;
        // vec3 splatCenter = ( meshMatrixWorld * vec4(transformed, 1.0) ).xyz;
        // vec3 splatCenter = ( meshMatrixWorld * vec4(transformed + relativePos, 1.0) ).xyz;  // GOOD

        vec3 skinnedRelativePos = vec4( skinMatrix * inverse(skinMatrix0) * vec4( relativePos, 0.0 ) ).xyz;
        splatCenter = ( meshMatrixWorld * vec4(transformed + skinnedRelativePos, 1.0) ).xyz;
        skinMatrix_ = skinMatrix; }
        `),C.vertexShader=C.vertexShader.replace("vec4 viewCenter = transformModelViewMatrix * vec4(splatCenter, 1.0);",`
        // The splatCenter is the coordinate system for inverse(transform).
        if(sceneIndex < VRM_SCENE_COUNT) {
          splatCenter = (inverse(transform) * vec4(splatCenter, 1.0)).xyz;
        }
        vec4 viewCenter = transformModelViewMatrix * vec4(splatCenter, 1.0);
        `),C.vertexShader=C.vertexShader.replace("mat3 cov2Dm = transpose(T) * Vrk * T;",`mat3 cov2Dm;
        if (sceneIndex >= VRM_SCENE_COUNT) cov2Dm = transpose(T) * Vrk * T; else {
        // for debug
        // Vrk[0][0] *= 25.0; Vrk[1][1] *= 0.1; Vrk[2][2] *= 0.1;
        // Vrk[1][1] *= 25.0; Vrk[0][0] *= 0.1; Vrk[2][2] *= 0.1;
        // Vrk[2][2] *= 25.0; Vrk[0][0] *= 0.1; Vrk[1][1] *= 0.1;

        // via quat
        mat3 gsRotation0 = mat3(gsMatrix0);
        mat3 skinRotationMatrix = mat3(skinMatrix_ * inverse(skinMatrix0));
        mat3 relativeRotation = transpose(gsRotation0) * skinRotationMatrix * gsRotation0;
        vec4 tempQuat = quatFromMat3(relativeRotation);
        tempQuat.y = -tempQuat.y;  // Hardcode, maybe bug in quatFromMat3?
        relativeRotation = mat3FromQuat(tempQuat);
        mat3 rotatedVrk = transpose(relativeRotation) * Vrk * relativeRotation;
        cov2Dm = transpose(T) * rotatedVrk * T;

        // TODO: via mat
        // mat3 gsRotation0 = mat3(gsMatrix0);
        // mat3 skinRotationMatrix = mat3(skinMatrix_ * inverse(skinMatrix0));
        // mat3 relativeRotation = transpose(gsRotation0) * skinRotationMatrix * gsRotation0;
        // mat3 rotatedVrk = transpose(relativeRotation) * Vrk * relativeRotation;
        // mat3 cov2Dm = transpose(T) * rotatedVrk * T;
      }
        `)},t.splatMesh.material.needsUpdate=!0}}const Tt=1,hs=.1*Tt,fr=.8*Tt,wp=1*Tt,_p=8*Tt,Fo=1/60,Cp=5;window.__MUTED__=!1;function Lo(l){window.__MUTED__=!!l;const e=document.getElementById("volumeToggle");e&&(e.textContent=window.__MUTED__?"":"")}async function Tp(l){try{const q=sl(),X=new Promise((ie,ee)=>setTimeout(()=>ee(new Error("Rapier initialization timeout")),l.RAPIER_INIT_TIMEOUT));await Promise.race([q,X]),console.log(" Rapier physics initialized")}catch(q){console.error("Failed to initialize Rapier:",q)}const e=new qo;e.background=new Se(2105376);const t=new Ps(75,window.innerWidth/window.innerHeight,.1,1e3);t.rotation.y=Math.PI;const n=new Xo;n.setSize(window.innerWidth,window.innerHeight),n.setPixelRatio(1),n.outputColorSpace=Ue,document.body.appendChild(n.domElement);const s=new Ql(16774374,2759178,1);s.position.set(0,20,0),e.add(s);const r=new Pr(16770764,.3);r.position.set(3,10,-5),e.add(r);const i=new ys(16753920,2,10);i.position.set(-3.2,-1,4.5),e.add(i);const o=new rl((q=>{const ie=Math.sqrt(q[0]*q[0]+q[1]*q[1]+q[2]+q[2]);return{x:9.81*q[0]/ie,y:9.81*q[1]/ie,z:9.81*q[2]/ie}})(l.GRAVITY)),a=new Map;let c=null;{const X=oi.dynamic().setTranslation(0,1.2,0).lockRotations(!0).setLinearDamping(4).setCcdEnabled(!0);c=o.createRigidBody(X);const ie=ai.capsule(fr,hs).setFriction(.8).setRestitution(0);o.createCollider(ie,c)}console.log(c);const d=new Jl(t,document.body),u=document.getElementById("start"),f=document.getElementById("info");document.getElementById("loading"),u.addEventListener("click",()=>d.lock()),d.addEventListener("lock",()=>{f.style.display="none";const q=document.getElementById("reticle");q&&(q.style.display="block")}),d.addEventListener("unlock",()=>{f.style.display="";const q=document.getElementById("reticle");q&&(q.style.display="none")});let h=null;function g(){h||(h=new(window.AudioContext||window.webkitAudioContext),Promise.all([]).then(()=>{console.log(" Audio system initialized")}).catch(q=>{console.error("Audio loading error:",q)}))}document.addEventListener("click",g,{once:!0}),document.addEventListener("keydown",g,{once:!0});const p=document.getElementById("volumeToggle");p&&(p.addEventListener("click",()=>{Lo(!window.__MUTED__)}),Lo(window.__MUTED__));const m=new Gl,A=new Map;function y(q,X){X!==void 0&&(q.rotateX(X[0]*Math.PI/180),q.rotateY(X[1]*Math.PI/180),q.rotateZ(X[2]*Math.PI/180))}const v=new oa,x=new yu;async function w({url:q,rotation:X,scale:ie=1}){const S=(await v.loadAsync(q)).scene;return y(S,X),S.scale.set(-ie*Tt,-ie*Tt,ie*Tt),S}async function T({url:q,rotation:X,scale:ie=1}){const ee=await x.loadAsync(q),S=new Oe(ee);return y(S,X),S.scale.set(-ie*Tt,-ie*Tt,ie*Tt),S}function C(q,X=0){q.traverse(ie=>{if(ie.isMesh){const ee=ie.geometry.clone();ie.updateWorldMatrix(!0,!1),ee.applyMatrix4(ie.matrixWorld);const S=new Float32Array(ee.attributes.position.array);let N;if(ee.index)N=new Uint32Array(ee.index.array);else{const b=ee.attributes.position.count;N=new Uint32Array(b);for(let L=0;L<b;L++)N[L]=L}const W=ai.trimesh(S,N).setRestitution(X),R=o.createRigidBody(oi.fixed());o.createCollider(W,R)}})}const E=new Br;function I({texture:q,width:X,height:ie,position:ee,rotation:S,scale:N}){const W=X/ie,R=1,b=R*W,L=new _s(b,R),K=new xs({map:q,side:Ss}),Y=new _s(b,R),Q=new xs({color:8421504,side:jo}),se=new Oe(L,K),le=new Oe(Y,Q);return se.position.set(...ee),le.position.set(...ee),y(se,S),y(le,S),se.scale.set(N,N,N),le.scale.set(N,N,N),[se,le]}async function P({url:q,...X}){const ie=await E.loadAsync(q),ee=ie.image.width,S=ie.image.height;return I({texture:ie,width:ee,height:S,...X})}async function B({url:q,muted:X,loop:ie,...ee}){const S=document.createElement("video");S.src=q,S.muted=X,S.loop=ie,document.addEventListener("click",()=>S.play()),await new Promise((b,L)=>{S.addEventListener("loadedmetadata",b,{once:!0}),S.addEventListener("error",L,{once:!0})});const N=S.videoWidth,W=S.videoHeight,R=new ql(S);return I({texture:R,width:N,height:W,...ee})}const M=[],D=[],_=[];let k=!1;Promise.allSettled(l.objects.map(async q=>{if(q.type!=="gaussian-model")if(q.type==="collision-mesh"){const X=await(q.url.toLowerCase().endsWith(".ply")?T:w)(q);C(X,q.restitution),e.add(X),X.visible=!1,D.push(X)}else if(q.type==="image"){const[X,ie]=await P(q);C(X,q.restitution),e.add(X),e.add(ie),q.to!==void 0&&a.set(X,function(){const ee=new URL(window.location);ee.searchParams.set("model",q.to),window.location.href=ee}),_.push(X)}else if(q.type==="video"){const[X,ie]=await B(q);C(X,q.restitution),e.add(X),e.add(ie),new URLSearchParams(window.location.search).get("debug_video")&&a.set(X,()=>{}),_.push(X)}else console.error("Unknown type")}).map(q=>q.catch(X=>console.error(X)))).then(()=>{k=!0});let G;ht.load(l.character?.gvrm,e,t,n,l.character?.gvrm,l.objects.filter(q=>q.type==="gaussian-model")).then(q=>{q&&(G=q,G.changeFBX(l.character.idle_fbx),console.log(G))});const O={};let $=!1,U={mesh:null,savedEmissive:null};window.addEventListener("keydown",q=>{if(O[q.code]=!0,q.code==="KeyM"&&($=!$,V()),q.code==="Space"&&c&&Z()){const X=c.linvel();c.setLinvel({x:X.x,y:_p,z:X.z},!0)}if(q.code==="KeyP")if(c){const X=c.translation(),ie=`pos=(${X.x.toFixed(3)}, ${X.y.toFixed(3)}, ${X.z.toFixed(3)})`,ee=new F;t.getWorldDirection(ee),ee.normalize();const S=Math.atan2(ee.x,ee.z)*180/Math.PI,N=Math.asin(Ae.clamp(ee.y,-1,1))*180/Math.PI,W=c.rotation?.(),R=W?`quat=(${W.x.toFixed(3)}, ${W.y.toFixed(3)}, ${W.z.toFixed(3)}, ${W.w.toFixed(3)})`:"";console.log(`[Player] ${ie}  yaw=${S.toFixed(1)}  pitch=${N.toFixed(1)}  ${R}`)}else console.log("[Player] body not initialized yet")}),window.addEventListener("keyup",q=>{O[q.code]=!1}),window.addEventListener("click",()=>{d.isLocked&&U.mesh&&a.get(U.mesh)()});function Z(){if(!c)return!1;const q=c.translation(),X={x:q.x,y:q.y,z:q.z},ie={x:0,y:-1,z:0},ee=new li(X,ie),S=fr+hs,N=o.castRayAndGetNormal(ee,S+.6,!0);if(!N)return!1;const W=N.normal?N.normal.y:1,R=N.toi<=S+.12&&W>.3,b=c.linvel().y;return R&&b<=.6}function V(){k&&($?(M.forEach(q=>e.remove(q)),D.forEach(q=>{q.visible=!0,q.traverse(X=>{X.isMesh&&(A.has(X.uuid)||A.set(X.uuid,X.material),X.geometry.attributes.normal||X.geometry.computeVertexNormals(),X.material=m)})})):(M.forEach(q=>e.add(q)),D.forEach(q=>{q.visible=!1,q.traverse(X=>{X.isMesh&&A.has(X.uuid)&&(X.material=A.get(X.uuid))})})))}let z=l.height_offset??0,ne=!1;function te(q){if(!d.isLocked||!c)return;const X=new F;t.getWorldDirection(X),X.y=0,X.normalize();const ie=new F;ie.crossVectors(X,t.up).normalize();const ee=new F;O.KeyW&&ee.add(X),O.KeyS&&ee.sub(X),O.KeyD&&ee.add(ie),O.KeyA&&ee.sub(ie);const S=!!(O.KeyA||O.KeyS||O.KeyD||O.KeyW);if(G&&S!==ne&&G.changeFBX(S?l.character.walking_fbx:l.character.idle_fbx),ne=S,U.mesh){const L=O.AltLeft?-1:1;if(O.KeyZ&&(U.mesh.position.x+=L*.001),O.KeyX&&(U.mesh.position.y+=L*.001),O.KeyC&&(U.mesh.position.z+=L*.001),O.KeyV&&U.mesh.rotateX(L*.001),O.KeyB&&U.mesh.rotateY(L*.001),O.KeyN&&U.mesh.rotateZ(L*.001),O.Comma&&U.mesh.scale.multiplyScalar(1+L*.001),O.Period){const K=[U.mesh.position.x,U.mesh.position.y,U.mesh.position.z],Y=[U.mesh.rotation.x,U.mesh.rotation.y,U.mesh.rotation.z].map(se=>se*180/Math.PI),Q=U.mesh.scale.x;console.log({position:K,rotation:Y,scale:Q})}}let N=0,W=0;if(ee.lengthSq()>0){ee.normalize().multiplyScalar(l.MOVE_SPEED);const L=ee.clone(),K=J(L);if(N=K.x,W=K.z,G&&c){const Y=new ce().setFromUnitVectors(new F(0,0,1),new F(L.x,0,L.z).normalize());c.setRotation(Y)}}let b=c.linvel().y;l.movable_ground?(O.KeyR&&(z+=l.movable_ground),O.KeyF&&(z-=l.movable_ground)):(O.KeyR&&(b+=l.MOVE_SPEED),O.KeyF&&(b-=l.MOVE_SPEED)),c.setLinvel({x:N,y:b,z:W},!0)}function J(q){const X=q.clone();if(X.lengthSq()===0)return X;const ie=c.translation(),ee=new F(X.x,0,X.z);if(ee.length()===0)return X;ee.normalize();const N={x:ie.x,y:ie.y,z:ie.z},W={x:ee.x,y:0,z:ee.z},R=new li(N,W),b=hs+.1,K=o.castRayAndGetNormal(R,b,!0)?.normal;if(K){const Y=new F(K.x,K.y,K.z);if(Y.y=0,Y.lengthSq()>1e-4){Y.normalize();const Q=X.dot(Y);Q>0&&X.addScaledVector(Y,-Q)}}return X}let ue=performance.now(),me=0;function de(q){requestAnimationFrame(de);const X=Math.min((q-ue)/1e3,.1);if(ue=q,k){te(),me+=X;const ie=Math.min(Math.floor(me/Fo),Cp);for(let ee=0;ee<ie;ee++)o.step(),me-=Fo;if(G&&c){const ee=c.translation(),S=c.rotation();G.character.currentVrm.scene.position.set(ee.x,ee.y-1,ee.z),G.character.currentVrm.scene.quaternion.set(S.z,S.w,-S.x,-S.y),G.update()}if(c){const ee=c.translation(),S=ee.y-(fr+hs);if(t.position.set(ee.x,S+wp+z,ee.z),G){const N=new F;t.getWorldDirection(N),N.setY(0).normalize(),t.position.addScaledVector(N,-2)}}}fe(),n.render(e,t)}function fe(){if(U.mesh&&U.savedEmissive!=null){const N=U.mesh.material;N&&N.emissive&&N.emissive.setHex(U.savedEmissive)}U={mesh:null,savedEmissive:null};const q=new Xl;q.far=l.INTERACTION.MAX_DISTANCE,t.updateMatrixWorld(),q.setFromCamera({x:0,y:0},t);const X=q.intersectObjects(_,!1);if(!X||X.length===0)return;const ie=X.find(N=>N.distance<=l.INTERACTION.MAX_DISTANCE);if(!ie)return;const ee=ie.object;if(!ee||!a.has(ee))return;const S=ee.material;S&&S.emissive&&(U={mesh:ee,savedEmissive:S.emissive.getHex()},S.emissive.setHex(16776960))}window.addEventListener("resize",()=>{t.aspect=window.innerWidth/window.innerHeight,t.updateProjectionMatrix(),n.setSize(window.innerWidth,window.innerHeight)}),de(ue),console.log(" Tavern demo initialized successfully!")}const Mp=new URLSearchParams(window.location.search).get("model");fetch(`${Mp}.json`).then(l=>l.json()).then(l=>Tp(l));
